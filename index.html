<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Doom-style Shooter</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: black;
            transition: background-color 0.15s;
        }
        #game-container { 
            width: 100vw; 
            height: 100vh; 
            display: none;
        }
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #ff0000;
            font-size: 24px;
            text-shadow: 2px 2px 2px black;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: red;
        }

        /* Vertical line */
        #crosshair::before {
            left: 50%;
            top: 0;
            width: 2px;
            height: 20px;
            transform: translateX(-50%);
        }

        /* Horizontal line */
        #crosshair::after {
            top: 50%;
            left: 0;
            width: 20px;
            height: 2px;
            transform: translateY(-50%);
        }

        /* Gap in the center */
        #crosshair::before {
            background: linear-gradient(to bottom, 
                red 0%, 
                red 45%, 
                transparent 45%, 
                transparent 55%, 
                red 55%, 
                red 100%
            );
        }

        #crosshair::after {
            background: linear-gradient(to right, 
                red 0%, 
                red 45%, 
                transparent 45%, 
                transparent 55%, 
                red 55%, 
                red 100%
            );
        }
    /* Blood overlay for player damage */
    #screen-blood-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        background: radial-gradient(ellipse at center, transparent 50%, rgba(255,0,0,0.5) 100%);
        opacity: 0;
        transition: opacity 0.5s;
        z-index: 100;
        display: none;
    }
    #mode-selection {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        padding: 30px;
        border: 2px solid #ff0000;
        color: white;
        text-align: center;
        font-family: Arial, sans-serif;
        z-index: 1000;
    }
    .mode-button {
        display: block;
        width: 200px;
        padding: 15px;
        margin: 10px auto;
        background: #ff0000;
        color: white;
        border: none;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.3s;
    }
    .mode-button:hover {
        background: #cc0000;
    }
    </style>
</head>
<body>
    <div id="mode-selection">
        <h2>Select Game Mode</h2>
        <button class="mode-button" onclick="startGame('testing')">Testing Mode</button>
        <button class="mode-button" onclick="startGame('normal')">Normal Mode</button>
    </div>
    <div id="game-container">
        <div id="hud">
            Level: <span id="level">1</span> | 
            Enemies: <span id="enemies">5</span>
        </div>
        <div id="crosshair"></div>
    <div id="screen-blood-overlay"></div>
        <div id="pause-menu" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: rgba(0,0,0,0.8); padding: 20px; color: red; text-align: center; border: 2px solid red;">
            <h2>PAUSED</h2>
            <p>Press ESC to resume</p>
            <p>Current Level: <span id="pause-level">1</span></p>
            <p>Enemies Remaining: <span id="pause-enemies">5</span></p>
        </div>
        <canvas id="minimap" style="position: fixed; top: 20px; right: 20px;"></canvas>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <script>
        class Monster {
            constructor(game) {
                this.game = game;
                this.mesh = new THREE.Group();
                this.health = 100;
                this.speed = game.config.monsterSpeed;
                this.damage = game.config.monsterDamage;
                this.detectionRadius = 15;
                this.attackRange = 2.0;
                this.attackCooldown = 1000;
                this.lastAttackTime = 0;
                this.state = "patrolling";
                this.patrolTimeRemaining = 0;
                this.animationTime = Math.random() * Math.PI * 2;
                this.animationSpeed = 0.1;
                this.isGrounded = true;
                this.baseHeight = 0;
            }

            createMesh() {
                // To be implemented by subclasses
                throw new Error("createMesh must be implemented by subclass");
            }

            update() {
                // To be implemented by subclasses
                throw new Error("update must be implemented by subclass");
            }

            takeDamage(damage) {
                this.health -= damage;
                return this.health <= 0;
            }

            findValidPosition() {
                let validPosition = false;
                let attempts = 0;
                const maxAttempts = 100;
                
                while (!validPosition && attempts < maxAttempts) {
                    attempts++;
                    
                    const gridX = Math.floor(Math.random() * (this.game.config.mazeSize - 2)) + 1;
                    const gridZ = Math.floor(Math.random() * (this.game.config.mazeSize - 2)) + 1;
                    
                    const x = (gridX - this.game.config.mazeSize/2) * this.game.config.cellSize;
                    const z = (gridZ - this.game.config.mazeSize/2) * this.game.config.cellSize;
                    
                    this.mesh.position.set(x, this.baseHeight, z);
                    
                    if (!this.game.checkCollision(this.mesh.position, true) && 
                        this.mesh.position.distanceTo(this.game.camera.position) > 10) {
                        validPosition = true;
                    }
                }
                
                if (!validPosition) {
                    console.warn("Could not find valid position for monster");
                    this.mesh.position.set(0, this.baseHeight, 0);
                }
            }
        }

        class GroundMonster extends Monster {
            constructor(game) {
                super(game);
                this.createMesh();
                this.findValidPosition();
            }

            createMesh() {
                // Create a zombie-like monster with decaying features
                
                // 1. Head - make it more zombie-like with pale skin and sunken features
                const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xc1d5c0, // Pale greenish skin
                    roughness: 0.9,
                    metalness: 0.1,
                    emissive: 0x003300,
                    emissiveIntensity: 0.2
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.8;
                
                // Add sunken glowing eyes
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff3300,
                    emissive: 0xff0000,
                    emissiveIntensity: 1
                });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.15, 0.05, 0.2);
                rightEye.position.set(0.15, 0.05, 0.2);
                leftEye.scale.y = 0.5; // Make eyes more sunken
                rightEye.scale.y = 0.5;
                head.add(leftEye);
                head.add(rightEye);
                
                // Add eye glow lights
                const leftLight = new THREE.PointLight(0xff0000, 1, 0.5);
                const rightLight = new THREE.PointLight(0xff0000, 1, 0.5);
                leftEye.add(leftLight);
                rightEye.add(rightLight);
                
                // Add decaying teeth
                const teethGeometry = new THREE.ConeGeometry(0.05, 0.15, 3); // More jagged teeth
                const teethMaterial = new THREE.MeshStandardMaterial({
                    color: 0xd6c48f, // Yellowed teeth
                    roughness: 0.8
                });
                
                for (let i = 0; i < 6; i++) {
                    const tooth = new THREE.Mesh(teethGeometry, teethMaterial);
                    tooth.position.set(
                        (i - 2.5) * 0.08,
                        -0.15,
                        0.2
                    );
                    tooth.rotation.x = 0.3 + Math.random() * 0.2; // Random rotation for broken look
                    tooth.rotation.z = Math.random() * 0.2 - 0.1;
                    head.add(tooth);
                }
                
                // 2. Torso - tattered and decaying
                const torsoGeometry = new THREE.BoxGeometry(0.6, 1.0, 0.6);
                const torsoMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x556677, // Dirty, tattered shirt
                    roughness: 1.0,
                    metalness: 0.0,
                    emissive: 0x000000,
                    emissiveIntensity: 0.1
                });
                const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
                torso.position.y = 1.1;
                
                // Add torn flesh effects
                const woundGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.1);
                const woundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x660000,
                    roughness: 0.7,
                    metalness: 0.3,
                    emissive: 0x330000,
                    emissiveIntensity: 0.2
                });
                
                for (let i = 0; i < 3; i++) {
                    const wound = new THREE.Mesh(woundGeometry, woundMaterial);
                    wound.position.set(
                        Math.random() * 0.4 - 0.2,
                        Math.random() * 0.8 - 0.4,
                        0.31
                    );
                    wound.rotation.z = Math.random() * Math.PI / 4;
                    torso.add(wound);
                }
                
                // 3. Arms - decaying with exposed bones
                const armGeometry = new THREE.CylinderGeometry(0.12, 0.08, 0.8, 8);
                const armMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xc1d5c0, // Matching skin tone
                    roughness: 0.9,
                    metalness: 0.1,
                    emissive: 0x003300,
                    emissiveIntensity: 0.2
                });
                
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                
                // Update arm positions and rotations for zombie pose
                // Position arms at shoulder height and move them forward
                leftArm.position.set(-0.2, 1.2, 0.3); // Moved forward (z positive)
                rightArm.position.set(0.2, 1.2, 0.3);
                
                // Rotate arms to point forward
                leftArm.rotation.x = -Math.PI / 2.5;  // Angle forward
                rightArm.rotation.x = -Math.PI / 2.5;

                
                // Store original rotations for animation
                leftArm.userData = { originalRotation: leftArm.rotation.clone() };
                rightArm.userData = { originalRotation: rightArm.rotation.clone() };
                
                // Add bone protrusions
                const boneGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.15, 4);
                const boneMaterial = new THREE.MeshStandardMaterial({
                    color: 0xf0f0e0,
                    roughness: 0.5,
                    metalness: 0.2
                });
                
                for (let arm of [leftArm, rightArm]) {
                    const bone = new THREE.Mesh(boneGeometry, boneMaterial);
                    bone.position.set(0, -0.2, 0.1);
                    bone.rotation.x = Math.PI / 6;
                    arm.add(bone);
                }
                
                // Add zombie claws - adjust claw positions for new arm orientation
                const clawGeometry = new THREE.ConeGeometry(0.05, 0.25, 4);
                const clawMaterial = new THREE.MeshStandardMaterial({
                    color: 0x222222,
                    metalness: 0.4,
                    roughness: 0.9
                });
                
                for (let arm of [leftArm, rightArm]) {
                    for (let i = 0; i < 3; i++) {
                        const claw = new THREE.Mesh(clawGeometry, clawMaterial);
                        claw.position.set(
                            (i - 1) * 0.06,
                            -0.4,
                            0
                        );
                        claw.rotation.x = Math.PI / 6; // Adjust claw angle for new arm position
                        arm.add(claw);
                    }
                }
                
                // 4. Legs - torn pants and decaying flesh
                const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 1.0, 8);
                const legMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333366, // Dark torn pants
                    roughness: 1.0,
                    metalness: 0.0
                });
                
                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                
                leftLeg.position.set(-0.15, 0.5, 0);
                rightLeg.position.set(0.15, 0.5, 0);
                
                // Add torn pants effect
                const tearGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.02);
                const tearMaterial = new THREE.MeshStandardMaterial({
                    color: 0xc1d5c0, // Exposed flesh
                    roughness: 0.9,
                    metalness: 0.1
                });
                
                for (let leg of [leftLeg, rightLeg]) {
                    for (let i = 0; i < 2; i++) {
                        const tear = new THREE.Mesh(tearGeometry, tearMaterial);
                        tear.position.set(
                            0,
                            Math.random() * 0.6 - 0.3,
                            0.11
                        );
                        tear.rotation.z = Math.random() * Math.PI / 4;
                        leg.add(tear);
                    }
                }
                
                // Add all parts to the monster mesh
                this.mesh.add(head);
                this.mesh.add(torso);
                this.mesh.add(leftArm);
                this.mesh.add(rightArm);
                this.mesh.add(leftLeg);
                this.mesh.add(rightLeg);
                
                // Store references for animation
                this.parts = {
                    head, torso, leftArm, rightArm, leftLeg, rightLeg,
                    originalPositions: {
                        head: head.position.clone(),
                        torso: torso.position.clone(),
                        leftArm: leftArm.position.clone(),
                        rightArm: rightArm.position.clone(),
                        leftLeg: leftLeg.position.clone(),
                        rightLeg: rightLeg.position.clone()
                    }
                };
            }

            update() {
                // Force ground level
                this.mesh.position.y = this.baseHeight;

                // Direction to player
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, this.mesh.position)
                    .normalize();
                directionToPlayer.y = 0;

                const distanceToPlayer = this.mesh.position.distanceTo(this.game.camera.position);
                const isChasing = distanceToPlayer <= this.detectionRadius;
                this.state = isChasing ? "chasing" : "patrolling";
                
                let speed = this.speed;
                let moveDirection = new THREE.Vector3();
                
                if (isChasing) {
                    speed *= 1.5;
                    moveDirection.copy(directionToPlayer);
                    
                    // Attack if close enough
                    if (distanceToPlayer <= this.attackRange && !this.game.state.powerups.invincibility.active) {
                        const currentTime = Date.now();
                        if (currentTime - this.lastAttackTime >= this.attackCooldown) {
                            // Apply melee damage
                            this.game.state.health -= this.damage;
                            this.lastAttackTime = currentTime;
                            
                            // Visual feedback
                            document.body.style.backgroundColor = 'rgba(255,0,0,0.7)';
                            setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                            
                            const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                            if (screenBloodOverlay) {
                                screenBloodOverlay.style.opacity = '0.9';
                                setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                            }
                            
                            this.game.playSound(100, 0.1, 'square', 0.3);
                            this.game.playSound(50, 0.3, 'sawtooth', 0.3);
                            this.game.updateHUD();
                            this.game.updateHealthBar();
                            
                            if (this.game.state.health <= 0) {
                                this.game.gameOver();
                            }
                        }
                    }
                } else {
                    // Patrol logic
                    if (!this.patrolDirection || this.patrolTimeRemaining <= 0) {
                        this.patrolDirection = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            0,
                            Math.random() * 2 - 1
                        ).normalize();
                        this.patrolTimeRemaining = 60;
                    }
                    moveDirection.copy(this.patrolDirection);
                    this.patrolTimeRemaining--;
                }
                
                // Movement and collision
                const currentPos = this.mesh.position.clone();
                const newPosition = currentPos.clone().add(moveDirection.multiplyScalar(speed));
                
                if (!this.game.checkCollision(new THREE.Vector3(newPosition.x, currentPos.y, currentPos.z), true)) {
                    this.mesh.position.x = newPosition.x;
                }
                if (!this.game.checkCollision(new THREE.Vector3(this.mesh.position.x, currentPos.y, newPosition.z), true)) {
                    this.mesh.position.z = newPosition.z;
                }
                
                // Update orientation
                if (moveDirection.lengthSq() > 0) {
                    const facePos = this.mesh.position.clone().add(moveDirection);
                    this.mesh.lookAt(facePos);
                }
                
                // Animation
                this.animationTime += this.animationSpeed;
                const walkCycle = Math.sin(this.animationTime);
                const swingAmount = isChasing ? 0.3 : 0.2;
                
                // Animate limbs
                if (moveDirection.lengthSq() > 0) {
                    this.parts.leftArm.position.z = this.parts.originalPositions.leftArm.z + walkCycle * swingAmount;
                    this.parts.rightArm.position.z = this.parts.originalPositions.rightArm.z - walkCycle * swingAmount;
                    this.parts.leftLeg.position.z = this.parts.originalPositions.leftLeg.z - walkCycle * swingAmount;
                    this.parts.rightLeg.position.z = this.parts.originalPositions.rightLeg.z + walkCycle * swingAmount;
                    
                    const bounceHeight = isChasing ? 0.05 : 0.03;
                    const bounceOffset = Math.abs(Math.sin(this.animationTime * 2)) * bounceHeight;
                    this.parts.torso.position.y = this.parts.originalPositions.torso.y + bounceOffset;
                    this.parts.head.position.y = this.parts.originalPositions.head.y + bounceOffset;
                }
            }

            checkHit(projectilePosition) {
                // Get relative position from monster to projectile
                const relativePos = new THREE.Vector3().subVectors(projectilePosition, this.mesh.position);
                
                // Transform relative position to account for monster's rotation
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(-this.mesh.rotation.y);
                relativePos.applyMatrix4(rotationMatrix);

                // Define simplified hit regions with their bounds and damage multipliers
                // Made hit boxes more generous and added overlap between regions
                const hitRegions = {
                    head: {
                        bounds: {
                            x: [-0.5, 0.5],    // Wider head hitbox
                            y: [1.6, 2.2],     // Lower starting point for head
                            z: [-0.5, 0.5]     // Deeper head hitbox
                        },
                        multiplier: 2.0  // Headshots do double damage
                    },
                    body: {
                        bounds: {
                            x: [-0.5, 0.5],    // Wider body hitbox
                            y: [0, 1.6],       // Overlaps slightly with head
                            z: [-0.5, 0.5]     // Deeper body hitbox
                        },
                        multiplier: 1.0  // Normal damage for body shots
                    }
                };

                // Debug hit detection
                //console.log(`Hit check at relative position: (${relativePos.x.toFixed(2)}, ${relativePos.y.toFixed(2)}, ${relativePos.z.toFixed(2)})`);

                // Check each hit region
                for (const [region, data] of Object.entries(hitRegions)) {
                    if (this.isPointInBounds(relativePos, data.bounds)) {
                        //console.log(`Hit registered in ${region} region!`);
                        return {
                            hit: true,
                            region: region,
                            multiplier: data.multiplier
                        };
                    }
                }

                // If no hit registered, log the miss
                //console.log('No hit registered - projectile outside all hit regions');
                return { hit: false };
            }

            isPointInBounds(point, bounds) {
                const inBounds = point.x >= bounds.x[0] && point.x <= bounds.x[1] &&
                       point.y >= bounds.y[0] && point.y <= bounds.y[1] &&
                       point.z >= bounds.z[0] && point.z <= bounds.z[1];
                
                // Debug bounds check
                // if (!inBounds) {
                //     const failedAxis = [];
                //   if (point.x < bounds.x[0] || point.x > bounds.x[1]) failedAxis.push('X');
                //   if (point.y < bounds.y[0] || point.y > bounds.y[1]) failedAxis.push('Y');
                //  if (point.z < bounds.z[0] || point.z > bounds.z[1]) failedAxis.push('Z');
                //  console.log(`Bounds check failed on axes: ${failedAxis.join(', ')}`);
                //  }
                
                return inBounds;
            }
        }

        class FlyingMonster extends Monster {
            constructor(game) {
                super(game);
                this.baseHeight = 3.0;
                this.health = 70;
                this.speed = game.config.monsterSpeed * 1.2;
                this.verticalSpeed = 0.05;  // Removed testing mode check
                this.verticalRange = 1.0;
                this.verticalPosition = 0;
                this.wingAnimationEnabled = true;  // Removed testing mode check
                this.createMesh();
                this.findValidPosition();
            }

            createMesh() {
                // Body
                const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: 0x000088,
                    emissive: 0x000033,
                    emissiveIntensity: 0.5,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.mesh.add(body);

                // Wings
                const wingGeometry = new THREE.BoxGeometry(2, 0.1, 0.8);
                const wingMaterial = new THREE.MeshStandardMaterial({
                    color: 0x0000aa,
                    emissive: 0x000066,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.8
                });
                
                const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                leftWing.position.set(-0.8, 0, 0);
                this.mesh.add(leftWing);
                
                const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                rightWing.position.set(0.8, 0, 0);
                this.mesh.add(rightWing);

                // Eyes
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.2, 0, 0.4);
                this.mesh.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.2, 0, 0.4);
                this.mesh.add(rightEye);

                // Add point light for glow effect
                const light = new THREE.PointLight(0x0000ff, 1, 2);
                this.mesh.add(light);

                // Store parts for animation
                this.parts = {
                    body,
                    leftWing,
                    rightWing,
                    originalPositions: {
                        leftWing: leftWing.position.clone(),
                        rightWing: rightWing.position.clone()
                    }
                };
            }

            update() {
                // Direction to player
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, this.mesh.position)
                    .normalize();
                directionToPlayer.y = 0;

                const distanceToPlayer = this.mesh.position.distanceTo(this.game.camera.position);
                const isChasing = distanceToPlayer <= this.detectionRadius;
                this.state = isChasing ? "chasing" : "patrolling";
                
                let speed = this.speed;
                let moveDirection = new THREE.Vector3();
                
                if (isChasing) {
                    speed *= 1.5;
                    moveDirection.copy(directionToPlayer);
                    moveDirection.y = 0; // Keep vertical movement separate
                } else {
                    if (!this.patrolDirection || this.patrolTimeRemaining <= 0) {
                        this.patrolDirection = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            0,
                            Math.random() * 2 - 1
                        ).normalize();
                        this.patrolTimeRemaining = 60;
                    }
                    moveDirection.copy(this.patrolDirection);
                    this.patrolTimeRemaining--;
                }
                
                // Movement and collision
                const currentPos = this.mesh.position.clone();
                const newPosition = currentPos.clone().add(moveDirection.multiplyScalar(speed));
                
                if (!this.game.checkCollision(new THREE.Vector3(newPosition.x, currentPos.y, currentPos.z), true)) {
                    this.mesh.position.x = newPosition.x;
                }
                if (!this.game.checkCollision(new THREE.Vector3(this.mesh.position.x, currentPos.y, newPosition.z), true)) {
                    this.mesh.position.z = newPosition.z;
                }
                
                // Update orientation
                if (moveDirection.lengthSq() > 0) {
                    const facePos = this.mesh.position.clone().add(moveDirection);
                    this.mesh.lookAt(facePos);
                }
                
                // Only update vertical position and wing animation if not in testing mode

                // Vertical movement
                this.verticalPosition += this.verticalSpeed;
                if (Math.abs(this.verticalPosition) > this.verticalRange) {
                    this.verticalSpeed = -this.verticalSpeed;
                }
                this.mesh.position.y = this.baseHeight + this.verticalPosition;

                // Wing animation
                this.animationTime += this.animationSpeed * 2;
                const wingFlap = Math.sin(this.animationTime) * 0.5;
                // Find wing meshes by their position (they're positioned at x: ±0.8)
                this.mesh.children.forEach(child => {
                    if (child.position.x < -0.5) {  // Left wing
                        child.rotation.z = wingFlap;
                    } else if (child.position.x > 0.5) {  // Right wing
                        child.rotation.z = -wingFlap;
                    }
                });
                
                
                // Attack logic
                if (distanceToPlayer < this.attackRange && !this.game.state.powerups.invincibility.active) {
                    const currentTime = Date.now();
                    if (currentTime - this.lastAttackTime >= this.attackCooldown) {
                        this.game.state.health -= this.damage;
                        this.lastAttackTime = currentTime;
                        
                        // Visual feedback
                        document.body.style.backgroundColor = 'rgba(0,0,255,0.7)';
                        setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                        
                        const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                        if (screenBloodOverlay) {
                            screenBloodOverlay.style.opacity = '0.9';
                            setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                        }
                        
                        this.game.playSound(200, 0.1, 'sine', 0.3);
                        this.game.updateHUD();
                        this.game.updateHealthBar();
                        
                        if (this.game.state.health <= 0) {
                            this.game.gameOver();
                        }
                    }
                }
            }

            checkHit(projectilePosition) {
                // Get relative position from monster to projectile
                const relativePos = new THREE.Vector3().subVectors(projectilePosition, this.mesh.position);
                
                // Transform relative position to account for monster's rotation
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(-this.mesh.rotation.y);
                relativePos.applyMatrix4(rotationMatrix);

                // Define hit regions with their bounds and damage multipliers
                const hitRegions = {
                    body: {
                        bounds: {
                            x: [-0.5, 0.5],
                            y: [-0.5, 0.5],
                            z: [-0.5, 0.5]
                        },
                        multiplier: 1.0  // Normal damage for body shots
                    },
                    wings: {
                        bounds: [
                            {  // Left wing
                                x: [-1.8, -0.5],
                                y: [-0.25, 0.25],
                                z: [-0.5, 0.5]
                            },
                            {  // Right wing
                                x: [0.5, 1.8],
                                y: [-0.25, 0.25],
                                z: [-0.5, 0.5]
                            }
                        ],
                        multiplier: 1.5  // Wings are more vulnerable
                    }
                };

                // Check each hit region
                for (const [region, data] of Object.entries(hitRegions)) {
                    if (Array.isArray(data.bounds)) {
                        // For regions with multiple parts (like wings)
                        for (const partBounds of data.bounds) {
                            if (this.isPointInBounds(relativePos, partBounds)) {
                                return {
                                    hit: true,
                                    region: region,
                                    multiplier: data.multiplier
                                };
                            }
                        }
                    } else {
                        // For single regions (like body)
                        if (this.isPointInBounds(relativePos, data.bounds)) {
                            return {
                                hit: true,
                                region: region,
                                multiplier: data.multiplier
                            };
                        }
                    }
                }

                return { hit: false };
            }

            isPointInBounds(point, bounds) {
                return point.x >= bounds.x[0] && point.x <= bounds.x[1] &&
                       point.y >= bounds.y[0] && point.y <= bounds.y[1] &&
                       point.z >= bounds.z[0] && point.z <= bounds.z[1];
            }
        }

        class ArcherMonster extends Monster {
            constructor(game) {
                super(game);
                this.baseHeight = 0;
                this.health = 70;
                this.speed = game.config.monsterSpeed * 0.8; // Slightly slower than ground monster
                this.damage = game.config.monsterDamage * 0.7; // Less damage for close combat
                this.detectionRadius = 20; // Longer detection range
                this.attackRange = 15.0; // Much longer attack range for arrows
                this.attackCooldown = 2000; // Longer cooldown for bow attacks
                this.arrowSpeed = 0.3;
                this.arrowDamage = game.config.monsterDamage * 1.2; // More damage for arrows
                this.createMesh();
                this.findValidPosition();
            }

            createMesh() {
                // Create a zombie-like archer with decaying features
                const archerGroup = new THREE.Group();
                
                // 1. Head - zombie-like with pale skin and sunken features
                const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xc1d5c0, // Pale greenish skin
                    roughness: 0.9,
                    metalness: 0.1,
                    emissive: 0x003300,
                    emissiveIntensity: 0.2
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.8;
                
                // Add sunken glowing eyes
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff3300,
                    emissive: 0xff0000,
                    emissiveIntensity: 1
                });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.15, 0.05, 0.2);
                rightEye.position.set(0.15, 0.05, 0.2);
                leftEye.scale.y = 0.5;
                rightEye.scale.y = 0.5;
                head.add(leftEye);
                head.add(rightEye);
                
                // Add eye glow
                const leftLight = new THREE.PointLight(0xff0000, 1, 0.5);
                const rightLight = new THREE.PointLight(0xff0000, 1, 0.5);
                leftEye.add(leftLight);
                rightEye.add(rightLight);
                
                // 2. Torso - tattered and decaying
                const torsoGeometry = new THREE.BoxGeometry(0.6, 1.0, 0.6);
                const torsoMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x556677,
                    roughness: 1.0,
                    metalness: 0.0
                });
                const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
                torso.position.y = 1.1;
                
                // Add torn flesh effects
                const woundGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.1);
                const woundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x660000,
                    roughness: 0.7,
                    metalness: 0.3,
                    emissive: 0x330000,
                    emissiveIntensity: 0.2
                });
                
                for (let i = 0; i < 3; i++) {
                    const wound = new THREE.Mesh(woundGeometry, woundMaterial);
                    wound.position.set(
                        Math.random() * 0.4 - 0.2,
                        Math.random() * 0.8 - 0.4,
                        0.31
                    );
                    wound.rotation.z = Math.random() * Math.PI / 4;
                    torso.add(wound);
                }
                
                // 3. Arms - decaying with exposed bones
                const armGeometry = new THREE.CylinderGeometry(0.12, 0.08, 0.8, 8);
                const armMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xc1d5c0,
                    roughness: 0.9,
                    metalness: 0.1
                });
                
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                
                // Position arms for bow holding pose
                leftArm.position.set(-0.4, 1.4, 0);
                rightArm.position.set(0.4, 1.4, 0);
                
                // Rotate arms for bow holding pose
                leftArm.rotation.z = Math.PI / 4;
                rightArm.rotation.z = -Math.PI / 4;
                
                // 4. Bow
                const bowGroup = new THREE.Group();
                
                // Main bow curve
                const bowGeometry = new THREE.TorusGeometry(0.5, 0.05, 8, 16, Math.PI);
                const bowMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    roughness: 0.7,
                    metalness: 0.3
                });
                const bow = new THREE.Mesh(bowGeometry, bowMaterial);
                
                // Bowstring
                const stringGeometry = new THREE.CylinderGeometry(0.01, 0.01, 1, 4);
                const stringMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc });
                const bowstring = new THREE.Mesh(stringGeometry, stringMaterial);
                
                bowGroup.add(bow);
                bowGroup.add(bowstring);
                bowGroup.position.set(0.4, 1.4, 0.3);
                bowGroup.rotation.y = Math.PI / 2;
                
                // 5. Legs
                const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 1.0, 8);
                const legMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333366
                });
                
                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                
                leftLeg.position.set(-0.2, 0.5, 0);
                rightLeg.position.set(0.2, 0.5, 0);
                
                // Add all parts to the archer mesh
                archerGroup.add(head);
                archerGroup.add(torso);
                archerGroup.add(leftArm);
                archerGroup.add(rightArm);
                archerGroup.add(leftLeg);
                archerGroup.add(rightLeg);
                archerGroup.add(bowGroup);
                
                this.mesh = archerGroup;
                
                // Store references for animation
                this.parts = {
                    head, torso, leftArm, rightArm, leftLeg, rightLeg, bow: bowGroup,
                    originalPositions: {
                        head: head.position.clone(),
                        torso: torso.position.clone(),
                        leftArm: leftArm.position.clone(),
                        rightArm: rightArm.position.clone(),
                        leftLeg: leftLeg.position.clone(),
                        rightLeg: rightLeg.position.clone(),
                        bow: bowGroup.position.clone()
                    }
                };
            }

            update() {
                // Force ground level and prevent falling
                this.mesh.position.y = this.baseHeight;

                // Direction to player
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, this.mesh.position)
                    .normalize();
                directionToPlayer.y = 0;

                const distanceToPlayer = this.mesh.position.distanceTo(this.game.camera.position);
                const isChasing = distanceToPlayer <= this.detectionRadius;
                this.state = isChasing ? "chasing" : "patrolling";
                
                let speed = this.speed;
                let moveDirection = new THREE.Vector3();
                
                if (isChasing) {
                    // Always face the player
                    const lookAtPos = new THREE.Vector3(
                        this.game.camera.position.x,
                        this.mesh.position.y,  // Keep y-level consistent
                        this.game.camera.position.z
                    );
                    this.mesh.lookAt(lookAtPos);
                    
                    // If too close to player, back away
                    const optimalRange = this.attackRange * 0.7; // Try to stay at 70% of max attack range
                    if (distanceToPlayer < optimalRange) {
                        // Move away from player
                        moveDirection.copy(directionToPlayer).negate();
                        speed *= 1.5; // Move away faster
                    } else if (distanceToPlayer > this.attackRange) {
                        // Move closer to player
                        moveDirection.copy(directionToPlayer);
                        speed *= 1.2;
                    } else {
                        // At good range, strafe sideways
                        const right = new THREE.Vector3().crossVectors(directionToPlayer, new THREE.Vector3(0, 1, 0));
                        moveDirection.copy(right).multiplyScalar(Math.sin(this.animationTime));
                        speed *= 0.8; // Slower when strafing
                    }
                    
                    // Check if we can shoot at the player
                    const currentTime = Date.now();
                    const canShoot = currentTime - this.lastAttackTime >= this.attackCooldown;
                    const inRange = distanceToPlayer <= this.attackRange;
                    const hasLineOfSight = !this.game.checkCollision(
                        new THREE.Vector3(
                            this.mesh.position.x + directionToPlayer.x * distanceToPlayer * 0.5,
                            this.mesh.position.y,
                            this.mesh.position.z + directionToPlayer.z * distanceToPlayer * 0.5
                        ),
                        false,
                        true
                    );

                    // Attack with bow if conditions are met
                    if (inRange && canShoot && hasLineOfSight && !this.game.state.powerups.invincibility.active) {
                        this.shootArrow();
                        this.lastAttackTime = currentTime;
                    }
                } else {
                    // Patrol logic
                    if (!this.patrolDirection || this.patrolTimeRemaining <= 0) {
                        this.patrolDirection = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            0,
                            Math.random() * 2 - 1
                        ).normalize();
                        this.patrolTimeRemaining = 60;
                    }
                    moveDirection.copy(this.patrolDirection);
                    this.patrolTimeRemaining--;
                    
                    // Update orientation for patrol
                    const facePos = this.mesh.position.clone().add(moveDirection);
                    facePos.y = this.mesh.position.y;  // Keep y-level consistent
                    this.mesh.lookAt(facePos);
                }
                
                // Movement and collision
                if (moveDirection.lengthSq() > 0) {
                    const currentPos = this.mesh.position.clone();
                    const moveAttempt = moveDirection.clone().multiplyScalar(speed);
                    
                    // Try X movement
                    const newPosX = currentPos.clone();
                    newPosX.x += moveAttempt.x;
                    if (!this.game.checkCollision(newPosX, true)) {
                        this.mesh.position.x = newPosX.x;
                    }
                    
                    // Try Z movement
                    const newPosZ = currentPos.clone();
                    newPosZ.z += moveAttempt.z;
                    if (!this.game.checkCollision(newPosZ, true)) {
                        this.mesh.position.z = newPosZ.z;
                    }
                }
                
                // Animation
                this.animationTime += this.animationSpeed;
                const walkCycle = Math.sin(this.animationTime);
                const swingAmount = isChasing ? 0.2 : 0.15;
                
                // Animate limbs
                if (moveDirection.lengthSq() > 0) {
                    this.parts.leftLeg.position.z = this.parts.originalPositions.leftLeg.z - walkCycle * swingAmount;
                    this.parts.rightLeg.position.z = this.parts.originalPositions.rightLeg.z + walkCycle * swingAmount;
                    
                    const bounceHeight = isChasing ? 0.03 : 0.02;
                    const bounceOffset = Math.abs(Math.sin(this.animationTime * 2)) * bounceHeight;
                    this.parts.torso.position.y = this.parts.originalPositions.torso.y + bounceOffset;
                    this.parts.head.position.y = this.parts.originalPositions.head.y + bounceOffset;
                }
            }

            shootArrow() {
                // Create arrow
                const arrowGroup = new THREE.Group();
                
                // Arrow shaft - made larger for visibility
                const shaftGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.6, 8);
                const shaftMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    metalness: 0.3,
                    roughness: 0.7,
                    emissive: 0x3a1707,
                    emissiveIntensity: 0.3
                });
                const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
                
                // Arrow head - made larger
                const headGeometry = new THREE.ConeGeometry(0.08, 0.2, 8);
                const headMaterial = new THREE.MeshStandardMaterial({
                    color: 0x666666,
                    metalness: 0.8,
                    roughness: 0.2,
                    emissive: 0x333333,
                    emissiveIntensity: 0.3
                });
                const arrowHead = new THREE.Mesh(headGeometry, headMaterial);
                arrowHead.position.y = 0.4;
                
                // Arrow fletching - made larger and more visible
                const fletchingGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.02);
                const fletchingMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff0000,
                    metalness: 0.1,
                    roughness: 0.9,
                    emissive: 0x660000,
                    emissiveIntensity: 0.5
                });
                
                const fletching1 = new THREE.Mesh(fletchingGeometry, fletchingMaterial);
                const fletching2 = new THREE.Mesh(fletchingGeometry, fletchingMaterial);
                fletching1.position.y = -0.25;
                fletching2.position.y = -0.25;
                fletching1.rotation.y = Math.PI / 4;
                fletching2.rotation.y = -Math.PI / 4;
                
                arrowGroup.add(shaft);
                arrowGroup.add(arrowHead);
                arrowGroup.add(fletching1);
                arrowGroup.add(fletching2);
                
                // Add a point light to make arrow more visible
                const arrowLight = new THREE.PointLight(0xff6600, 0.5, 2);
                arrowLight.position.set(0, 0, 0);
                arrowGroup.add(arrowLight);
                
                // Position and orient arrow - adjusted spawn position
                arrowGroup.position.copy(this.mesh.position);
                arrowGroup.position.y += 1.4; // Shoot from bow height
                arrowGroup.position.z += this.mesh.rotation.y; // Offset based on archer's rotation
                
                // Calculate direction to player with slight randomness
                const spread = 0.1;
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, arrowGroup.position)
                    .normalize();
                
                // Add slight spread
                directionToPlayer.x += (Math.random() - 0.5) * spread;
                directionToPlayer.z += (Math.random() - 0.5) * spread;
                directionToPlayer.normalize();
                
                // Orient arrow
                arrowGroup.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), directionToPlayer);
                
                // Add arrow properties
                arrowGroup.userData = {
                    velocity: directionToPlayer.multiplyScalar(this.arrowSpeed),
                    damage: this.arrowDamage,
                    distance: 0,
                    maxDistance: 30,
                    isArrow: true,
                    isMonsterProjectile: true,  // Add this flag to identify monster projectiles
                    prevPosition: arrowGroup.position.clone(),
                    shooterId: this.mesh.uuid
                };
                
                // Add to game projectiles
                this.game.projectiles.push(arrowGroup);
                this.game.scene.add(arrowGroup);
                
                // Play sound effect
                this.game.playSound(440, 0.1, 'sine', 0.2);
            }

            checkHit(projectilePosition, projectile) {
                // Skip hit detection if the projectile was shot by this archer
                if (projectile && projectile.userData.shooterId === this.mesh.uuid) {
                    return { hit: false };
                }

                // Get relative position from monster to projectile
                const relativePos = new THREE.Vector3().subVectors(projectilePosition, this.mesh.position);
                
                // Transform relative position to account for monster's rotation
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(-this.mesh.rotation.y);
                relativePos.applyMatrix4(rotationMatrix);

                // Define hit regions with generous bounds
                const hitRegions = {
                    head: {
                        bounds: {
                            x: [-0.5, 0.5],    // Wide head hitbox
                            y: [1.6, 2.2],     // Head height range
                            z: [-0.5, 0.5]     // Deep head hitbox
                        },
                        multiplier: 2.0  // Headshots do double damage
                    },
                    body: {
                        bounds: {
                            x: [-0.5, 0.5],    // Wide body hitbox
                            y: [0, 1.6],       // Body height range
                            z: [-0.5, 0.5]     // Deep body hitbox
                        },
                        multiplier: 1.0  // Normal damage for body shots
                    },
                };

                // Check each hit region
                for (const [region, data] of Object.entries(hitRegions)) {
                    if (this.isPointInBounds(relativePos, data.bounds)) {
                        return {
                            hit: true,
                            region: region,
                            multiplier: data.multiplier
                        };
                    }
                }

                return { hit: false };
            }

            isPointInBounds(point, bounds) {
                return point.x >= bounds.x[0] && point.x <= bounds.x[1] &&
                       point.y >= bounds.y[0] && point.y <= bounds.y[1] &&
                       point.z >= bounds.z[0] && point.z <= bounds.z[1];
            }
        }

        class SpiderMonster extends Monster {
            constructor(game) {
                super(game);
                this.baseHeight = 0;
                this.health = 50;  // Low health
                this.speed = game.config.monsterSpeed * 2.0; // Twice as fast as normal monsters
                this.damage = game.config.monsterDamage * 0.5; // Half damage
                this.detectionRadius = 12;
                this.attackRange = 1.0;
                this.attackCooldown = 500; // Fast attacks
                this.jumpCooldown = 2000; // Time between jumps
                this.lastJumpTime = 0;
                this.jumpHeight = 2.0;
                this.jumpSpeed = 0.15;
                this.isJumping = false;
                this.jumpVelocity = 0;
                this.isOnWall = false;
                this.wallNormal = new THREE.Vector3();
                this.wallCrawlTime = 0;
                this.isAttacking = false;
                this.attackJumpTarget = null;
                this.createMesh();
                this.findValidPosition();
            }

            createMesh() {
                // Create spider body
                const bodyGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: 0x222222,
                    roughness: 0.7,
                    metalness: 0.3
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.2;

                // Create eyes (red and glowing)
                const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 1
                });

                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.08, 0.05, 0.15);
                rightEye.position.set(0.08, 0.05, 0.15);
                body.add(leftEye);
                body.add(rightEye);

                // Add eye glow
                const leftLight = new THREE.PointLight(0xff0000, 0.5, 0.5);
                const rightLight = new THREE.PointLight(0xff0000, 0.5, 0.5);
                leftEye.add(leftLight);
                rightEye.add(rightLight);

                // Create legs
                const legGeometry = new THREE.CylinderGeometry(0.02, 0.01, 0.3, 4);
                const legMaterial = new THREE.MeshStandardMaterial({
                    color: 0x111111,
                    roughness: 0.9,
                    metalness: 0.1
                });

                // Create 8 legs
                const legs = [];
                for (let i = 0; i < 8; i++) {
                    const leg = new THREE.Group();
                    
                    // Upper leg segment
                    const upperLeg = new THREE.Mesh(legGeometry, legMaterial);
                    upperLeg.position.y = -0.15;
                    
                    // Lower leg segment
                    const lowerLeg = new THREE.Mesh(legGeometry, legMaterial);
                    lowerLeg.position.y = -0.15;
                    
                    leg.add(upperLeg);
                    upperLeg.add(lowerLeg);
                    
                    // Position legs around body
                    const angle = (i * Math.PI / 4) + (Math.PI / 8);
                    leg.position.set(
                        Math.cos(angle) * 0.2,
                        0.2,
                        Math.sin(angle) * 0.2
                    );
                    
                    // Rotate legs outward
                    leg.rotation.z = -Math.PI / 4;
                    leg.rotation.y = angle;
                    
                    legs.push(leg);
                    this.mesh.add(leg);
                }

                this.mesh.add(body);
                
                // Store references for animation
                this.parts = {
                    body,
                    legs,
                    originalPositions: {
                        body: body.position.clone(),
                        legs: legs.map(leg => ({
                            position: leg.position.clone(),
                            rotation: leg.rotation.clone()
                        }))
                    }
                };
            }

            update() {
                // Direction to player
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, this.mesh.position)
                    .normalize();
                const distanceToPlayer = this.mesh.position.distanceTo(this.game.camera.position);
                const isChasing = distanceToPlayer <= this.detectionRadius;
                this.state = isChasing ? "chasing" : "patrolling";
                
                // Handle wall crawling
                if (!this.isJumping && !this.isAttacking) {
                    const nearestWallDir = this.game.findNearestWallDirection(this.mesh.position);
                    if (nearestWallDir) {
                        const wallDistance = nearestWallDir.length();
                        if (wallDistance < 0.5) {
                            this.isOnWall = true;
                            this.wallNormal = nearestWallDir.normalize();
                        } else {
                            this.isOnWall = false;
                        }
                    }
                }

                let speed = this.speed;
                let moveDirection = new THREE.Vector3();
                
                if (isChasing) {
                    speed *= 1.5;
                    
                    // Decide whether to attack jump
                    const currentTime = Date.now();
                    if (!this.isJumping && !this.isAttacking && 
                        currentTime - this.lastJumpTime >= this.jumpCooldown &&
                        distanceToPlayer <= this.detectionRadius && 
                        distanceToPlayer > this.attackRange) {
                        
                        // Higher chance to jump when closer to player
                        const jumpChance = Math.min(0.8, 1 - (distanceToPlayer / this.detectionRadius));
                        if (Math.random() < jumpChance) {
                            this.startAttackJump(this.game.camera.position.clone());
                        }
                    }

                    if (this.isAttacking) {
                        // Move towards attack target
                        if (this.attackJumpTarget) {
                            moveDirection.copy(this.attackJumpTarget)
                                .sub(this.mesh.position)
                                .normalize();
                            speed *= 2; // Faster during attack jump
                        }
                    } else if (!this.isJumping) {
                        moveDirection.copy(directionToPlayer);
                    }
                    
                    // Attack if close enough
                    if (distanceToPlayer <= this.attackRange && !this.game.state.powerups.invincibility.active) {
                        const currentTime = Date.now();
                        if (currentTime - this.lastAttackTime >= this.attackCooldown) {
                            this.game.state.health -= this.damage;
                            this.lastAttackTime = currentTime;
                            
                            // Visual feedback
                            document.body.style.backgroundColor = 'rgba(255,0,0,0.7)';
                            setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                            
                            const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                            if (screenBloodOverlay) {
                                screenBloodOverlay.style.opacity = '0.9';
                                setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                            }
                            
                            // Play bite sound
                            this.game.playSound(150, 0.1, 'square', 0.2);
                            this.game.updateHUD();
                            this.game.updateHealthBar();
                            
                            if (this.game.state.health <= 0) {
                                this.game.gameOver();
                            }
                        }
                    }
                } else {
                    // Patrol logic
                    if (!this.patrolDirection || this.patrolTimeRemaining <= 0) {
                        this.patrolDirection = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            0,
                            Math.random() * 2 - 1
                        ).normalize();
                        this.patrolTimeRemaining = 60;
                    }
                    moveDirection.copy(this.patrolDirection);
                    this.patrolTimeRemaining--;
                }
                
                // Apply wall crawling movement
                if (this.isOnWall && !this.isJumping && !this.isAttacking) {
                    this.wallCrawlTime += 0.1;
                    const wallOffset = Math.sin(this.wallCrawlTime) * 0.1;
                    this.mesh.position.y = 0.5 + wallOffset;
                    
                    // Rotate to face along wall
                    const wallTangent = new THREE.Vector3().crossVectors(this.wallNormal, new THREE.Vector3(0, 1, 0));
                    moveDirection.projectOnPlane(this.wallNormal);
                }

                // Movement and collision
                if (moveDirection.lengthSq() > 0) {
                    const currentPos = this.mesh.position.clone();
                    const moveAttempt = moveDirection.clone().multiplyScalar(speed);
                    
                    // Try X movement
                    const newPosX = currentPos.clone();
                    newPosX.x += moveAttempt.x;
                    if (!this.game.checkCollision(newPosX, true)) {
                        this.mesh.position.x = newPosX.x;
                    }
                    
                    // Try Z movement
                    const newPosZ = currentPos.clone();
                    newPosZ.z += moveAttempt.z;
                    if (!this.game.checkCollision(newPosZ, true)) {
                        this.mesh.position.z = newPosZ.z;
                    }
                }
                
                // Update orientation
                if (moveDirection.lengthSq() > 0) {
                    const facePos = this.mesh.position.clone().add(moveDirection);
                    this.mesh.lookAt(facePos);
                }
                
                // Handle jumping physics
                if (this.isJumping) {
                    this.jumpVelocity -= 0.015; // Gravity
                    this.mesh.position.y += this.jumpVelocity;
                    
                    // Check for landing
                    if (this.mesh.position.y <= this.baseHeight) {
                        this.mesh.position.y = this.baseHeight;
                        this.isJumping = false;
                        this.isAttacking = false;
                        this.jumpVelocity = 0;
                        this.attackJumpTarget = null;
                    }
                }
                
                // Animate legs
                this.animationTime += this.animationSpeed * 2;
                const walkCycle = Math.sin(this.animationTime);
                const legPhases = [0, Math.PI, Math.PI/2, Math.PI*1.5, 0, Math.PI, Math.PI/2, Math.PI*1.5];
                
                this.parts.legs.forEach((leg, index) => {
                    const phase = legPhases[index];
                    const lift = Math.sin(this.animationTime + phase) * 0.1;
                    leg.position.y = this.parts.originalPositions.legs[index].position.y + lift;
                    
                    leg.rotation.z = this.parts.originalPositions.legs[index].rotation.z + 
                                   (Math.sin(this.animationTime + phase) * 0.2);
                });
            }

            startAttackJump(targetPos) {
                if (!this.isJumping && !this.isAttacking) {
                    this.isJumping = true;
                    this.isAttacking = true;
                    this.jumpVelocity = this.jumpSpeed * 1.5;
                    this.lastJumpTime = Date.now();
                    this.attackJumpTarget = targetPos;
                    
                    // Play jump sound
                    this.game.playSound(200, 0.1, 'sine', 0.2);
                }
            }

            checkHit(projectilePosition) {
                // Get relative position from monster to projectile
                const relativePos = new THREE.Vector3().subVectors(projectilePosition, this.mesh.position);
                
                // Transform relative position to account for monster's rotation
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(-this.mesh.rotation.y);
                relativePos.applyMatrix4(rotationMatrix);

                // Define hit regions with their bounds and damage multipliers
                const hitRegions = {
                    body: {
                        bounds: {
                            x: [-0.5, 0.5],
                            y: [-0.5, 0.5],
                            z: [-0.5, 0.5]
                        },
                        multiplier: 1.0  // Critical hits due to small size
                    },
                };

                // Check each hit region
                for (const [region, data] of Object.entries(hitRegions)) {
                    if (this.isPointInBounds(relativePos, data.bounds)) {
                        return {
                            hit: true,
                            region: region,
                            multiplier: data.multiplier
                        };
                    }
                }

                return { hit: false };
            }

            isPointInBounds(point, bounds) {
                return point.x >= bounds.x[0] && point.x <= bounds.x[1] &&
                       point.y >= bounds.y[0] && point.y <= bounds.y[1] &&
                       point.z >= bounds.z[0] && point.z <= bounds.z[1];
            }
        }

        class GiantMonster extends Monster {
            constructor(game) {
                super(game);
                this.baseHeight = 0;
                this.health = 200;  // High HP
                this.speed = game.config.monsterSpeed * 0.6; // 40% slower than normal
                this.damage = game.config.monsterDamage * 2.5; // 2.5x normal damage
                this.detectionRadius = 20;
                this.attackRange = 3.0; // Melee range with club
                this.attackCooldown = 2000; // Slow attacks
                this.chaseStartTime = 0;
                this.hasClub = true;
                this.clubThrowSpeed = 0.4;
                this.clubThrowDamage = this.damage * 0.8;
                this.clubReturnDistance = 1.0;
                this.createMesh();
                this.findValidPosition();

                // Initialize arm positions
                if (this.parts && this.parts.rightArm && this.parts.leftArm) {
                    // Set initial arm rotations
                    this.parts.rightArm.rotation.set(0, 0, Math.PI / 3);
                    this.parts.leftArm.rotation.set(0, 0, -Math.PI / 9);
                }
            }

            createMesh() {
                const giantGroup = new THREE.Group();
                
                // Create fat torso using multiple merged geometries
                const torsoGroup = new THREE.Group();
                
                // Main belly (larger sphere for fat appearance)
                const bellyGeometry = new THREE.SphereGeometry(1.0, 16, 16);
                const torsoMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x666666,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const belly = new THREE.Mesh(bellyGeometry, torsoMaterial);
                belly.position.y = 1.8;
                belly.scale.set(1.2, 1.0, 0.8);
                
                // Upper torso (slightly smaller)
                const upperTorsoGeometry = new THREE.SphereGeometry(0.8, 16, 16);
                const upperTorso = new THREE.Mesh(upperTorsoGeometry, torsoMaterial);
                upperTorso.position.y = 2.6;
                upperTorso.scale.set(1.0, 0.8, 0.7);
                
                torsoGroup.add(belly);
                torsoGroup.add(upperTorso);
                
                // Create thick legs using merged geometries
                const legGroup = new THREE.Group();
                
                // Function to create a thick leg
                const createThickLeg = (isLeft) => {
                    const legGroup = new THREE.Group();
                    
                    // Upper thigh (fat part)
                    const thighGeometry = new THREE.SphereGeometry(0.4, 12, 12);
                    const thigh = new THREE.Mesh(thighGeometry, torsoMaterial);
                    thigh.scale.set(1, 1.2, 1);
                    thigh.position.y = 1.4;
                    
                    // Calf (slightly thinner)
                    const calfGeometry = new THREE.SphereGeometry(0.3, 12, 12);
                    const calf = new THREE.Mesh(calfGeometry, torsoMaterial);
                    calf.scale.set(1, 1.5, 1);
                    calf.position.y = 0.7;
                    
                    // Foot
                    const footGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.6);
                    const foot = new THREE.Mesh(footGeometry, torsoMaterial);
                    foot.position.y = 0.1;
                    foot.position.z = 0.1;
                    
                    legGroup.add(thigh);
                    legGroup.add(calf);
                    legGroup.add(foot);
                    
                    // Position the leg
                    legGroup.position.x = isLeft ? -0.4 : 0.4;
                    return legGroup;
                };
                
                const leftLeg = createThickLeg(true);
                const rightLeg = createThickLeg(false);
                
                legGroup.add(leftLeg);
                legGroup.add(rightLeg);
                
                // Create two heads with detailed faces
                const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x777777,
                    roughness: 0.7,
                    metalness: 0.3
                });
                
                const leftHead = new THREE.Mesh(headGeometry, headMaterial);
                leftHead.position.set(-0.4, 3.3, 0);
                const rightHead = new THREE.Mesh(headGeometry, headMaterial);
                rightHead.position.set(0.4, 3.3, 0);
                
                // Create eyeballs and pupils for each head
                const createEye = () => {
                    const eyeGroup = new THREE.Group();
                    
                    // White eyeball
                    const eyeballGeometry = new THREE.SphereGeometry(0.15, 12, 12);
                    const eyeballMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        roughness: 0.2,
                        metalness: 0.1
                    });
                    const eyeball = new THREE.Mesh(eyeballGeometry, eyeballMaterial);
                    
                    // Black pupil
                    const pupilGeometry = new THREE.SphereGeometry(0.07, 8, 8);
                    const pupilMaterial = new THREE.MeshStandardMaterial({
                        color: 0x000000,
                        roughness: 0.1,
                        metalness: 0.1
                    });
                    const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                    pupil.position.z = 0.08;
                    
                    eyeGroup.add(eyeball);
                    eyeGroup.add(pupil);
                    
                    // Store references for blinking animation
                    eyeGroup.userData = {
                        eyeball,
                        pupil,
                        originalScale: eyeball.scale.clone(),
                        blinkTime: Math.random() * 1000,
                        nextBlinkTime: Date.now() + Math.random() * 5000
                    };
                    
                    return eyeGroup;
                };
                
                const leftEye = createEye();
                leftEye.position.set(0, 0, 0.3);
                const rightEye = createEye();
                rightEye.position.set(0, 0, 0.3);
                
                // Create mouths with sharp teeth
                const createMouth = () => {
                    const mouthGroup = new THREE.Group();
                    
                    // Create jaw
                    const jawGeometry = new THREE.BoxGeometry(0.3, 0.15, 0.2);
                    const jawMaterial = new THREE.MeshStandardMaterial({
                        color: 0x550000,
                        roughness: 0.8,
                        metalness: 0.2
                    });
                    const jaw = new THREE.Mesh(jawGeometry, jawMaterial);
                    jaw.position.z = 0.3;
                    jaw.position.y = -0.2;
                    
                    // Create teeth
                    const teethGroup = new THREE.Group();
                    const teethMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffcc,
                        roughness: 0.3,
                        metalness: 0.4
                    });
                    
                    // Create multiple sharp teeth
                    for (let i = 0; i < 6; i++) {
                        const toothGeometry = new THREE.ConeGeometry(0.03, 0.08, 4);
                        const tooth = new THREE.Mesh(toothGeometry, teethMaterial);
                        tooth.position.x = (i - 2.5) * 0.05;
                        tooth.position.y = -0.15;
                        tooth.position.z = 0.35;
                        tooth.rotation.x = -Math.PI / 6;
                        teethGroup.add(tooth);
                        
                        // Add bottom teeth
                        const bottomTooth = new THREE.Mesh(toothGeometry, teethMaterial);
                        bottomTooth.position.x = (i - 2.5) * 0.05;
                        bottomTooth.position.y = -0.25;
                        bottomTooth.position.z = 0.35;
                        bottomTooth.rotation.x = Math.PI / 6;
                        teethGroup.add(bottomTooth);
                    }
                    
                    mouthGroup.add(jaw);
                    mouthGroup.add(teethGroup);
                    return mouthGroup;
                };
                
                const leftMouth = createMouth();
                const rightMouth = createMouth();
                
                leftHead.add(leftEye);
                leftHead.add(leftMouth);
                rightHead.add(rightEye);
                rightHead.add(rightMouth);
                
                // Create thick arms
                const createArm = (isLeft) => {
                    const armGroup = new THREE.Group();
                    
                    // Upper arm (thick)
                    const upperArmGeometry = new THREE.SphereGeometry(0.25, 12, 12);
                    const upperArm = new THREE.Mesh(upperArmGeometry, torsoMaterial);
                    upperArm.scale.set(1, 1.8, 1);
                    upperArm.position.y = -0.4;
                    
                    // Forearm (slightly thinner)
                    const forearmGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                    const forearm = new THREE.Mesh(forearmGeometry, torsoMaterial);
                    forearm.scale.set(1, 1.5, 1);
                    forearm.position.y = -1.0;
                    
                    armGroup.add(upperArm);
                    armGroup.add(forearm);
                    
                    // Position the arm
                    armGroup.position.set(isLeft ? -0.7 : 0.7, 2.8, 0);
                    return armGroup;
                };
                
                const leftArm = createArm(true);
                const rightArm = createArm(false);
                
                // Create club with pivot point at handle end
                const clubGroup = new THREE.Group();
                
                const clubHandleGeometry = new THREE.CylinderGeometry(0.1, 0.08, 1.5, 8);
                const clubHeadGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const clubMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    roughness: 0.8,
                    metalness: 0.2
                });
                
                const clubHandle = new THREE.Mesh(clubHandleGeometry, clubMaterial);
                clubHandle.position.y = 0.75; // Move handle up so pivot is at bottom
                
                const clubHead = new THREE.Mesh(clubHeadGeometry, clubMaterial);
                clubHead.position.y = 1.5; // Position relative to handle
                clubHead.scale.set(1.2, 1, 1.2);
                
                clubGroup.add(clubHandle);
                clubGroup.add(clubHead);
                
                // Position club at right hand
                clubGroup.position.set(1.5, 2.5, 0);
                clubGroup.rotation.z = -Math.PI / 6;
                
                // Store club reference
                this.club = clubGroup;
                
                // Add all parts to the giant mesh
                giantGroup.add(torsoGroup);
                giantGroup.add(legGroup);
                giantGroup.add(leftHead);
                giantGroup.add(rightHead);
                giantGroup.add(leftArm);
                giantGroup.add(rightArm);
                giantGroup.add(clubGroup);
                
                this.mesh = giantGroup;
                
                // Store references for animation
                this.parts = {
                    torso: torsoGroup,
                    leftHead,
                    rightHead,
                    leftArm,
                    rightArm,
                    leftLeg,
                    rightLeg,
                    club: clubGroup,
                    leftEye,
                    rightEye,
                    originalPositions: {
                        leftHead: leftHead.position.clone(),
                        rightHead: rightHead.position.clone(),
                        leftArm: leftArm.position.clone(),
                        rightArm: rightArm.position.clone(),
                        leftLeg: leftLeg.position.clone(),
                        rightLeg: rightLeg.position.clone(),
                        club: clubGroup.position.clone()
                    }
                };

                // After creating arms, set their initial positions and rotations
                if (leftArm && rightArm) {
                    leftArm.rotation.set(0, 0, -Math.PI / 9);  // Slight outward angle
                    rightArm.rotation.set(0, 0, Math.PI / 3);  // Club holding position
                }
            }

            update() {
                // Force ground level
                this.mesh.position.y = this.baseHeight;

                // Direction to player
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, this.mesh.position)
                    .normalize();
                directionToPlayer.y = 0;

                const distanceToPlayer = this.mesh.position.distanceTo(this.game.camera.position);
                const isChasing = distanceToPlayer <= this.detectionRadius;
                this.state = isChasing ? "chasing" : "patrolling";
                
                let speed = this.speed;
                let moveDirection = new THREE.Vector3();
                
                // If we don't have the club, move towards it
                if (!this.hasClub && this.thrownClub) {
                    const dirToClub = new THREE.Vector3()
                        .subVectors(this.thrownClub.position, this.mesh.position);
                    dirToClub.y = 0;
                    const distanceToClub = dirToClub.length();
                    dirToClub.normalize();
                    
                    if (distanceToClub <= this.clubReturnDistance) {
                        this.retrieveClub();
                    } else {
                        moveDirection.copy(dirToClub);
                        speed *= 1.5;
                        
                        // Only rotate around Y axis to face the club
                        const targetAngle = Math.atan2(dirToClub.x, dirToClub.z);
                        this.mesh.rotation.y = targetAngle;
                    }
                } else if (isChasing) {
                    if (this.chaseStartTime === 0) {
                        this.chaseStartTime = Date.now();
                    }
                    
                    speed *= 1.2;
                    moveDirection.copy(directionToPlayer);
                    
                    // Only rotate around Y axis to face the player
                    const targetAngle = Math.atan2(directionToPlayer.x, directionToPlayer.z);
                    this.mesh.rotation.y = targetAngle;
                    
                    const chaseTime = Date.now() - this.chaseStartTime;
                    const canThrowClub = chaseTime > 7000 && this.hasClub && distanceToPlayer > 10;
                    
                    if (canThrowClub) {
                        const hasLineOfSight = !this.game.checkCollision(
                            new THREE.Vector3(
                                this.mesh.position.x + directionToPlayer.x * distanceToPlayer * 0.5,
                                this.mesh.position.y,
                                this.mesh.position.z + directionToPlayer.z * distanceToPlayer * 0.5
                            ),
                            false,
                            true
                        );
                        
                        if (hasLineOfSight) {
                            this.throwClub();
                        }
                    }
                    
                    if (distanceToPlayer <= this.attackRange && this.hasClub && !this.game.state.powerups.invincibility.active) {
                        const currentTime = Date.now();
                        if (currentTime - this.lastAttackTime >= this.attackCooldown) {
                            // Apply damage
                            this.game.state.health -= this.damage;
                            this.lastAttackTime = currentTime;
                            
                            // Visual feedback
                            document.body.style.backgroundColor = 'rgba(255,0,0,0.7)';
                            setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                            
                            const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                            if (screenBloodOverlay) {
                                screenBloodOverlay.style.display = 'block';
                                screenBloodOverlay.style.opacity = '0.9';
                                setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                            }
                            
                            // Play heavy hit sound
                            this.game.playSound(80, 0.2, 'square', 0.4);
                            this.game.playSound(40, 0.3, 'sawtooth', 0.3);
                            
                            // Add screen shake
                            this.game.addScreenShake(0.2, 200);
                            
                            this.game.updateHUD();
                            this.game.updateHealthBar();
                            
                            if (this.game.state.health <= 0) {
                                this.game.gameOver();
                            }
                            
                            // Animate club swing and arms together
                            const swingDuration = 200;
                            const startRotation = this.parts.club.rotation.z;
                            const endRotation = startRotation - Math.PI; // Full swing
                            const startTime = Date.now();
                            
                            const animateSwing = () => {
                                const elapsed = Date.now() - startTime;
                                const progress = Math.min(1, elapsed / swingDuration);
                                
                                // Use easing for smoother swing
                                const easeProgress = Math.sin(progress * Math.PI / 2);
                                
                                // Swing club and arms together
                                const currentRotation = startRotation + (endRotation - startRotation) * easeProgress;
                                this.parts.club.rotation.z = currentRotation;
                                this.parts.rightArm.rotation.z = currentRotation * 0.7;
                                this.parts.leftArm.rotation.z = currentRotation * 0.5;
                                
                                if (progress < 1) {
                                    requestAnimationFrame(animateSwing);
                                } else {
                                    // Reset to original position with a smooth return
                                    const returnDuration = 100;
                                    const returnStartTime = Date.now();
                                    
                                    const returnToIdle = () => {
                                        const returnElapsed = Date.now() - returnStartTime;
                                        const returnProgress = Math.min(1, returnElapsed / returnDuration);
                                        
                                        // Use easing for smooth return
                                        const returnEase = 1 - Math.pow(1 - returnProgress, 2);
                                        
                                        // Return to original positions
                                        this.parts.club.rotation.z = endRotation + (startRotation - endRotation) * returnEase;
                                        this.parts.rightArm.rotation.z = Math.PI / 3 * returnEase;
                                        this.parts.leftArm.rotation.z = -Math.PI / 9 * returnEase;
                                        
                                        if (returnProgress < 1) {
                                            requestAnimationFrame(returnToIdle);
                                        }
                                    };
                                    
                                    returnToIdle();
                                }
                            };
                            
                            animateSwing();
                        }
                    }
                } else {
                    this.chaseStartTime = 0;
                    
                    if (!this.patrolDirection || this.patrolTimeRemaining <= 0) {
                        this.patrolDirection = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            0,
                            Math.random() * 2 - 1
                        ).normalize();
                        this.patrolTimeRemaining = 60;
                    }
                    moveDirection.copy(this.patrolDirection);
                    this.patrolTimeRemaining--;
                    
                    // Only rotate around Y axis during patrol
                    if (moveDirection.lengthSq() > 0) {
                        const targetAngle = Math.atan2(moveDirection.x, moveDirection.z);
                        this.mesh.rotation.y = targetAngle;
                    }
                }
                
                // Movement and collision
                if (moveDirection.lengthSq() > 0) {
                    const currentPos = this.mesh.position.clone();
                    const moveAttempt = moveDirection.clone().multiplyScalar(speed);
                    
                    // Try X movement
                    const newPosX = currentPos.clone();
                    newPosX.x += moveAttempt.x;
                    if (!this.game.checkCollision(newPosX, true)) {
                        this.mesh.position.x = newPosX.x;
                    }
                    
                    // Try Z movement
                    const newPosZ = currentPos.clone();
                    newPosZ.z += moveAttempt.z;
                    if (!this.game.checkCollision(newPosZ, true)) {
                        this.mesh.position.z = newPosZ.z;
                    }
                }
                
                // Force upright position
                this.mesh.rotation.x = 0;
                this.mesh.rotation.z = 0;
                this.mesh.position.y = this.baseHeight;
                
                // Animation
                this.animationTime += this.animationSpeed;
                const walkCycle = Math.sin(this.animationTime);
                const swingAmount = isChasing ? 0.2 : 0.15;
                
                // Animate legs and body
                if (moveDirection.lengthSq() > 0) {
                    this.parts.leftLeg.position.z = this.parts.originalPositions.leftLeg.z + walkCycle * swingAmount;
                    this.parts.rightLeg.position.z = this.parts.originalPositions.rightLeg.z - walkCycle * swingAmount;
                    
                    // Animate heads bobbing
                    const headBob = Math.abs(Math.sin(this.animationTime * 2)) * 0.1;
                    this.parts.leftHead.position.y = this.parts.originalPositions.leftHead.y + headBob;
                    this.parts.rightHead.position.y = this.parts.originalPositions.rightHead.y + headBob;
                    
                    // Animate arms and club together during walk
                    if (this.hasClub) {
                        const armSwing = walkCycle * 0.2;
                        this.parts.rightArm.rotation.x = armSwing;
                        this.parts.leftArm.rotation.x = -armSwing;
                        this.parts.club.rotation.x = armSwing;
                    } else {
                        // Both arms swing opposite to legs when not holding club
                        this.parts.rightArm.rotation.x = -walkCycle * 0.4;
                        this.parts.leftArm.rotation.x = walkCycle * 0.4;
                    }
                }
                
                // Update thrown club if it exists
                if (this.thrownClub) {
                    this.updateThrownClub();
                }
            }

            throwClub() {
                if (!this.hasClub) return;
                
                this.hasClub = false;
                this.chaseStartTime = 0; // Reset chase timer
                
                // Create thrown club mesh
                const clubGroup = new THREE.Group();
                
                // Copy club geometry
                this.parts.club.traverse(child => {
                    if (child.isMesh) {
                        const clonedMesh = child.clone();
                        clubGroup.add(clonedMesh);
                    }
                });
                
                // Position at giant's hand
                clubGroup.position.copy(this.mesh.position);
                clubGroup.position.y += 2.5;
                clubGroup.position.x += Math.cos(this.mesh.rotation.y) * 1.5;
                clubGroup.position.z += Math.sin(this.mesh.rotation.y) * 1.5;
                
                // Calculate throw direction
                const throwDirection = new THREE.Vector3()
                    .subVectors(this.game.camera.position, clubGroup.position)
                    .normalize();
                
                // Add club properties
                clubGroup.userData = {
                    velocity: throwDirection.multiplyScalar(this.clubThrowSpeed),
                    rotationSpeed: new THREE.Vector3(
                        Math.random() * 0.2 - 0.1,
                        Math.random() * 0.2 - 0.1,
                        Math.random() * 0.2 - 0.1
                    ),
                    damage: this.clubThrowDamage
                };
                
                this.thrownClub = clubGroup;
                this.game.scene.add(clubGroup);
                
                // Hide held club
                this.parts.club.visible = false;
                
                // Play throw sound
                this.game.playSound(200, 0.1, 'sine', 0.3);
            }

            updateThrownClub() {
                if (!this.thrownClub) return;
                
                // Store previous position for collision check
                const prevPosition = this.thrownClub.position.clone();
                
                // Update position
                this.thrownClub.position.add(this.thrownClub.userData.velocity);
                
                // Add rotation only if the club is moving
                if (this.thrownClub.userData.velocity.lengthSq() > 0.001) {
                    this.thrownClub.rotation.x += this.thrownClub.userData.rotationSpeed.x;
                    this.thrownClub.rotation.y += this.thrownClub.userData.rotationSpeed.y;
                    this.thrownClub.rotation.z += this.thrownClub.userData.rotationSpeed.z;
                }
                
                // Check wall collision
                if (this.game.checkCollision(this.thrownClub.position, false, true)) {
                    this.thrownClub.position.copy(prevPosition);
                    this.thrownClub.userData.velocity.set(0, 0, 0);
                    // Stop rotation when hitting wall
                    this.thrownClub.userData.rotationSpeed.set(0, 0, 0);
                    return;
                }
                
                // Check player collision
                if (!this.game.state.powerups.invincibility.active) {
                    const distanceToPlayer = this.thrownClub.position.distanceTo(this.game.camera.position);
                    if (distanceToPlayer < 1.0) {
                        // Apply damage
                        this.game.state.health -= this.thrownClub.userData.damage;
                        
                        // Visual feedback
                        document.body.style.backgroundColor = 'rgba(255,0,0,0.7)';
                        setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                        
                        const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                        if (screenBloodOverlay) {
                            screenBloodOverlay.style.display = 'block';
                            screenBloodOverlay.style.opacity = '0.9';
                            setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                        }
                        
                        // Play hit sound
                        this.game.playSound(100, 0.1, 'square', 0.3);
                        this.game.playSound(50, 0.3, 'sawtooth', 0.3);
                        
                        // Add screen shake
                        this.game.addScreenShake(0.15, 150);
                        
                        // Update UI
                        this.game.updateHUD();
                        this.game.updateHealthBar();
                        
                        if (this.game.state.health <= 0) {
                            this.game.gameOver();
                        }
                        
                        // Stop club movement
                        this.thrownClub.userData.velocity.set(0, 0, 0);
                    }
                }
            }

            retrieveClub() {
                if (!this.thrownClub) return;
                
                // Store current position and orientation
                const currentPos = this.mesh.position.clone();
                const currentRotY = this.mesh.rotation.y;
                
                // Remove thrown club from scene
                this.game.scene.remove(this.thrownClub);
                this.thrownClub = null;
                
                // Make held club visible and reset its position/rotation
                this.parts.club.visible = true;
                this.parts.club.position.copy(this.parts.originalPositions.club);
                this.parts.club.rotation.set(0, 0, -Math.PI / 6);
                
                // Reset arm positions
                this.parts.rightArm.rotation.set(0, 0, Math.PI / 3);
                this.parts.leftArm.rotation.set(0, 0, -Math.PI / 9);
                
                // Force upright position while maintaining horizontal orientation
                this.mesh.position.copy(currentPos);
                this.mesh.position.y = this.baseHeight;
                this.mesh.rotation.set(0, currentRotY, 0);
                
                // Reset all velocities
                if (this.velocity) {
                    this.velocity.set(0, 0, 0);
                }
                
                this.hasClub = true;
                
                // Play pickup sound
                this.game.playSound(440, 0.1, 'sine', 0.2);
            }

            checkHit(projectilePosition) {
                // Get relative position from monster to projectile
                const relativePos = new THREE.Vector3().subVectors(projectilePosition, this.mesh.position);
                
                // Transform relative position to account for monster's rotation
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(-this.mesh.rotation.y);
                relativePos.applyMatrix4(rotationMatrix);

                // Define hit regions with their bounds and damage multipliers
                const hitRegions = {
                    heads: {
                        bounds: [
                            {  // Left head
                                x: [-0.8, -0.1],
                                y: [3.0, 3.7],
                                z: [-0.4, 0.4]
                            },
                            {  // Right head
                                x: [0.1, 0.8],
                                y: [3.0, 3.7],
                                z: [-0.4, 0.4]
                            }
                        ],
                        multiplier: 1.5  // Headshots do more damage
                    },
                    upperBody: {
                        bounds: {
                            x: [-0.8, 0.8],
                            y: [2.2, 3.0],
                            z: [-0.4, 0.4]
                        },
                        multiplier: 0.8  // Upper body is more resistant
                    },
                    belly: {
                        bounds: {
                            x: [-1.2, 1.2],
                            y: [1.4, 2.2],
                            z: [-0.8, 0.8]
                        },
                        multiplier: 1.0  // Belly is normal damage
                    },
                    arms: {
                        bounds: [
                            {  // Left arm
                                x: [-1.0, -0.4],
                                y: [1.4, 2.8],
                                z: [-0.3, 0.3]
                            },
                            {  // Right arm
                                x: [0.4, 1.0],
                                y: [1.4, 2.8],
                                z: [-0.3, 0.3]
                            }
                        ],
                        multiplier: 1.0  // Normal damage for arms
                    },
                    legs: {
                        bounds: [
                            {  // Left leg
                                x: [-0.6, -0.2],
                                y: [0.1, 1.4],
                                z: [-0.4, 0.4]
                            },
                            {  // Right leg
                                x: [0.2, 0.6],
                                y: [0.1, 1.4],
                                z: [-0.4, 0.4]
                            }
                        ],
                        multiplier: 1.0  // Normal damage for legs
                    },
                    club: {
                        bounds: {
                            x: [0.8, 1.8],
                            y: [1.8, 3.0],
                            z: [-0.3, 0.3]
                        },
                        multiplier: 0  // Club can't be damaged
                    }
                };

                // Check each hit region
                for (const [region, data] of Object.entries(hitRegions)) {
                    if (Array.isArray(data.bounds)) {
                        // For regions with multiple parts (like heads)
                        for (const partBounds of data.bounds) {
                            if (this.isPointInBounds(relativePos, partBounds)) {
                                return {
                                    hit: true,
                                    region: region,
                                    multiplier: data.multiplier
                                };
                            }
                        }
                    } else {
                        // For single regions (like body)
                        if (this.isPointInBounds(relativePos, data.bounds)) {
                            return {
                                hit: true,
                                region: region,
                                multiplier: data.multiplier
                            };
                        }
                    }
                }

                return { hit: false };
            }

            isPointInBounds(point, bounds) {
                return point.x >= bounds.x[0] && point.x <= bounds.x[1] &&
                       point.y >= bounds.y[0] && point.y <= bounds.y[1] &&
                       point.z >= bounds.z[0] && point.z <= bounds.z[1];
            }
        }

        class Game {
            constructor(gameMode = 'normal') {
                this.gameMode = gameMode;
                this.config = {
                    playerSpeed: 0.15,      // Reduced from 0.2
                    playerHeight: 1.7,      // Restored player height
                    playerJumpForce: 0.3,   // Consolidated jump force value
                    gravity: 0.015,         // Consolidated gravity value
                    mouseSensitivity: 0.002,
                    monsterSpeed: 0.05,      // Set very low speed so movement is recognizable
                    monsterDamage: 15,      // Increased from 10 for more danger
                    startingAmmo: 30,
                    mazeSize: 15,          // Initial maze size
                    bulletDamage: 25,
                    shootingCooldown: 250,
                    reloadTime: 2000,
                    enemiesPerLevel: 5,
                    cellSize: 2,
                    // Add level configurations
                    levels: [
                        { mazeSize: 15, enemies: 5 },    // Level 1
                        { mazeSize: 17, enemies: 7 },    // Level 2
                        { mazeSize: 19, enemies: 9 },    // Level 3
                        { mazeSize: 21, enemies: 11 },   // Level 4
                        { mazeSize: 23, enemies: 13 },   // Level 5
                        { mazeSize: 25, enemies: 15 },   // Level 6
                        { mazeSize: 27, enemies: 17 },   // Level 7
                        { mazeSize: 29, enemies: 19 },   // Level 8
                        { mazeSize: 31, enemies: 21 },   // Level 9
                        { mazeSize: 33, enemies: 23 },   // Level 10
                        { mazeSize: 35, enemies: 25 },   // Level 11
                        { mazeSize: 37, enemies: 27 },   // Level 12
                        { mazeSize: 39, enemies: 29 },   // Level 13
                        { mazeSize: 41, enemies: 31 },   // Level 14
                        { mazeSize: 43, enemies: 33 },   // Level 15
                        { mazeSize: 45, enemies: 35 },   // Level 16
                        { mazeSize: 47, enemies: 37 },   // Level 17
                        { mazeSize: 49, enemies: 39 },   // Level 18
                        { mazeSize: 51, enemies: 41 },   // Level 19
                        { mazeSize: 53, enemies: 43 }    // Level 20 (Final Level)
                    ],
                    weapons: {
                        pistol: { 
                            damage: 20, 
                            cooldown: 500, 
                            ammo: 50, 
                            maxAmmo: 100, 
                            speed: 1,
                            recoil: 0.15  // Add recoil values for each weapon
                        },
                        shotgun: { 
                            damage: 15, 
                            cooldown: 2000, 
                            ammo: 20, 
                            maxAmmo: 40, 
                            pellets: 8, 
                            spread: 0.2, 
                            speed: 1,
                            recoil: 0.5  // Stronger recoil for shotgun
                        },
                        machinegun: { 
                            damage: 15, 
                            cooldown: 100, 
                            ammo: 100, 
                            maxAmmo: 200, 
                            speed: 1,
                            recoil: 0.2  // Small but rapid recoil
                        },
                        rocketLauncher: { 
                            damage: 40, 
                            explosionDamage: 80, 
                            explosionRadius: 5, 
                            selfDamage: 20,
                            cooldown: 1000, 
                            ammo: 10, 
                            maxAmmo: 20, 
                            speed: 0.7,
                            recoil: 0.4  // Strong recoil for rocket launcher
                        },
                        railgun: {
                            damage: 100,
                            cooldown: 1500,
                            ammo: 50,
                            maxAmmo: 100,
                            beamColor: 0x00ffff,
                            beamDuration: 500,
                            piercing: true,
                            recoil: 0.9  // Medium recoil for railgun
                        }
                    },
                    powerupSpawnTime: 15000, // 15 seconds between powerup spawns
                    powerupDuration: 15000,   // 15 seconds for temporary powerups
                };

                // Initialize game based on mode
                if (this.gameMode === 'testing') {
                    // Override config for testing mode
                    this.config.mazeSize = 10;
                }

                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
                document.body.appendChild(this.renderer.domElement);

                // Create and add the weapon container to the camera AFTER camera is created
                this.weaponContainer = new THREE.Group();
                this.camera.add(this.weaponContainer);
                this.scene.add(this.camera);

                // Set weapon container and its children to always render last
                this.weaponContainer.renderOrder = 999;
                this.weaponContainer.children.forEach(child => {
                    child.renderOrder = 999;
                });

                this.weaponModels = {};
                this.weaponScene = new THREE.Scene();
                this.weaponCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 2);

                this.state = {
                    health: 100,
                    ammo: this.config.startingAmmo,
                    isGrounded: true,
                    velocity: new THREE.Vector3(0, 0, 0),
                    lastShootTime: 0,
                    isReloading: false,
                    level: 1,
                    isPaused: false,
                    isMouseDown: false,
                    isGameOver: false,
                    currentWeapon: 'pistol',
                    weapons: {
                        pistol: { owned: true, ammo: Infinity },  // Set pistol ammo to Infinity
                        shotgun: { owned: false, ammo: 0 },
                        machinegun: { owned: false, ammo: 0 },
                        rocketLauncher: { owned: false, ammo: 0 },
                        railgun: { owned: false, ammo: 0 }
                    },
                    powerups: {
                        speed: { active: false, endTime: 0 },
                        invincibility: { active: false, endTime: 0 }
                    },
                    lastShotTime: 0,
                    isZoomed: false,
                    normalFOV: 75,
                    zoomFOV: 20,
                    mouseMovement: { x: 0, y: 0 },
                    isRecoiling: false,
                    recoil: {
                        current: 0,
                        recovery: 0.1,  // How fast recoil recovers
                        recoveryDelay: 50,  // Slight delay before recovery starts
                        lastShootTime: 0
                    },
                    weaponBob: {
                        offset: new THREE.Vector3(0, 0, 0),
                        time: 0,
                        intensity: 0.03
                    }
                };

                this.walls = [];

                this.monsters = [];
                this.powerups = [];
                this.projectiles = [];
                this.jumpVelocity = 0;
                this.isJumping = false;
                this.setupScene();
                this.setupLighting();
                this.createLevel();
                this.setupControls();
                this.setupAudio();
                this.setupMinimap();
                this.spawnInitialMonsters();
                this.setupWeapons();
                this.setupPowerupSpawner();
                this.setupMouseControls();
                this.setupWeaponPanel();
                this.animate();
                this.spawnInitialWeapons();
                this.setupSoldierFace();
            }

            setupScene() {
                // Remove these lines since we already created them in constructor
                // this.scene = new THREE.Scene();
                // this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                
                this.renderer.setClearColor(0x000000);
                document.getElementById('game-container').appendChild(this.renderer.domElement);
            }

            setupLighting() {
                // Ambient light for general illumination
                const ambient = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambient);

                // Main directional light (like sun)
                const directional = new THREE.DirectionalLight(0xffffff, 0.8);
                directional.position.set(5, 10, 5);
                this.scene.add(directional);

                // Player point light
                const pointLight = new THREE.PointLight(0xffffff, 0.8, 10);
                this.camera.add(pointLight);
                this.scene.add(this.camera);

                // Disable shadow mapping
                this.renderer.shadowMap.enabled = false;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
            }

            generateMaze() {
                if (this.gameMode === 'testing') {
                    // Create empty map for testing mode
                    const maze = Array(this.config.mazeSize).fill().map(() => Array(this.config.mazeSize).fill(0));
                    
                    // Add border walls only
                    for (let i = 0; i < this.config.mazeSize; i++) {
                        maze[0][i] = 1;
                        maze[this.config.mazeSize-1][i] = 1;
                        maze[i][0] = 1;
                        maze[i][this.config.mazeSize-1] = 1;
                    }
                    return maze;
                } else {
                    const maze = Array(this.config.mazeSize).fill().map(() => Array(this.config.mazeSize).fill(1));
                    
                    function primMaze(maze) {
                        const frontiers = [];
                        const startX = Math.floor(maze.length / 2);
                        const startZ = Math.floor(maze[0].length / 2);
                        
                        maze[startX][startZ] = 0;
                        
                        function addFrontiers(x, z) {
                            const dirs = [[0, 2], [2, 0], [0, -2], [-2, 0]];
                            dirs.forEach(([dx, dz]) => {
                                const nx = x + dx;
                                const nz = z + dz;
                                if (nx >= 0 && nx < maze.length && nz >= 0 && nz < maze[0].length && maze[nx][nz] === 1) {
                                    frontiers.push([nx, nz]);
                                }
                            });
                        }
                        
                        addFrontiers(startX, startZ);
                        
                        while (frontiers.length > 0) {
                            const randIndex = Math.floor(Math.random() * frontiers.length);
                            const [fx, fz] = frontiers[randIndex];
                            frontiers.splice(randIndex, 1);
                            
                            const neighbors = [];
                            const dirs = [[0, 2], [2, 0], [0, -2], [-2, 0]];
                            dirs.forEach(([dx, dz]) => {
                                const nx = fx + dx;
                                const nz = fz + dz;
                                if (nx >= 0 && nx < maze.length && nz >= 0 && nz < maze[0].length && maze[nx][nz] === 0) {
                                    neighbors.push([nx, nz]);
                                }
                            });
                            
                            if (neighbors.length > 0) {
                                const [nx, nz] = neighbors[Math.floor(Math.random() * neighbors.length)];
                                const mx = (fx + nx) / 2;
                                const mz = (fz + nz) / 2;
                                maze[fx][fz] = 0;
                                maze[mx][mz] = 0;
                                addFrontiers(fx, fz);
                            }
                        }
                        
                        // Create more open spaces by randomly removing walls
                        for (let x = 1; x < maze.length - 1; x++) {
                            for (let z = 1; z < maze[0].length - 1; z++) {
                                if (maze[x][z] === 1 && Math.random() < 0.4) { // 40% chance to remove walls
                                    maze[x][z] = 0;
                                }
                            }
                        }
                        
                        // Ensure starting area is clear
                        maze[startX][startZ] = 0;
                        maze[startX+1][startZ] = 0;
                        maze[startX-1][startZ] = 0;
                        maze[startX][startZ+1] = 0;
                        maze[startX][startZ-1] = 0;
                        maze[startX+1][startZ+1] = 0;
                        maze[startX-1][startZ-1] = 0;
                        maze[startX+1][startZ-1] = 0;
                        maze[startX-1][startZ+1] = 0;
                    }
                    
                    primMaze(maze);
                    
                    // Ensure border walls remain
                    for (let i = 0; i < this.config.mazeSize; i++) {
                        maze[0][i] = 1;
                        maze[this.config.mazeSize-1][i] = 1;
                        maze[i][0] = 1;
                        maze[i][this.config.mazeSize-1] = 1;
                    }
                    
                    return maze;
                }
            }

            createLevel() {
                this.maze = this.generateMaze();
                
                // Clear existing level geometry
                this.walls = [];
                this.scene.children = this.scene.children.filter(child => {
                    if (child.userData && child.userData.isWall) {
                        return false;
                    }
                    return true;
                });

                // Load textures
                const textureLoader = new THREE.TextureLoader();
                const loadTexture = (path) => {
                    console.log(`Attempting to load texture: ${path}`);
                    return new Promise((resolve, reject) => {
                        // First try to load as an Image to verify the path
                        const img = new Image();
                        img.onload = () => {
                            console.log(`Image pre-check successful for: ${path}`);
                            // Now load with TextureLoader
                            textureLoader.load(
                                path,
                                (texture) => {
                                    console.log(`Successfully loaded texture: ${path}`);
                                    resolve(texture);
                                },
                                (xhr) => {
                                    console.log(`${path}: ${(xhr.loaded / xhr.total * 100)}% loaded`);
                                },
                                (error) => {
                                    console.error(`Error loading texture ${path}:`, error);
                                    reject(error);
                                }
                            );
                        };
                        img.onerror = (error) => {
                            console.error(`Image pre-check failed for: ${path}`, error);
                            reject(error);
                        };
                        img.src = path;
                    });
                };

                // Create loading promises
                Promise.all([
                    // Floor textures
                    loadTexture('textures/floor/Tiles090_1K-JPG_Color.jpg'),
                    loadTexture('textures/floor/Tiles090_1K-JPG_NormalGL.jpg'),
                    loadTexture('textures/floor/Tiles090_1K-JPG_Roughness.jpg'),
                    loadTexture('textures/floor/Tiles090_1K-JPG_AmbientOcclusion.jpg'),
                    // Wall textures
                    loadTexture('textures/wall/Tiles115_1K-JPG_Color.jpg'),
                    loadTexture('textures/wall/Tiles115_1K-JPG_NormalGL.jpg'),
                    loadTexture('textures/wall/Tiles115_1K-JPG_Roughness.jpg'),
                    loadTexture('textures/wall/Tiles115_1K-JPG_AmbientOcclusion.jpg')
                ]).then(([
                    floorColorMap,
                    floorNormalMap,
                    floorRoughnessMap,
                    floorAOMap,
                    wallColorMap,
                    wallNormalMap,
                    wallRoughnessMap,
                    wallAOMap
                ]) => {
                    // Configure texture settings
                    [floorColorMap, floorNormalMap, floorRoughnessMap, floorAOMap].forEach(texture => {
                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                        texture.repeat.set(this.config.mazeSize/2, this.config.mazeSize/2);
                        texture.encoding = THREE.sRGBEncoding;
                    });
                    
                    [wallColorMap, wallNormalMap, wallRoughnessMap, wallAOMap].forEach(texture => {
                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                        texture.repeat.set(1, 2);
                        texture.encoding = THREE.sRGBEncoding;
                    });

                    // Create floor
                    const floorGeometry = new THREE.PlaneGeometry(
                        this.config.mazeSize * this.config.cellSize, 
                        this.config.mazeSize * this.config.cellSize,
                        1, // Reduced segments
                        1
                    );
                    const floorMaterial = new THREE.MeshStandardMaterial({ 
                        map: floorColorMap,
                        normalMap: floorNormalMap,
                        roughnessMap: floorRoughnessMap,
                        aoMap: floorAOMap,
                        normalScale: new THREE.Vector2(1, 1),
                        roughness: 0.8,
                        metalness: 0.2
                    });
                    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                    floor.rotation.x = -Math.PI / 2;
                    floor.receiveShadow = false;
                    floor.geometry.setAttribute('uv2', floor.geometry.attributes.uv);
                    this.scene.add(floor);

                    // Create wall material
                    const wallGeometry = new THREE.BoxGeometry(
                        this.config.cellSize, 
                        4, 
                        this.config.cellSize,
                        1, // Reduced segments
                        1,
                        1
                    );
                    const wallMaterial = new THREE.MeshStandardMaterial({ 
                        map: wallColorMap,
                        normalMap: wallNormalMap,
                        roughnessMap: wallRoughnessMap,
                        aoMap: wallAOMap,
                        normalScale: new THREE.Vector2(1, 1),
                        roughness: 0.7,
                        metalness: 0.3
                    });
                    wallGeometry.setAttribute('uv2', wallGeometry.attributes.uv);

                    // Create walls
                    for (let x = 0; x < this.config.mazeSize; x++) {
                        for (let z = 0; z < this.config.mazeSize; z++) {
                            if (this.maze[x][z] === 1) {
                                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                                wall.position.set(
                                    (x - this.config.mazeSize/2) * this.config.cellSize,
                                    2,
                                    (z - this.config.mazeSize/2) * this.config.cellSize
                                );
                                wall.castShadow = false;
                                wall.receiveShadow = false;
                                wall.userData.isWall = true;
                                wall.userData.gridX = x;
                                wall.userData.gridZ = z;
                                this.walls.push(wall);
                                this.scene.add(wall);
                            }
                        }
                    }

                    // Create boundary walls
                    const totalSize = this.config.mazeSize * this.config.cellSize;
                    const halfSize = totalSize / 2;
                    
                    // North wall
                    const northWall = new THREE.Mesh(
                        new THREE.BoxGeometry(totalSize + this.config.cellSize, 4, this.config.cellSize, 1, 1, 1),
                        wallMaterial
                    );
                    northWall.position.set(0, 2, -halfSize - this.config.cellSize/2);
                    northWall.userData.isWall = true;
                    northWall.castShadow = false;
                    northWall.receiveShadow = false;
                    this.scene.add(northWall);
                    this.walls.push(northWall);

                    // South wall
                    const southWall = new THREE.Mesh(
                        new THREE.BoxGeometry(totalSize + this.config.cellSize, 4, this.config.cellSize, 1, 1, 1),
                        wallMaterial
                    );
                    southWall.position.set(0, 2, halfSize + this.config.cellSize/2);
                    southWall.userData.isWall = true;
                    southWall.castShadow = false;
                    southWall.receiveShadow = false;
                    this.scene.add(southWall);
                    this.walls.push(southWall);

                    // East wall
                    const eastWall = new THREE.Mesh(
                        new THREE.BoxGeometry(this.config.cellSize, 4, totalSize + this.config.cellSize, 1, 1, 1),
                        wallMaterial
                    );
                    eastWall.position.set(halfSize + this.config.cellSize/2, 2, 0);
                    eastWall.userData.isWall = true;
                    eastWall.castShadow = false;
                    eastWall.receiveShadow = false;
                    this.scene.add(eastWall);
                    this.walls.push(eastWall);

                    // West wall
                    const westWall = new THREE.Mesh(
                        new THREE.BoxGeometry(this.config.cellSize, 4, totalSize + this.config.cellSize, 1, 1, 1),
                        wallMaterial
                    );
                    westWall.position.set(-halfSize - this.config.cellSize/2, 2, 0);
                    westWall.userData.isWall = true;
                    westWall.castShadow = false;
                    westWall.receiveShadow = false;
                    this.scene.add(westWall);
                    this.walls.push(westWall);
                }).catch(error => {
                    console.error('Error loading textures:', error);
                    // Fallback to basic materials if textures fail to load
                    this.createLevelWithBasicMaterials();
                });

                this.findStartPosition();
            }

            // Fallback method for basic materials
            createLevelWithBasicMaterials() {
                console.log('Using fallback basic materials');
                const floorGeometry = new THREE.PlaneGeometry(
                    this.config.mazeSize * this.config.cellSize, 
                    this.config.mazeSize * this.config.cellSize
                );
                const floorMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x808080,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = false;
                this.scene.add(floor);

                const wallGeometry = new THREE.BoxGeometry(
                    this.config.cellSize, 
                    4, 
                    this.config.cellSize
                );
                const wallMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.7,
                    metalness: 0.3
                });

                // Create walls (rest of the code remains the same as original)
                // ... (copy the wall creation code from the original method)
            }

            findStartPosition() {
                const center = Math.floor(this.config.mazeSize / 2);
                const spawnX = (center - this.config.mazeSize/2) * this.config.cellSize;
                const spawnZ = (center - this.config.mazeSize/2) * this.config.cellSize;
                
                this.camera.position.set(spawnX, this.config.playerHeight, spawnZ);
            }

            setupControls() {
                this.keys = {};
                this.rotationX = 0;
                this.rotationY = 0;

                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    
                    if (e.code === 'Space' && !this.isJumping) {
                        this.jumpVelocity = 0.3;
                        this.isJumping = true;
                    }

                    if (e.key === 'Escape') {
                        // Set a flag to indicate manual pause
                        this.state.manuallyPausing = true;
                        this.togglePause();
                        // Clear the flag after a short delay
                        setTimeout(() => {
                            this.state.manuallyPausing = false;
                        }, 100);
                    }

                    if (e.key >= '1' && e.key <= '5') {
                        const weaponIndex = parseInt(e.key) - 1;
                        const weapons = ['pistol', 'shotgun', 'machinegun', 'rocketLauncher', 'railgun'];
                        const selectedWeapon = weapons[weaponIndex];
                        
                        if (this.state.weapons[selectedWeapon] && this.state.weapons[selectedWeapon].owned) {
                            this.state.currentWeapon = selectedWeapon;
                            this.state.lastShotTime = 0;
                            console.log(`Switched to ${selectedWeapon}, ammo: ${this.state.weapons[selectedWeapon].ammo}`);
                            
                            const crosshair = document.getElementById('crosshair');
                            if (crosshair) {
                                crosshair.style.display = 'block';
                            }
                            
                            this.updateHUD();
                            this.updateWeaponPanel();
                        }
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });

                document.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        this.state.isMouseDown = true;
                        this.shoot();
                    }
                });

                document.addEventListener('mouseup', (e) => {
                    if (e.button === 0) {
                        this.state.isMouseDown = false;
                    }
                });

                // Handle pointer lock
                const gameContainer = document.getElementById('game-container');
                gameContainer.addEventListener('click', () => {
                    if (!document.pointerLockElement && !this.state.isPaused) {
                        gameContainer.requestPointerLock().catch(err => {
                            console.warn("Pointer lock request failed:", err);
                        });
                    }
                });

                // Handle pointer lock change
                document.addEventListener('pointerlockchange', () => {
                    const gameContainer = document.getElementById('game-container');
                    if (document.pointerLockElement === gameContainer) {
                        console.log('Pointer lock active');
                    } else {
                        console.log('Pointer lock inactive');
                        // Only auto-pause if we're not already paused and not manually pausing
                        if (!this.state.isPaused && !this.state.manuallyPausing) {
                            this.togglePause();
                        }
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === gameContainer) {
                        // Update rotation values
                        this.rotationY -= e.movementX * 0.002;
                        this.rotationX -= e.movementY * 0.002;
                        
                        // Limit vertical rotation (up/down)
                        this.rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotationX));
                        
                        // Apply rotations separately
                        this.camera.rotation.order = 'YXZ'; // Important! Set rotation order
                        this.camera.rotation.x = this.rotationX;
                        this.camera.rotation.y = this.rotationY;
                        this.camera.rotation.z = 0; // Keep z-rotation at 0
                    }
                });
            }

            setupMouseControls() {
                document.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        this.state.isMouseDown = true;
                        this.shoot();
                    }
                });

                // Add mouseup event listener
                document.addEventListener('mouseup', (e) => {
                    if (e.button === 0) {
                        this.state.isMouseDown = false;
                    }
                });

                document.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
            }

            toggleZoom() {
                this.state.isZoomed = !this.state.isZoomed;
                
                // Handle scope overlay
                let scopeOverlay = document.getElementById('scope-overlay');
                if (this.state.isZoomed) {
                    this.camera.fov = this.state.zoomFOV;
                    
                    // Create scope overlay if it doesn't exist
                    if (!scopeOverlay) {
                        scopeOverlay = document.createElement('div');
                        scopeOverlay.id = 'scope-overlay';
                        scopeOverlay.style.cssText = `
                            position: fixed;
                            top: 0;
                            left: 0;
                            width: 100%;
                            height: 100%;
                            pointer-events: none;
                            z-index: 1000;
                            background: radial-gradient(
                                circle at center,
                                transparent 35%,
                                rgba(0, 0, 0, 0.95) 36%
                            );
                        `;
                        
                        // Add crosshair lines
                        const centerLine = document.createElement('div');
                        centerLine.style.cssText = `
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            width: 2px;
                            height: 40px;
                            background: black;
                        `;
                        
                        const horizontalLine = document.createElement('div');
                        horizontalLine.style.cssText = `
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            width: 40px;
                            height: 2px;
                            background: black;
                        `;
                        
                        scopeOverlay.appendChild(centerLine);
                        scopeOverlay.appendChild(horizontalLine);
                        document.body.appendChild(scopeOverlay);
                    }
                    scopeOverlay.style.display = 'block';
                    
                    // Hide regular crosshair
                    const crosshair = document.getElementById('crosshair');
                    if (crosshair) {
                        crosshair.style.display = 'none';
                    }
                } else {
                    this.camera.fov = this.state.normalFOV;
                    if (scopeOverlay) {
                        scopeOverlay.style.display = 'none';
                    }
                    
                    // Show regular crosshair only if not using railgun
                    const crosshair = document.getElementById('crosshair');
                    if (crosshair) {
                        crosshair.style.display = this.state.currentWeapon !== 'railgun' ? 'block' : 'none';
                    }
                }
                this.camera.updateProjectionMatrix();
            }

            checkCollision(position, isMonster = false, isProjectile = false, customRadius = null) {
                const radius = customRadius ?? (isProjectile ? 0.1 : (isMonster ? 0.2 : 0.3));
                
                // Check collision with each wall
                for (const wall of this.walls) {
                    // Get wall boundaries
                    const wallHalfSize = this.config.cellSize / 2;
                    const wallMinX = wall.position.x - wallHalfSize;
                    const wallMaxX = wall.position.x + wallHalfSize;
                    const wallMinZ = wall.position.z - wallHalfSize;
                    const wallMaxZ = wall.position.z + wallHalfSize;
                    
                    // Find closest point on wall to position
                    const closestX = Math.max(wallMinX, Math.min(position.x, wallMaxX));
                    const closestZ = Math.max(wallMinZ, Math.min(position.z, wallMaxZ));
                    
                    // Calculate distance from closest point
                    const dx = position.x - closestX;
                    const dz = position.z - closestZ;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    // Check if distance is less than collision radius
                if (distance < radius) {
                                return true;
                    }
                }

                // Monster-player collision check
                if (isMonster) {
                    const dx = position.x - this.camera.position.x;
                    const dz = position.z - this.camera.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    if (distance < radius + 0.3) return true;
                } else {
                    // Check monster collisions for player
                    for (const monster of this.monsters) {
                        const dx = position.x - monster.position.x;
                        const dz = position.z - monster.position.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        if (distance < radius + 0.2) return true;
                    }
                }
                
                return false;
            }

            updatePlayer() {
                if (this.state.isPaused) return;

                // Handle jumping
                if (this.isJumping) {
                    this.jumpVelocity -= 0.015;
                    this.camera.position.y += this.jumpVelocity;

                    if (this.camera.position.y <= this.config.playerHeight) {
                        this.camera.position.y = this.config.playerHeight;
                        this.jumpVelocity = 0;
                        this.isJumping = false;
                    }
                }

                const moveSpeed = this.state.powerups.speed.active ? 
                    this.config.playerSpeed * 2 : 
                    this.config.playerSpeed;

                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.camera.quaternion);
                direction.y = 0;
                direction.normalize();

                const right = new THREE.Vector3(1, 0, 0);
                right.applyQuaternion(this.camera.quaternion);
                right.normalize();

                const currentPos = this.camera.position.clone();
                const newPosition = currentPos.clone();
                let moved = false;

                // Calculate movement vector
                const movement = new THREE.Vector3(0, 0, 0);
                if (this.keys.w) movement.add(direction.clone().multiplyScalar(moveSpeed));
                if (this.keys.s) movement.sub(direction.clone().multiplyScalar(moveSpeed));
                if (this.keys.a) movement.sub(right.clone().multiplyScalar(moveSpeed));
                if (this.keys.d) movement.add(right.clone().multiplyScalar(moveSpeed));

                // Try movement along X axis
                if (movement.x !== 0) {
                    newPosition.x = currentPos.x + movement.x;
                    if (!this.checkCollision(newPosition)) {
                        this.camera.position.x = newPosition.x;
                        moved = true;
                    }
                    newPosition.x = currentPos.x; // Reset for Z movement check
                }

                // Try movement along Z axis
                if (movement.z !== 0) {
                    newPosition.z = currentPos.z + movement.z;
                    if (!this.checkCollision(newPosition)) {
                        this.camera.position.z = newPosition.z;
                        moved = true;
                    }
                }

                // If we hit a wall, try sliding along it
                if (!moved && movement.length() > 0) {
                    const slideDirections = [
                        new THREE.Vector3(1, 0, 0),
                        new THREE.Vector3(-1, 0, 0),
                        new THREE.Vector3(0, 0, 1),
                        new THREE.Vector3(0, 0, -1)
                    ];

                    for (const slideDir of slideDirections) {
                        const slidePos = currentPos.clone().add(slideDir.multiplyScalar(moveSpeed));
                        if (!this.checkCollision(slidePos)) {
                            this.camera.position.copy(slidePos);
                            break;
                        }
                    }
                }
            }

            createMonster(type = 'ground') {
                let monster;
                switch(type) {
                    case 'flying':
                        monster = new FlyingMonster(this);
                        break;
                    case 'archer':
                        monster = new ArcherMonster(this);
                        break;
                    case 'spider':
                        monster = new SpiderMonster(this);
                        break;
                    case 'giant':
                        monster = new GiantMonster(this);
                        break;
                    default:
                        monster = new GroundMonster(this);
                        break;
                }
                monster.mesh.userData.instance = monster;
                return monster.mesh;
            }

            updateMonsters() {
                if (this.state.isPaused) return;
                
                if (!this.monsters || this.monsters.length === 0) {
                    console.log('%cNO MONSTERS TO UPDATE!', 'background: red; color: white; font-weight: bold');
                    return;
                }
                
            this.monsters.forEach((monsterMesh, index) => {
                if (!monsterMesh) return;
                
                // Find the monster instance that owns this mesh
                const monster = monsterMesh.userData.instance;
                if (!monster) return;
                
                // Update the monster
                monster.update();
                
                // Monster-monster collision avoidance
                this.monsters.forEach((otherMonsterMesh, otherIndex) => {
                    if (index === otherIndex) return;
                    const distance = monsterMesh.position.distanceTo(otherMonsterMesh.position);
                    if (distance < 0.5) { // 0.5 = 2 * radius
                        const pushDirection = monsterMesh.position.clone()
                            .sub(otherMonsterMesh.position)
                            .normalize()
                            .multiplyScalar(this.config.monsterSpeed * 0.5);
                        const pushTestPos = monsterMesh.position.clone().add(pushDirection);
                        if (!this.checkCollision(new THREE.Vector3(pushTestPos.x, monsterMesh.position.y, monsterMesh.position.z), true)) {
                            monsterMesh.position.x = pushTestPos.x;
                        }
                        if (!this.checkCollision(new THREE.Vector3(monsterMesh.position.x, monsterMesh.position.y, pushTestPos.z), true)) {
                            monsterMesh.position.z = pushTestPos.z;
                        }
                    }
                });
                            });
            }

            shoot() {
                if (this.state.isPaused) return;
                
                const currentTime = Date.now();
                const currentWeapon = this.state.currentWeapon;
                const weaponConfig = this.config.weapons[currentWeapon];
                
                // Check if current weapon is out of ammo (skip check for pistol)
                if (currentWeapon !== 'pistol' && this.state.weapons[currentWeapon].ammo <= 0) {
                    // Find the previous weapon that has ammo
                    const weaponOrder = ['railgun', 'rocketLauncher', 'machinegun', 'shotgun', 'pistol'];
                    const currentIndex = weaponOrder.indexOf(currentWeapon);
                    
                    let newWeapon = null;
                    for (let i = currentIndex + 1; i < weaponOrder.length; i++) {
                        const weapon = weaponOrder[i];
                        if (this.state.weapons[weapon].owned && (weapon === 'pistol' || this.state.weapons[weapon].ammo > 0)) {
                            newWeapon = weapon;
                            break;
                        }
                    }
                    
                    // If we found a weapon with ammo, switch to it
                    if (newWeapon) {
                        this.state.currentWeapon = newWeapon;
                        this.updateWeaponPanel();
                        // Play weapon switch sound
                        this.playSound(440, 0.1, 'sine', 0.2);
                        return;
                    }
                    
                    // If no weapon has ammo, play empty click sound
                    this.playSound(110, 0.1, 'square', 0.05);
                    return;
                }
                
                if (currentTime - this.state.lastShotTime < weaponConfig.cooldown) {
                    return;
                }
                
                // Apply recoil
                this.state.recoil.current += weaponConfig.recoil;
                this.state.recoil.lastShootTime = currentTime;
                
                this.state.lastShotTime = currentTime;
                // Only decrease ammo for non-pistol weapons
                if (currentWeapon !== 'pistol') {
                    this.state.weapons[currentWeapon].ammo--;
                }
                this.updateHUD();
                
                switch (currentWeapon) {
                    case 'railgun':
                        this.fireRailgun();
                        break;
                    case 'shotgun':
                        this.fireShotgun();
                        break;
                    case 'machinegun':
                        this.fireMachinegun();
                        break;
                    case 'rocketLauncher':
                        this.fireRocket();
                        break;
                    default:
                        this.fireBullet(weaponConfig.damage, weaponConfig.speed);
                        break;
                }
            }

            fireBullet(damage, speed, direction = null, spread = 0) {
                if (!direction) {
                    // Get exact direction where camera/crosshair is pointing
                    direction = new THREE.Vector3(0, 0, -1);
                    direction.unproject(this.camera);
                    direction.sub(this.camera.position).normalize();
                }

                // Apply spread if specified
                if (spread > 0) {
                    const randomAngle = Math.random() * Math.PI * 2;
                    const randomSpread = Math.random() * spread;
                    
                    // Create perpendicular vectors to apply spread
                    const up = new THREE.Vector3(0, 1, 0);
                    const right = new THREE.Vector3().crossVectors(direction, up).normalize();
                    const newUp = new THREE.Vector3().crossVectors(right, direction).normalize();
                    
                    // Apply spread in both directions
                    const spreadVector = new THREE.Vector3()
                        .add(right.clone().multiplyScalar(Math.cos(randomAngle) * randomSpread))
                        .add(newUp.clone().multiplyScalar(Math.sin(randomAngle) * randomSpread));
                    
                    direction.add(spreadVector).normalize();
                }
                
                const bulletGroup = new THREE.Group();
                
                // Changed bullet geometry to be oriented along Z-axis
                const bulletPoints = [
                    new THREE.Vector2(0, 0),
                    new THREE.Vector2(0.05, 0),
                    new THREE.Vector2(0.05, 0.3),
                    new THREE.Vector2(0, 0.3)
                ];
                const bulletGeometry = new THREE.LatheGeometry(bulletPoints, 8);
                const bulletMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 1,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                // Rotate bullet to align with direction
                bullet.rotation.x = Math.PI / 2;
                bulletGroup.add(bullet);
            
            // Add a point light to the bullet for better visibility
            const bulletLight = new THREE.PointLight(0xffff00, 1, 3);
            bulletLight.intensity = 0.8;
            bulletGroup.add(bulletLight);
                
                // Update trail to match new bullet orientation
                const trail = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.02, 0.02, 2, 8),
                    new THREE.MeshBasicMaterial({
                        color: 0xffff00,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                trail.position.z = -1; // Position trail behind bullet
                trail.rotation.x = Math.PI / 2;
                bulletGroup.add(trail);
                
            // Position bullet at camera/gun position
                bulletGroup.position.copy(this.camera.position);
            
            // Offset from camera (moved closer to weapon position)
            bulletGroup.position.y -= 0.05; // Lower the spawn point to align with weapon
            

            bulletGroup.position.add(direction.clone().multiplyScalar(-0.5));
                
                // Set bullet orientation to match shooting direction
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction);
                bulletGroup.quaternion.copy(quaternion);
                
            // Store bullet data
                bulletGroup.userData = {
                    velocity: direction.clone().multiplyScalar(speed),
                    distance: 0,
                    maxDistance: 100,
                    damage: damage,
                    type: this.state.currentWeapon,
                    prevPosition: bulletGroup.position.clone()
                };
                
                this.projectiles.push(bulletGroup);
                this.scene.add(bulletGroup);
                
            // Ensure proper rendering order
                bulletGroup.renderOrder = 0;
                bulletGroup.traverse(child => {
                    if (child.isMesh) {
                        child.renderOrder = 0;
                        child.material.depthTest = true;
                        child.material.depthWrite = true;
                    }
                });
            
            // Return the bullet for additional effects
            return bulletGroup;
            }
            fireMachinegun() {
                const weaponConfig = this.config.weapons.machinegun;
                
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                const bulletGroup = new THREE.Group();
                
                // Changed bullet geometry to be oriented along Z-axis
                const bulletGeometry = new THREE.LatheGeometry([
                    new THREE.Vector2(0, 0),
                    new THREE.Vector2(0.03, 0),
                    new THREE.Vector2(0.03, 0.4),
                    new THREE.Vector2(0, 0.4)
                ], 8);
                const bulletMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff4400,
                    emissive: 0xff4400,
                    emissiveIntensity: 1,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                // Rotate bullet to align with direction
                bullet.rotation.x = Math.PI / 2;
                bulletGroup.add(bullet);
                
                // Update trail to match new bullet orientation
                const trail = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.015, 0.015, 2, 8),
                    new THREE.MeshBasicMaterial({
                        color: 0xff4400,
                        transparent: true,
                        opacity: 0.9
                    })
                );
                trail.position.z = -1; // Position trail behind bullet
                trail.rotation.x = Math.PI / 2;
                bulletGroup.add(trail);
                
                bulletGroup.position.copy(this.camera.position);
                // Move spawn point back by 1 unit from camera
                bulletGroup.position.add(direction.clone().multiplyScalar(-1));
                bulletGroup.position.y -= 0.05; // Lower the spawn point slightly
                
                // Set bullet orientation to match shooting direction
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction);
                bulletGroup.quaternion.copy(quaternion);
                
                bulletGroup.userData = {
                    velocity: direction.clone().multiplyScalar(weaponConfig.speed),
                    distance: 0,
                    maxDistance: 100,
                    damage: weaponConfig.damage,
                    type: 'machinegun',
                    prevPosition: bulletGroup.position.clone()
                };
                
                this.projectiles.push(bulletGroup);
                this.scene.add(bulletGroup);
                
                // Rest of the collision check code remains the same
                // ... existing collision check code ...
                
                this.playSound(220, 0.05, 'square', 0.2);
            }
            fireShotgun() {
                const weaponConfig = this.config.weapons.shotgun;
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                const numPellets = weaponConfig.pellets;
                const baseSpeed = 0.4;
                const minConeAngle = Math.PI / 24; // Starting at 7.5 degrees
                const maxConeAngle = Math.PI / 6;  // Expanding to 30 degrees
                
                // Move spawn point slightly forward from camera to prevent wall collision
                const spawnPoint = this.camera.position.clone().add(direction.clone().multiplyScalar(0));
                spawnPoint.y -= 0.2; // Lower to match weapon position
                
                // Check if spawn point is inside a wall
                if (this.checkCollision(spawnPoint)) {
                    console.log("Cannot fire shotgun - too close to wall");
                    return;
                }
                
                // Define the base direction and perpendicular vectors
                const forward = direction.clone().normalize();
                const up = new THREE.Vector3(0, 1, 0);
                const right = new THREE.Vector3().crossVectors(forward, up).normalize();
                const coneUp = new THREE.Vector3().crossVectors(right, forward).normalize();

                // Play shotgun sound
                this.playSound(80, 0.2, 'square', 0.3);
                this.playSound(40, 0.3, 'sawtooth', 0.2);
                
                // Create single muzzle flash for all pellets
                const muzzleFlash = new THREE.PointLight(0xff6600, 3, 5);
                muzzleFlash.position.copy(spawnPoint);
                this.scene.add(muzzleFlash);
                setTimeout(() => this.scene.remove(muzzleFlash), 100);

                // Create and reuse a single geometry and material for all pellets
                const pelletGeometry = new THREE.SphereGeometry(0.05, 4, 4); // Reduced segments
                const pelletMaterial = new THREE.MeshBasicMaterial({ // Changed to BasicMaterial
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.8
                });

                // Distribute pellets in a circular pattern
                for (let i = 0; i < numPellets; i++) {
                    const pellet = new THREE.Mesh(pelletGeometry, pelletMaterial);
                    
                    // Calculate pellet direction
                    let pelletDirection;
                    if (i === 0 && numPellets > 1) {
                        // First pellet goes straight forward
                        pelletDirection = forward.clone();
                    } else {
                        // Distribute remaining pellets in a circular pattern
                        const angleStep = (2 * Math.PI) / (numPellets - 1);
                        const angle = (i - 1) * angleStep;
                        
                        // Initial radius at spawn point (smaller cone)
                        const initialRadius = Math.tan(minConeAngle);
                        
                        // Calculate offset within cone base
                        const offsetX = Math.cos(angle) * initialRadius;
                        const offsetY = Math.sin(angle) * initialRadius;
                        
                        // Combine forward direction with offsets
                        pelletDirection = forward.clone()
                            .add(right.clone().multiplyScalar(offsetX))
                            .add(coneUp.clone().multiplyScalar(offsetY))
                            .normalize();
                    }
                    
                    // Spawn position
                    pellet.position.copy(spawnPoint);
                    
                    // Set up pellet properties with more reliable hit detection
                    pellet.userData = {
                        velocity: pelletDirection.multiplyScalar(baseSpeed),
                        distance: 0,
                        maxDistance: 30,
                        damage: weaponConfig.damage,
                        type: 'shotgun',
                        prevPosition: pellet.position.clone(),
                        initialDirection: pelletDirection.clone(),
                        spawnTime: Date.now(),
                        // Add expansion parameters
                        initialConeAngle: minConeAngle,
                        maxConeAngle: maxConeAngle,
                        expansionRate: 0.1 // Adjust this to control spread speed
                    };
                    
                    this.projectiles.push(pellet);
                    this.scene.add(pellet);
                }

                // Add screen shake for shotgun recoil
                this.addScreenShake(0.15, 150);
                
                // Apply stronger kickback for shotgun
                this.state.recoil.current += this.config.weapons.shotgun.recoil * 1.2;
            }

            fireRocket() {
                const weaponConfig = this.config.weapons.rocketLauncher;
                
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                const rocketGroup = new THREE.Group();
                
                const bodyGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x444444,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                
                const noseGeometry = new THREE.ConeGeometry(0.1, 0.2, 8);
                const noseMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x666666,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const nose = new THREE.Mesh(noseGeometry, noseMaterial);
                nose.position.y = 0.5;
                
                const finGeometry = new THREE.BoxGeometry(0.3, 0.02, 0.15);
                const finMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                
                for (let i = 0; i < 4; i++) {
                    const fin = new THREE.Mesh(finGeometry, finMaterial);
                    fin.position.set(0.15 * Math.cos(i * Math.PI/2), -0.4, 0.15 * Math.sin(i * Math.PI/2));
                    fin.rotation.z = i * Math.PI/2;
                    rocketGroup.add(fin);
                }
                
                rocketGroup.add(body);
                rocketGroup.add(nose);
                
                const engineGlow = new THREE.PointLight(0xff6600, 2, 2);
                engineGlow.position.y = -0.4;
                rocketGroup.add(engineGlow);
                
                // Move spawn point forward by 2 units from camera instead of backward
                rocketGroup.position.copy(this.camera.position);
                rocketGroup.position.add(direction.clone().multiplyScalar(0));
                rocketGroup.position.y -= 0.2; // Lower the spawn point slightly
                
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
                rocketGroup.quaternion.copy(quaternion);
                
                // Add a small delay before the rocket becomes "armed" and can explode
                rocketGroup.userData = {
                    velocity: direction.clone().multiplyScalar(weaponConfig.speed),
                    distance: 0,
                    maxDistance: 50,
                    damage: weaponConfig.damage,
                    type: 'rocketLauncher',
                    isRocket: true,
                    prevPosition: rocketGroup.position.clone()
                };
                
                this.projectiles.push(rocketGroup);
                this.scene.add(rocketGroup);
                
                // In the fireRocket method, add these lines after creating the rocketGroup:
                rocketGroup.renderOrder = 0;
                rocketGroup.traverse(child => {
                    if (child.isMesh) {
                        child.renderOrder = 0;
                        child.material.depthTest = true;
                        child.material.depthWrite = true;
                    }
                });
            }

            createExplosion(position) {
                const weaponConfig = this.config.weapons.rocketLauncher;
                
                // Visual explosion
                const explosionGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const explosionMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.8
                });
                const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                explosion.position.copy(position);
                this.scene.add(explosion);
                
                // Add point light
                const light = new THREE.PointLight(0xff6600, 5, weaponConfig.explosionRadius);
                light.position.copy(position);
                this.scene.add(light);
                
                // Animate expansion and fade out
                let scale = 1;
                const expandInterval = setInterval(() => {
                    scale += 0.5;
                    explosion.scale.set(scale, scale, scale);
                    explosionMaterial.opacity -= 0.1;
                    
                    if (scale >= 5) {
                        clearInterval(expandInterval);
                        this.scene.remove(explosion);
                        this.scene.remove(light);
                    }
                }, 50);
                
                // Damage monsters in radius
                this.monsters.forEach(monster => {
                    const distance = monster.position.distanceTo(position);
                    if (distance < weaponConfig.explosionRadius) {
                        // Calculate damage falloff based on distance
                        const damageFactor = 1 - (distance / weaponConfig.explosionRadius);
                        const damage = Math.floor(weaponConfig.explosionDamage * damageFactor);
                        this.damageMonster(monster, damage);
                    }
                });
                
                // Self damage if player is close
                const distanceToPlayer = this.camera.position.distanceTo(position);
                if (distanceToPlayer < weaponConfig.explosionRadius * 0.7 && !this.state.powerups.invincibility.active) {
                    const damageFactor = 1 - (distanceToPlayer / (weaponConfig.explosionRadius * 0.7));
                    const damage = Math.floor(weaponConfig.selfDamage * damageFactor);
                    this.state.health -= damage;
                    
                    // Visual feedback for self damage
                    document.body.style.backgroundColor = 'rgba(255,0,0,0.3)';
                    setTimeout(() => {
                        document.body.style.backgroundColor = 'transparent';
                    }, 100);
                    
                    // Add these lines to update the health display
                    this.updateHUD();
                    this.updateHealthBar();
                    this.updateSoldierFace();
                    
                    if (this.state.health <= 0) {
                        this.gameOver();
                    }
                }
            }

            damageMonster(monsterMesh, damage, distance) {
                // Get the monster instance
                const monster = monsterMesh.userData.instance;
                if (!monster) return;

                // Apply damage
                const isDead = monster.takeDamage(damage);
                
                // Store original colors if not already stored
                if (!monsterMesh.userData.originalColors) {
                    monsterMesh.userData.originalColors = new Map();
                    monsterMesh.traverse(child => {
                        if (child.isMesh && child.material && child.material.color) {
                            monsterMesh.userData.originalColors.set(child.uuid, {
                                color: child.material.color.clone(),
                                emissiveIntensity: child.material.emissiveIntensity || 0
                            });
                        }
                    });
                }
                
                // Visual feedback - flash red
                monsterMesh.traverse(child => {
                    if (child.isMesh && child.material) {
                        child.material.color.setHex(0xff0000);
                        child.material.emissiveIntensity = 1.0;
                        child.material.needsUpdate = true;
                    }
                });
                
                // Create hit impact effect
                const impactGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const impactMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.8
                });
                const impact = new THREE.Mesh(impactGeometry, impactMaterial);
                
                // Position impact at hit point
                impact.position.copy(monsterMesh.position);
                impact.position.y = monsterMesh instanceof FlyingMonster ? monster.baseHeight : 1.2;
                this.scene.add(impact);
                
                // Create blood particles
                const particleCount = Math.min(10, Math.ceil(damage / 5));
                for (let i = 0; i < particleCount; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05, 4, 4),
                        new THREE.MeshBasicMaterial({
                            color: monster instanceof FlyingMonster ? 0x0000ff : 0x990000,
                            transparent: true,
                            opacity: 0.9
                        })
                    );
                
                    particle.position.copy(impact.position);
                    particle.position.x += (Math.random() - 0.5) * 0.2;
                    particle.position.y += (Math.random() - 0.5) * 0.2;
                    particle.position.z += (Math.random() - 0.5) * 0.2;
                    
                    particle.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.1,
                            Math.random() * 0.1,
                            (Math.random() - 0.5) * 0.1
                        ),
                        life: 20 + Math.random() * 20
                    };
                
                    this.scene.add(particle);
                    if (!this.bloodParticles) this.bloodParticles = [];
                    this.bloodParticles.push(particle);
                }
                
                // Play hit sound effect
                this.playSound(300 + Math.random() * 100, 0.1, 'sawtooth', 0.2);
                
                // Reset visual effects after short delay
                setTimeout(() => {
                    monsterMesh.traverse(child => {
                        if (child.isMesh && child.material) {
                            const originalData = monsterMesh.userData.originalColors.get(child.uuid);
                            if (originalData) {
                                child.material.color.copy(originalData.color);
                                child.material.emissiveIntensity = originalData.emissiveIntensity;
                                child.material.needsUpdate = true;
                            }
                        }
                    });
                    
                    this.scene.remove(impact);
                }, 150);
                
                // Handle monster death
                if (isDead) {
                    // Store the position and type before removing the monster
                    const deathPosition = monsterMesh.position.clone();
                    let monsterType = 'ground';  // default type
                    
                    // Determine monster type
                    if (monster instanceof FlyingMonster) {
                        monsterType = 'flying';
                    } else if (monster instanceof SpiderMonster) {
                        monsterType = 'spider';
                    } else if (monster instanceof ArcherMonster) {
                        monsterType = 'ground';  // Archer uses ground death effect
                    }
                    
                    this.createMonsterDeathEffect(deathPosition, monsterType);
                    this.scene.remove(monsterMesh);
                    const index = this.monsters.indexOf(monsterMesh);
                    if (index > -1) {
                        this.monsters.splice(index, 1);
                        console.log(`${monsterType} monster killed!`);
                    }
                    
                    this.sounds.enemyDeath.play();
                    
                    this.state.enemiesRemaining = this.monsters.length;
                    document.getElementById('enemies').textContent = this.state.enemiesRemaining;
                    
                    if (this.monsters.length === 0 && this.gameMode !== 'testing') {
                        // Only progress to next level in normal mode
                        console.log("Level complete!");
                        this.nextLevel();
                    }
                }
                
                this.updateSoldierFace();
            }

            createMonsterDeathEffect(position, monsterType = 'ground') {
                // Create death blood splatter with type-specific color
                const deathColors = {
                    ground: 0x990000,  // Red blood for ground monsters
                    flying: 0x0000ff,  // Blue for flying monsters
                    spider: 0x00ff00   // Green for spiders
                };

                const deathColor = deathColors[monsterType] || deathColors.ground;
                
                const deathGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                const deathMaterial = new THREE.MeshBasicMaterial({
                    color: deathColor,
                    transparent: true,
                    opacity: 0.9
                });
                const deathEffect = new THREE.Mesh(deathGeometry, deathMaterial);
                deathEffect.position.copy(position);
                deathEffect.position.y += 1.0;
                this.scene.add(deathEffect);
                
                // Define corpse configurations for different monster types
                const monsterConfigs = {
                    ground: {
                        parts: [
                            {
                                name: 'head',
                                geometry: new THREE.BoxGeometry(0.4, 0.4, 0.4),
                                position: new THREE.Vector3(0, 2.1, 0),
                                material: {
                                    color: 0xaa0000,
                                    emissive: 0x330000,
                                    emissiveIntensity: 0.5
                                }
                            },
                            {
                                name: 'torso',
                                geometry: new THREE.BoxGeometry(0.6, 0.8, 0.3),
                                position: new THREE.Vector3(0, 1.5, 0),
                                material: {
                                    color: 0x880000,
                                    emissive: 0x330000,
                                    emissiveIntensity: 0.5
                                }
                            },
                            {
                                name: 'leftArm',
                                geometry: new THREE.BoxGeometry(0.2, 0.6, 0.2),
                                position: new THREE.Vector3(-0.4, 1.5, 0),
                                material: {
                                    color: 0x990000,
                                    emissive: 0x330000,
                                    emissiveIntensity: 0.4
                                }
                            },
                            {
                                name: 'rightArm',
                                geometry: new THREE.BoxGeometry(0.2, 0.6, 0.2),
                                position: new THREE.Vector3(0.4, 1.5, 0),
                                material: {
                                    color: 0x990000,
                                    emissive: 0x330000,
                                    emissiveIntensity: 0.4
                                }
                            },
                            {
                                name: 'leftLeg',
                                geometry: new THREE.BoxGeometry(0.25, 0.7, 0.25),
                                position: new THREE.Vector3(-0.2, 0.85, 0),
                                material: {
                                    color: 0x770000,
                                    emissive: 0x330000,
                                    emissiveIntensity: 0.3
                                }
                            },
                            {
                                name: 'rightLeg',
                                geometry: new THREE.BoxGeometry(0.25, 0.7, 0.25),
                                position: new THREE.Vector3(0.2, 0.85, 0),
                                material: {
                                    color: 0x770000,
                                    emissive: 0x330000,
                                    emissiveIntensity: 0.3
                                }
                            }
                        ],
                        deathSound: { frequency: 80, duration: 0.3, type: 'sawtooth' }
                    },
                    flying: {
                        parts: [
                            {
                                name: 'body',
                                geometry: new THREE.SphereGeometry(0.5, 16, 16),
                                position: new THREE.Vector3(0, 0, 0),
                                material: {
                                    color: 0x000088,
                                    emissive: 0x000033,
                                    emissiveIntensity: 0.5,
                                    metalness: 0.8,
                                    roughness: 0.2
                                }
                            },
                            {
                                name: 'leftWing',
                                geometry: new THREE.BoxGeometry(2, 0.1, 0.8),
                                position: new THREE.Vector3(-0.8, 0, 0),
                                material: {
                                    color: 0x0000aa,
                                    emissive: 0x000066,
                                    emissiveIntensity: 0.3,
                                    transparent: true,
                                    opacity: 0.8
                                }
                            },
                            {
                                name: 'rightWing',
                                geometry: new THREE.BoxGeometry(2, 0.1, 0.8),
                                position: new THREE.Vector3(0.8, 0, 0),
                                material: {
                                    color: 0x0000aa,
                                    emissive: 0x000066,
                                    emissiveIntensity: 0.3,
                                    transparent: true,
                                    opacity: 0.8
                                }
                            }
                        ],
                        deathSound: { frequency: 200, duration: 0.2, type: 'sine' }
                    },
                    spider: {
                        parts: [
                            {
                                name: 'body',
                                geometry: new THREE.SphereGeometry(0.2, 16, 16),
                                position: new THREE.Vector3(0, 0.2, 0),
                                material: {
                                    color: 0x222222,
                                    roughness: 0.7,
                                    metalness: 0.3
                                }
                            }
                        ],
                        deathSound: { frequency: 300, duration: 0.2, type: 'square' },
                        particleCount: 20,
                        particleSize: 0.05,
                        particleColor: 0x00ff00,
                        particleSpeed: 0.08
                    }
                    // Add new monster types here with their corpse configurations
                };
                
                const config = monsterConfigs[monsterType] || monsterConfigs.ground;
                
                // Create and add each body part to the corpse
                const corpse = new THREE.Group();
                config.parts.forEach(part => {
                    const mesh = new THREE.Mesh(
                        part.geometry,
                        new THREE.MeshStandardMaterial(part.material)
                    );
                    mesh.position.copy(part.position);
                    
                    // Apply slight distortion to show damage
                    mesh.rotation.set(
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3
                    );
                    
                    corpse.add(mesh);
                });
                
                // Position the corpse at the monster location
                corpse.position.copy(position);
                
                // Set up death animation data
                corpse.userData = {
                    fallTime: 0,
                    fallSpeed: 0.03,
                    rotationSpeed: 0.05,
                    onGround: false,
                    fadeTime: 100 // Frames before starting to fade
                };
                
                this.scene.add(corpse);
                
                // Add to a list to track for animation
                if (!this.corpses) this.corpses = [];
                this.corpses.push(corpse);
                
                // Create blood/particle effects
                const particleCount = config.particleCount || 15;
                for (let i = 0; i < particleCount; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(config.particleSize || 0.08, 4, 4),
                        new THREE.MeshBasicMaterial({
                            color: config.particleColor || deathColor,
                            transparent: true,
                            opacity: 0.9
                        })
                    );
                    
                    // Position around the monster
                    particle.position.copy(position);
                    particle.position.y += 1.0 + (Math.random() - 0.5) * 0.5;
                    particle.position.x += (Math.random() - 0.5) * 0.5;
                    particle.position.z += (Math.random() - 0.5) * 0.5;
                    
                    // Random velocity - but mostly outward and downward
                    const direction = new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        Math.random() * 0.5,
                        (Math.random() - 0.5) * 2
                    ).normalize();
                    
                    particle.userData = {
                        velocity: direction.multiplyScalar(config.particleSpeed || 0.05),
                        life: 30 + Math.random() * 30
                    };
                    
                    this.scene.add(particle);
                    if (!this.bloodParticles) this.bloodParticles = [];
                    this.bloodParticles.push(particle);
                }
                
                // Play death sound
                const sound = config.deathSound;
                this.playSound(sound.frequency, sound.duration, sound.type, 0.5);
                
                // Animate death effect
                let scale = 1;
                const expandInterval = setInterval(() => {
                    scale += 0.2;
                    deathEffect.scale.set(scale, scale, scale);
                    deathMaterial.opacity -= 0.1;
                    
                    if (scale >= 3) {
                        clearInterval(expandInterval);
                        this.scene.remove(deathEffect);
                    }
                }, 50);
            }

                updateProjectiles() {
                    for (let i = this.projectiles.length - 1; i >= 0; i--) {
                        const projectile = this.projectiles[i];

                        // Store current position before moving
                        projectile.userData.prevPosition.copy(projectile.position);
                        projectile.position.add(projectile.userData.velocity);
                        projectile.userData.distance += projectile.userData.velocity.length();

                        // Check for collisions
                        let collisionOccurred = false;
                        let explosionPosition = null;

                        // Check wall collisions
                        if ((this.checkCollision(projectile.position, false, true) && 
                                projectile.userData.type !== 'railgun') || 
                            (projectile.userData.isRocket && projectile.position.y <= 0.1)) {
                            collisionOccurred = true;
                            explosionPosition = projectile.position.clone();
                        }

                        // Check for player collision if it's a monster projectile
                        if (projectile.userData.isMonsterProjectile && !this.state.powerups.invincibility.active) {
                            // Skip if this projectile has already hit something
                            if (projectile.userData.hasHit) continue;
                            
                            const distanceToPlayer = projectile.position.distanceTo(this.camera.position);
                            if (distanceToPlayer < 0.5) { // Player hit radius
                                // Mark projectile as having hit
                                projectile.userData.hasHit = true;
                                
                                // Apply damage to player
                                this.state.health -= projectile.userData.damage;
                                
                                // Visual feedback
                                document.body.style.backgroundColor = 'rgba(255,0,0,0.7)';
                                setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                                
                                const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                                if (screenBloodOverlay) {
                                    screenBloodOverlay.style.display = 'block';
                                    screenBloodOverlay.style.opacity = '0.9';
                                    setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                                }
                                
                                // Play hit sound
                                this.playSound(100, 0.1, 'square', 0.3);
                                this.playSound(50, 0.3, 'sawtooth', 0.3);
                                
                                // Update UI
                                this.updateHUD();
                                this.updateHealthBar();
                                this.updateSoldierFace();
                                
                                if (this.state.health <= 0) {
                                    this.gameOver();
                                }
                                
                                collisionOccurred = true;
                                continue;
                            }
                        }

                        // Check monster collisions for player projectiles
                        if (!projectile.userData.isMonsterProjectile) {
                            for (const monster of this.monsters) {
                                // Skip if this monster has already been hit by this railgun projectile
                                if (projectile.userData.type === 'railgun' && 
                                    projectile.userData.hitMonsters && 
                                    projectile.userData.hitMonsters.has(monster.uuid)) {
                                    continue;
                                }

                                // Use the monster's checkHit method to determine hit region and damage multiplier
                                const hitResult = monster.userData.instance.checkHit(projectile.position, projectile);
                                
                                if (hitResult.hit) {
                                    console.log(`HIT! Region: ${hitResult.region}, multiplier: ${hitResult.multiplier}`);
                                    
                                    // Calculate damage using the hit region's multiplier
                                    const damage = Math.ceil(projectile.userData.damage * hitResult.multiplier);
                                    
                                    if (projectile.userData.isRocket) {
                                        collisionOccurred = true;
                                        explosionPosition = projectile.position.clone();
                                        break;
                                    } else if (projectile.userData.type === 'railgun') {
                                        // Apply damage to monster
                                        this.damageMonster(monster, damage, 0);
                                        
                                        // Mark this monster as hit by this projectile to prevent multiple hits
                                        if (!projectile.userData.hitMonsters) {
                                            projectile.userData.hitMonsters = new Set();
                                        }
                                        projectile.userData.hitMonsters.add(monster.uuid);
                                        
                                        // Create hit effect for railgun
                                        const hitEffect = new THREE.Mesh(
                                            new THREE.SphereGeometry(0.1, 8, 8),
                                            new THREE.MeshBasicMaterial({
                                                color: 0x00ffff,
                                                transparent: true,
                                                opacity: 0.8
                                            })
                                        );
                                        hitEffect.position.copy(projectile.position);
                                        this.scene.add(hitEffect);
                                        setTimeout(() => this.scene.remove(hitEffect), 100);
                                        
                                        console.log(`Railgun hit monster in ${hitResult.region}, damage: ${damage}`);
                                    } else {
                                        // Apply damage to monster for regular weapons
                                        this.damageMonster(monster, damage, 0);
                                        
                                        // Create hit effect for regular weapons
                                        const hitEffect = new THREE.Mesh(
                                            new THREE.SphereGeometry(0.1, 8, 8),
                                            new THREE.MeshBasicMaterial({
                                                color: 0xff0000,
                                                transparent: true,
                                                opacity: 0.8
                                            })
                                        );
                                        hitEffect.position.copy(projectile.position);
                                        this.scene.add(hitEffect);
                                        setTimeout(() => this.scene.remove(hitEffect), 100);

                                        // Set collision for regular projectiles
                                        collisionOccurred = true;
                                        break;
                                    }
                                }
                            }
                        }

                        // Handle collision aftermath
                        if (collisionOccurred) {
                            if (projectile.userData.isRocket && explosionPosition) {
                                this.createExplosion(explosionPosition);
                            }
                            this.scene.remove(projectile);
                            this.projectiles.splice(i, 1);
                            continue;
                        }

                        // Remove projectiles that exceed max distance
                        if (projectile.userData.distance > projectile.userData.maxDistance) {
                            this.scene.remove(projectile);
                            this.projectiles.splice(i, 1);
                        }
                    }
                }

                spawnInitialMonsters() {
                    console.log('%c=== SPAWNING INITIAL MONSTERS ===', 'background: green; color: white; font-size: 14px; font-weight: bold;');
                    
                    this.monsters.forEach(monster => this.scene.remove(monster));
                    this.monsters = [];

                    if (this.gameMode === 'testing') {
                        // Remove test mode spawns - will be handled by spawn panel
                        console.log(`%cTest mode active - use spawn panel to create monsters`, 'color: lime; font-weight: bold');
                    } else {
                        // Original monster spawning for normal mode
                        if (this.state.level === 1) {
                            // Level 1: 2 of each type
                            for (let i = 0; i < 2; i++) {
                                // Spawn ground monsters
                                console.log(`%cSpawning ground monster ${i+1}/2`, 'color: green; font-weight: bold');
                                const groundMonster = this.createMonster('ground');
                                this.monsters.push(groundMonster);
                                this.scene.add(groundMonster);

                                // Spawn flying monsters
                                console.log(`%cSpawning flying monster ${i+1}/2`, 'color: blue; font-weight: bold');
                                const flyingMonster = this.createMonster('flying');
                                this.monsters.push(flyingMonster);
                                this.scene.add(flyingMonster);

                                // Spawn archer monsters
                                console.log(`%cSpawning archer monster ${i+1}/2`, 'color: orange; font-weight: bold');
                                const archerMonster = this.createMonster('archer');
                                this.monsters.push(archerMonster);
                                this.scene.add(archerMonster);

                                // Spawn spider monsters
                                console.log(`%cSpawning spider monster ${i+1}/2`, 'color: purple; font-weight: bold');
                                const spiderMonster = this.createMonster('spider');
                                this.monsters.push(spiderMonster);
                                this.scene.add(spiderMonster);
                            }
                            
                            console.log(`%cSpawned ${this.monsters.length} monsters (2 ground, 2 flying, 2 archer, 2 spider)`, 'color: lime; font-weight: bold');
                        } else {
                            // Calculate counts based on level for levels > 1
                            const totalCount = 3 + (this.state.level - 1) * 2;
                            const typeCount = Math.floor(totalCount / 4); // Changed from 3 to 4 to include spiders
                            const remainder = totalCount % 4;
                            
                            const counts = {
                                ground: typeCount + (remainder > 0 ? 1 : 0),
                                flying: typeCount + (remainder > 1 ? 1 : 0),
                                archer: typeCount + (remainder > 2 ? 1 : 0),
                                spider: typeCount
                            };

                            // Spawn ground monsters
                            for (let i = 0; i < counts.ground; i++) {
                                console.log(`%cSpawning ground monster ${i+1}/${counts.ground}`, 'color: green; font-weight: bold');
                                const monster = this.createMonster('ground');
                                this.monsters.push(monster);
                                this.scene.add(monster);
                            }

                            // Spawn flying monsters
                            for (let i = 0; i < counts.flying; i++) {
                                console.log(`%cSpawning flying monster ${i+1}/${counts.flying}`, 'color: blue; font-weight: bold');
                                const monster = this.createMonster('flying');
                                this.monsters.push(monster);
                                this.scene.add(monster);
                            }

                            // Spawn archer monsters
                            for (let i = 0; i < counts.archer; i++) {
                                console.log(`%cSpawning archer monster ${i+1}/${counts.archer}`, 'color: orange; font-weight: bold');
                                const monster = this.createMonster('archer');
                                this.monsters.push(monster);
                                this.scene.add(monster);
                            }

                            // Spawn spider monsters
                            for (let i = 0; i < counts.spider; i++) {
                                console.log(`%cSpawning spider monster ${i+1}/${counts.spider}`, 'color: purple; font-weight: bold');
                                const monster = this.createMonster('spider');
                                this.monsters.push(monster);
                                this.scene.add(monster);
                            }
                            
                            console.log(`%cSpawned ${this.monsters.length} monsters (${counts.ground} ground, ${counts.flying} flying, ${counts.archer} archer, ${counts.spider} spider)`, 'color: lime; font-weight: bold');
                        }
                    }

                    this.state.enemiesRemaining = this.monsters.length;
                    document.getElementById('enemies').textContent = this.state.enemiesRemaining;
                }

                animate() {
                    requestAnimationFrame(() => this.animate());
                    
                    if (!this.state.isPaused) {
                        if (this.state.isMouseDown) {
                            this.shoot();
                        }
                        
                        this.updatePlayer();
                        this.updateMonsters();
                        this.updateProjectiles();
                        this.updatePowerups();
                        this.updateMinimap();
                        this.updateWeaponPanel();
                        this.updateWeaponPosition(); // Make sure this is called
                    
                    // Update blood particles
                    if (this.bloodParticles && this.bloodParticles.length > 0) {
                        for (let i = this.bloodParticles.length - 1; i >= 0; i--) {
                            const particle = this.bloodParticles[i];
                            
                            // Apply gravity and update position
                            particle.userData.velocity.y -= 0.005;
                            particle.position.add(particle.userData.velocity);
                            
                            // Check floor collision
                            if (particle.position.y <= 0.05) {
                                particle.position.y = 0.05;
                                particle.userData.velocity.set(0, 0, 0);
                                
                                // Fade out particles on the ground
                                if (particle.material.opacity > 0.05) {
                                    particle.material.opacity -= 0.02;
                                } else {
                                    this.scene.remove(particle);
                                    this.bloodParticles.splice(i, 1);
                                }
                            } else {
                                // Reduce life counter
                                particle.userData.life--;
                                
                                // Fade out particles in air
                                if (particle.userData.life <= 10) {
                                    particle.material.opacity -= 0.1;
                                }
                                
                                // Remove dead particles
                                if (particle.userData.life <= 0) {
                                    this.scene.remove(particle);
                                    this.bloodParticles.splice(i, 1);
                                }
                            }
                        }
                    }
                    
                    // Update monster corpses
                    if (this.corpses && this.corpses.length > 0) {
                        for (let i = this.corpses.length - 1; i >= 0; i--) {
                            const corpse = this.corpses[i];
                            
                            // Increment fall time
                            corpse.userData.fallTime++;
                            
                            if (!corpse.userData.onGround) {
                                // Apply falling rotation (tipping over)
                                corpse.rotation.x += corpse.userData.rotationSpeed;
                                
                                // Apply gravity 
                                const fallDistance = corpse.userData.fallSpeed;
                                corpse.position.y -= fallDistance;
                                
                                // Check if corpse hit the ground
                                if (corpse.position.y <= 0.1 || corpse.rotation.x >= Math.PI/2) {
                                    corpse.position.y = 0.1;
                                    corpse.rotation.x = Math.PI/2; // Flat on ground
                                    corpse.userData.onGround = true;
                                    
                                    // Add small impact blood
                                    for (let j = 0; j < 5; j++) {
                                        const bloodSplat = new THREE.Mesh(
                                            new THREE.CircleGeometry(0.1 + Math.random() * 0.2, 8),
                                            new THREE.MeshBasicMaterial({
                                                color: 0x990000,
                                                transparent: true,
                                                opacity: 0.7,
                                                side: THREE.DoubleSide
                                            })
                                        );
                                        
                                        // Position on ground under corpse
                                        bloodSplat.position.copy(corpse.position);
                                        bloodSplat.position.y = 0.01; // Just above ground
                                        bloodSplat.position.x += (Math.random() - 0.5) * 0.5;
                                        bloodSplat.position.z += (Math.random() - 0.5) * 0.5;
                                        
                                        // Rotate to lie flat on ground
                                        bloodSplat.rotation.x = -Math.PI/2;
                                        
                                        // Add to scene and track
                                        this.scene.add(bloodSplat);
                                        if (!this.bloodSplats) this.bloodSplats = [];
                                        this.bloodSplats.push(bloodSplat);
                                    }
                                }
                            }
                            
                            // Fade out corpse after it's been on the ground for a while
                            if (corpse.userData.onGround && corpse.userData.fallTime > corpse.userData.fadeTime) {
                                let fadingDone = true;
                                
                                // Fade out all child meshes
                                corpse.traverse(child => {
                                    if (child.isMesh && child.material) {
                                        if (child.material.opacity > 0.05) {
                                            child.material.opacity -= 0.01;
                                            child.material.transparent = true;
                                            fadingDone = false;
                                        }
                                    }
                                });
                                
                                // Remove corpse when fully faded
                                if (fadingDone) {
                                    this.scene.remove(corpse);
                                    this.corpses.splice(i, 1);
                                }
                            }
                        }
                    }
                    
                    // Update blood splats on ground
                    if (this.bloodSplats && this.bloodSplats.length > 0) {
                        for (let i = this.bloodSplats.length - 1; i >= 0; i--) {
                            const splat = this.bloodSplats[i];
                            
                            // Very slow fade for blood splats (persist longer)
                            if (splat.material.opacity > 0.02) {
                                splat.material.opacity -= 0.001;
                            } else {
                                this.scene.remove(splat);
                                this.bloodSplats.splice(i, 1);
                            }
                        }
                    }
                    
                    // Update body parts physics
                    if (this.bodyParts && this.bodyParts.length > 0) {
                        for (let i = this.bodyParts.length - 1; i >= 0; i--) {
                            const part = this.bodyParts[i];
                            
                            // Apply gravity and update position
                            part.userData.velocity.y -= 0.01;
                            part.position.add(part.userData.velocity);
                            
                            // Apply rotation
                            if (part.userData.rotationVelocity) {
                                part.rotation.x += part.userData.rotationVelocity.x;
                                part.rotation.y += part.userData.rotationVelocity.y;
                                part.rotation.z += part.userData.rotationVelocity.z;
                            }
                            
                            // Check floor collision
                            if (part.position.y <= 0.1) {
                                part.position.y = 0.1;
                                part.userData.velocity.set(
                                    part.userData.velocity.x * 0.8, // Friction
                                    0,
                                    part.userData.velocity.z * 0.8
                                );
                                
                                // Slow down rotation on ground
                                if (part.userData.rotationVelocity) {
                                    part.userData.rotationVelocity.multiplyScalar(0.95);
                                }
                            }
                            
                            // Reduce life counter
                            part.userData.life--;
                            
                            // Fade out parts
                            if (part.userData.life <= 20) {
                                if (part.material.opacity > 0.05) {
                                    part.material.opacity -= 0.05;
                                } else {
                                    this.scene.remove(part);
                                    this.bodyParts.splice(i, 1);
                                }
                            }
                        }
                    }
                    }
                    
                    this.render();
                }

                setupAudio() {
                    try {
                        // Create local AudioContext-based sounds instead of relying on external URLs
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        
                        // Create simple audio effects using oscillators instead of external files
                        this.sounds = {
                            shoot: {
                                play: () => {
                                    this.playSound(220, 0.1, 'square');
                                }
                            },
                            reload: {
                                play: () => {
                                    this.playSound(110, 0.3, 'sawtooth');
                                }
                            },
                            enemyDeath: {
                                play: () => {
                                    this.playSound(440, 0.2, 'triangle', 0.1);
                                }
                            },
                            playerDeath: {
                                play: () => {
                                    this.playSound(55, 0.5, 'sawtooth', 0.3);
                                }
                            },
                            levelUp: {
                                play: () => {
                                    this.playSound(880, 0.3, 'sine', 0.1);
                                    setTimeout(() => this.playSound(1320, 0.3, 'sine', 0.1), 100);
                                }
                            },
                            emptyGun: {
                                play: () => {
                                    this.playSound(110, 0.1, 'square', 0.05);
                                }
                            },
                            background: {
                                play: () => {
                                    // Do nothing for background music
                                    console.log("Background music would play here");
                                },
                                pause: () => {
                                    // Do nothing for background music
                                },
                                loop: true
                            }
                        };
                        
                        console.log("Audio system initialized successfully");
                    } catch (error) {
                        console.error("Error setting up audio:", error);
                        // Fallback empty sound functions if audio setup fails
                        this.sounds = {
                            shoot: { play: () => {} },
                            reload: { play: () => {} },
                            enemyDeath: { play: () => {} },
                            playerDeath: { play: () => {} },
                            levelUp: { play: () => {} },
                            emptyGun: { play: () => {} },
                            background: { play: () => {}, pause: () => {}, loop: true }
                        };
                    }
                }

                // Helper method to play sounds using Web Audio API
                playSound(frequency, duration, type = 'square', volume = 0.2) {
                    try {
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.type = type;
                        oscillator.frequency.value = frequency;
                        oscillator.connect(gainNode);
                        
                        gainNode.connect(this.audioContext.destination);
                        gainNode.gain.value = volume;
                        
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + duration);
                    } catch (error) {
                        console.error("Error playing sound:", error);
                    }
                }

                createGunModel() {
                    // Empty method - no gun model created
                }

                togglePause() {
                    const wasAlreadyPaused = this.state.isPaused;
                    this.state.isPaused = !this.state.isPaused;
                    
                    // Find and remove ALL pause menu elements
                    const existingMenus = document.querySelectorAll('#pause-menu');
                    existingMenus.forEach(menu => menu.remove());

                    if (this.state.isPaused) {
                        // Create pause menu
                        const pauseMenu = document.createElement('div');
                        pauseMenu.id = 'pause-menu';
                        pauseMenu.style.cssText = `
                            position: fixed;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            background: rgba(0, 0, 0, 0.8);
                            color: white;
                            padding: 20px;
                            border: 2px solid white;
                            text-align: center;
                            font-family: Arial, sans-serif;
                            z-index: 1000;
                        `;

                        pauseMenu.innerHTML = `
                            <h2>GAME PAUSED</h2>
                            <h3>Power-Ups Guide:</h3>
                            <div style="text-align: left; margin: 20px;">
                                <div style="margin: 10px 0;">
                                    <span style="color: white;">⬜</span> Health Pack: +50 HP (Max 100)
                                </div>
                                <div style="margin: 10px 0;">
                                    <span style="color: red;">👟</span> Speed Boost: 2x speed for 15 seconds
                                </div>
                                <div style="margin: 10px 0;">
                                    <span style="color: gold;">🛡️</span> Invincibility: Immune to damage for 15 seconds
                                </div>
                            </div>
                            <div style="margin-top: 20px;">
                                Press ESC to resume
                            </div>
                            <button onclick="window.location.reload();" style="
                            background: #ff0000;
                            color: white;
                            border: none;
                            padding: 10px 20px;
                            margin-top: 15px;
                            cursor: pointer;
                            font-size: 16px;
                            border-radius: 5px;
                        ">Restart Game</button>
                        `;

                        document.body.appendChild(pauseMenu);
                        
                        // Only exit pointer lock if we weren't already paused
                        if (!wasAlreadyPaused) {
                            document.exitPointerLock();
                        }
                    } else {
                        // Only request pointer lock if we were already paused
                        if (wasAlreadyPaused) {
                            const gameContainer = document.getElementById('game-container');
                            gameContainer.requestPointerLock().catch(err => {
                                console.warn("Pointer lock request failed:", err);
                            });
                        }
                    }
                }

                nextLevel() {


                    this.state.level++;
                    
                    // Check if player has completed all levels
                    if (this.state.level > this.config.levels.length) {
                        alert('Congratulations! You\'ve completed all 20 levels and beaten the game!');
                        this.restart();
                        return;
                    }
                    
                    // Get current level configuration
                    const levelConfig = this.config.levels[this.state.level - 1];
                    this.config.mazeSize = levelConfig.mazeSize;
                    
                    // Restore health to full
                    this.state.health = 100;
                    this.updateHealthBar();
                    this.updateSoldierFace();
                    
                    // Play level up sound
                    this.sounds.levelUp.play();
                    
                    // Update HUD
                    document.getElementById('level').textContent = this.state.level;
                    
                    // Clear existing level
                    this.monsters.forEach(monster => this.scene.remove(monster));
                    this.monsters = [];
                    this.powerups.forEach(powerup => this.scene.remove(powerup));
                    this.powerups = [];
                    this.projectiles.forEach(projectile => this.scene.remove(projectile));
                    this.projectiles = [];
                    
                    // Create new level with updated size
                    this.createLevel();
                    
                    // Spawn new monsters based on level configuration
                    for (let i = 0; i < levelConfig.enemies; i++) {
                        const monster = this.createMonster();
                        if (monster) {
                            this.monsters.push(monster);
                            this.scene.add(monster);
                        }
                    }
                    
                    // Update enemy count
                    this.state.enemiesRemaining = this.monsters.length;
                    document.getElementById('enemies').textContent = this.state.enemiesRemaining;
                    
                    // Spawn new weapons for the level
                    this.spawnInitialWeapons();
                    
                    // Add level transition effect
                    document.body.style.backgroundColor = '#fff';
                    setTimeout(() => {
                        document.body.style.backgroundColor = 'black';
                    }, 100);
                    
                    console.log(`Starting Level ${this.state.level} - Map Size: ${this.config.mazeSize}x${this.config.mazeSize}, Enemies: ${levelConfig.enemies}`);
                }

                gameOver() {
                    // In testing mode, don't end the game when health drops to 0
                    if (this.gameMode === 'testing') {
                        console.log('Player would have died, but testing mode is active');
                        return;
                    }
                    
                    this.state.isGameOver = true;
                    this.sounds.playerDeath.play();
                    this.sounds.background.pause();
                    document.exitPointerLock();
                    alert(`Game Over! You reached level ${this.state.level}`);
                    this.restart();
                }

                restart() {
                    this.state = {
                        health: 100,
                        ammo: this.config.startingAmmo,
                        level: 1,
                        isGameOver: false,
                        isReloading: false,
                        isPaused: false,
                        lastShootTime: 0,
                        isMouseDown: false,
                        currentWeapon: 'pistol',
                        weapons: {
                            pistol: { owned: true, ammo: Infinity },
                            shotgun: { owned: false, ammo: 0 },
                            machinegun: { owned: false, ammo: 0 },
                            rocketLauncher: { owned: false, ammo: 0 },
                            railgun: { owned: false, ammo: 0 }
                        },
                        powerups: {
                            speed: { active: false, endTime: 0 },
                            invincibility: { active: false, endTime: 0 }
                        },
                        enemiesRemaining: 0,
                        lastShotTime: 0,
                        isZoomed: false,
                        normalFOV: 75,
                        zoomFOV: 20,
                        mouseMovement: { x: 0, y: 0 },
                        isRecoiling: false,
                        recoil: {
                            current: 0,
                            recovery: 0.1,
                            recoveryDelay: 50,
                            lastShootTime: 0
                        },
                        weaponBob: {
                            offset: new THREE.Vector3(0, 0, 0),
                            time: 0,
                            intensity: 0.03
                        }
                    };

                    // Clear existing monsters
                    this.monsters.forEach(monster => this.scene.remove(monster));
                    this.monsters = [];

                    // Recreate level
                    this.createLevel();
                    this.spawnInitialMonsters();

                    // Reset camera
                    this.camera.rotation.set(0, 0, 0);
                    this.rotationX = 0;
                    this.rotationY = 0;

                    // Update HUD elements
                    const levelElement = document.getElementById('level');
                    if (levelElement) levelElement.textContent = this.state.level;

                    const enemiesElement = document.getElementById('enemies');
                    if (enemiesElement) enemiesElement.textContent = this.monsters.length;

                    // Hide pause menu if it exists
                    const pauseMenu = document.getElementById('pause-menu');
                    if (pauseMenu) pauseMenu.style.display = 'none';

                    // Update weapon panel and soldier face
                    this.updateWeaponPanel();
                    this.updateSoldierFace();
                }

                setupMinimap() {
                    this.minimap = document.getElementById('minimap');
                    this.minimap.width = 200;
                    this.minimap.height = 200;
                    this.minimapCtx = this.minimap.getContext('2d');
                    
                    // Create circular clip path with border
                    this.minimapCtx.save();
                    this.minimapCtx.beginPath();
                    this.minimapCtx.arc(100, 100, 100, 0, Math.PI * 2);
                    this.minimapCtx.clip();
                    
                    // Add gray border around minimap
                    this.minimap.style.border = '3px solid #666';
                    this.minimap.style.borderRadius = '50%';
                }

                updateMinimap() {
                    const ctx = this.minimapCtx;
                    const size = this.minimap.width;
                    const radius = size / 2;

                    // Clear minimap with a black background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, size, size);

                    // Calculate the total world size and scale
                    const worldSize = this.config.mazeSize * this.config.cellSize;
                    const scale = size / worldSize;

                    // Calculate offset to keep player centered
                    const offsetX = radius - (this.camera.position.x * scale);
                    const offsetZ = radius - (this.camera.position.z * scale);

                    // Draw walls
                    ctx.fillStyle = '#666';
                    for (let x = 0; x < this.config.mazeSize; x++) {
                        for (let z = 0; z < this.config.mazeSize; z++) {
                            if (this.maze[x][z] === 1) {
                                const worldX = (x - this.config.mazeSize/2) * this.config.cellSize;
                                const worldZ = (z - this.config.mazeSize/2) * this.config.cellSize;
                                
                                // Convert to minimap coordinates with player-centered offset
                                const minimapX = worldX * scale + offsetX;
                                const minimapZ = worldZ * scale + offsetZ;
                                
                                ctx.fillRect(
                                    minimapX - (this.config.cellSize * scale / 2),
                                    minimapZ - (this.config.cellSize * scale / 2),
                                    this.config.cellSize * scale,
                                    this.config.cellSize * scale
                                );
                            }
                        }
                    }

                    // Draw monsters
                    ctx.fillStyle = '#f00';
                    this.monsters.forEach(monster => {
                        const minimapX = monster.position.x * scale + offsetX;
                        const minimapZ = monster.position.z * scale + offsetZ;
                        
                        ctx.beginPath();
                        ctx.arc(minimapX, minimapZ, 3, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    // Draw powerups
                    ctx.fillStyle = '#ff0';
                    this.powerups.forEach(powerup => {
                        const minimapX = powerup.position.x * scale + offsetX;
                        const minimapZ = powerup.position.z * scale + offsetZ;
                        
                        ctx.beginPath();
                        ctx.arc(minimapX, minimapZ, 3, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    // Draw player in center
                    ctx.fillStyle = '#0f0';
                    ctx.save();
                    ctx.translate(radius, radius);
                    ctx.rotate(-this.camera.rotation.y);
                    
                    // Draw player triangle
                    ctx.beginPath();
                    ctx.moveTo(0, -6);
                    ctx.lineTo(-4, 4);
                    ctx.lineTo(4, 4);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.restore();
                }

                setupWeapons() {
                    // Create weapon models for each type
                    const weaponContainers = {};
                    
                    // 1. Pistol
                    const pistolGroup = new THREE.Group();
                    pistolGroup.name = 'pistol';
                    
                    // Main body of the pistol
                    const pistolBody = new THREE.Mesh(
                        new THREE.BoxGeometry(0.08, 0.15, 0.25),
                        new THREE.MeshStandardMaterial({ color: 0x2b2b2b })
                    );
                    
                    // Grip
                    const pistolGrip = new THREE.Mesh(
                        new THREE.BoxGeometry(0.07, 0.2, 0.08),
                        new THREE.MeshStandardMaterial({ color: 0x1a1a1a })
                    );
                    pistolGrip.position.set(0, -0.15, 0);
                    pistolGrip.rotation.x = Math.PI / 8;
                    
                    // Barrel
                    const pistolBarrel = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.02, 0.02, 0.2, 8),
                        new THREE.MeshStandardMaterial({ color: 0x2b2b2b })
                    );
                    pistolBarrel.rotation.z = Math.PI / 2;
                    pistolBarrel.position.set(0, 0.02, 0.2);
                    
                    pistolGroup.add(pistolBody);
                    pistolGroup.add(pistolGrip);
                    pistolGroup.add(pistolBarrel);
                    
                    const pistolContainer = new THREE.Object3D();
                    pistolContainer.add(pistolGroup);
                    weaponContainers.pistol = pistolContainer;
                    
                    // 2. Shotgun
                    const shotgunGroup = new THREE.Group();
                    shotgunGroup.name = 'shotgun';
                    
                    // Main body
                    const shotgunBody = new THREE.Mesh(
                        new THREE.BoxGeometry(0.1, 0.1, 0.6),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                    );
                    
                    // Pump
                    const shotgunPump = new THREE.Mesh(
                        new THREE.BoxGeometry(0.12, 0.08, 0.2),
                        new THREE.MeshStandardMaterial({ color: 0x000000 })
                    );
                    shotgunPump.position.set(0, 0, 0.2);
                    
                    // Stock
                    const shotgunStock = new THREE.Mesh(
                        new THREE.BoxGeometry(0.08, 0.15, 0.3),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                    );
                    shotgunStock.position.set(0, 0.05, -0.3);
                    
                    // Grip
                    const shotgunGrip = new THREE.Mesh(
                        new THREE.BoxGeometry(0.07, 0.2, 0.08),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                    );
                    shotgunGrip.position.set(0, -0.1, -0.1);
                    shotgunGrip.rotation.x = Math.PI / 4;
                    
                    shotgunGroup.add(shotgunBody);
                    shotgunGroup.add(shotgunPump);
                    shotgunGroup.add(shotgunStock);
                    shotgunGroup.add(shotgunGrip);
                    
                    const shotgunContainer = new THREE.Object3D();
                    shotgunContainer.add(shotgunGroup);
                    weaponContainers.shotgun = shotgunContainer;
                    
                    // 3. Machine Gun
                    const machinegunGroup = new THREE.Group();
                    machinegunGroup.name = 'machinegun';
                    
                    // Main body - made longer and more rectangular
                    const mgBody = new THREE.Mesh(
                        new THREE.BoxGeometry(0.12, 0.15, 0.6),
                        new THREE.MeshStandardMaterial({ color: 0x2f2f2f })
                    );
                    
                    // Add stock
                    const mgStock = new THREE.Mesh(
                        new THREE.BoxGeometry(0.1, 0.2, 0.25),
                        new THREE.MeshStandardMaterial({ color: 0x1a1a1a })
                    );
                    mgStock.position.set(0, 0.05, -0.3);
                    
                    // Barrel - made longer and thicker
                    const mgBarrel = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.04, 0.04, 0.4, 8),
                        new THREE.MeshStandardMaterial({ color: 0x1a1a1a })
                    );
                    mgBarrel.rotation.x = Math.PI / 2;
                    mgBarrel.position.set(0, 0, 0.5);
                    
                    // Add cooling vents
                    const ventGeometry = new THREE.BoxGeometry(0.14, 0.04, 0.3);
                    const ventMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });
                    const vents = new THREE.Mesh(ventGeometry, ventMaterial);
                    vents.position.set(0, 0.08, 0.2);
                    
                    // Handle - adjusted position
                    const mgHandle = new THREE.Mesh(
                        new THREE.BoxGeometry(0.07, 0.2, 0.1),
                        new THREE.MeshStandardMaterial({ color: 0x2a2a2a })
                    );
                    mgHandle.position.set(0, -0.15, -0.1);
                    mgHandle.rotation.x = Math.PI / 6;
                    
                    // Magazine - made larger
                    const mgMag = new THREE.Mesh(
                        new THREE.BoxGeometry(0.08, 0.25, 0.06),
                        new THREE.MeshStandardMaterial({ color: 0x3a3a3a })
                    );
                    mgMag.position.set(0, -0.2, 0.1);
                    
                    machinegunGroup.add(mgBody);
                    machinegunGroup.add(mgStock);
                    machinegunGroup.add(mgBarrel);
                    machinegunGroup.add(vents);
                    machinegunGroup.add(mgHandle);
                    machinegunGroup.add(mgMag);
                    
                    const machinegunContainer = new THREE.Object3D();
                    machinegunContainer.add(machinegunGroup);
                    weaponContainers.machinegun = machinegunContainer;
                    
                    // 4. Rocket Launcher
                    const rocketLauncherGroup = new THREE.Group();
                    rocketLauncherGroup.name = 'rocketLauncher';
                    
                    // Main tube
                    const rlTube = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.08, 0.08, 0.7, 16),
                        new THREE.MeshStandardMaterial({ color: 0x4f4f4f })
                    );
                    rlTube.rotation.z = Math.PI / 2;
                    
                    // Rear sight
                    const rlRear = new THREE.Mesh(
                        new THREE.BoxGeometry(0.12, 0.12, 0.05),
                        new THREE.MeshStandardMaterial({ color: 0x333333 })
                    );
                    rlRear.position.set(0, 0, -0.3);
                    
                    // Handle
                    const rlHandle = new THREE.Mesh(
                        new THREE.BoxGeometry(0.07, 0.2, 0.1),
                        new THREE.MeshStandardMaterial({ color: 0x333333 })
                    );
                    rlHandle.position.set(0, -0.2, -0.1);
                    
                    rocketLauncherGroup.add(rlTube);
                    rocketLauncherGroup.add(rlRear);
                    rocketLauncherGroup.add(rlHandle);
                    
                    const rocketLauncherContainer = new THREE.Object3D();
                    rocketLauncherContainer.add(rocketLauncherGroup);
                    weaponContainers.rocketLauncher = rocketLauncherContainer;
                    
                    // 5. Sniper Rifle
                    const sniperGroup = new THREE.Group();
                    sniperGroup.name = 'sniper';
                    
                    // Main body
                    const sniperBody = new THREE.Mesh(
                        new THREE.BoxGeometry(0.08, 0.1, 0.8),
                        new THREE.MeshStandardMaterial({ color: 0x222222 })
                    );
                    
                    // Scope
                    const sniperScope = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.03, 0.03, 0.2, 8),
                        new THREE.MeshStandardMaterial({ color: 0x000000 })
                    );
                    sniperScope.position.set(0, 0.08, 0.1);
                    
                    // Stock
                    const sniperStock = new THREE.Mesh(
                        new THREE.BoxGeometry(0.07, 0.15, 0.3),
                        new THREE.MeshStandardMaterial({ color: 0x663300 })
                    );
                    sniperStock.position.set(0, 0, -0.4);
                    
                    // Grip
                    const sniperGrip = new THREE.Mesh(
                        new THREE.BoxGeometry(0.06, 0.2, 0.08),
                        new THREE.MeshStandardMaterial({ color: 0x663300 })
                    );
                    sniperGrip.position.set(0, -0.12, -0.1);
                    sniperGrip.rotation.x = Math.PI / 6;
                    
                    sniperGroup.add(sniperBody);
                    sniperGroup.add(sniperScope);
                    sniperGroup.add(sniperStock);
                    sniperGroup.add(sniperGrip);
                    
                    const sniperContainer = new THREE.Object3D();
                    sniperContainer.add(sniperGroup);
                    weaponContainers.sniper = sniperContainer;
                    
                    // 6. Railgun
                    const railgunGroup = new THREE.Group();
                    railgunGroup.name = 'railgun';
                    
                    // Main body - more angular and sci-fi looking
                    const railBody = new THREE.Mesh(
                        new THREE.BoxGeometry(0.08, 0.12, 0.7),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x444444,
                            metalness: 0.9,
                            roughness: 0.2
                        })
                    );
                    
                    // Energy coils (distinctive Quake 2 railgun feature)
                    const coilGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.4, 8);
                    const coilMaterial = new THREE.MeshStandardMaterial({
                        color: 0x00ffff,
                        emissive: 0x00ffff,
                        emissiveIntensity: 0.5
                    });
                    
                    const coil1 = new THREE.Mesh(coilGeometry, coilMaterial);
                    const coil2 = new THREE.Mesh(coilGeometry, coilMaterial);
                    
                    coil1.position.set(0.06, 0, 0.1);
                    coil2.position.set(-0.06, 0, 0.1);
                    
                    // Add pulsing light to coils
                    const coilLight = new THREE.PointLight(0x00ffff, 1, 2);
                    coilLight.position.set(0, 0, 0.1);
                    
                    railgunGroup.add(railBody);
                    railgunGroup.add(coil1);
                    railgunGroup.add(coil2);
                    railgunGroup.add(coilLight);
                    
                    const railgunContainer = new THREE.Object3D();
                    railgunContainer.add(railgunGroup);
                    weaponContainers.railgun = railgunContainer;
                    
                    // Store the models
                    this.weaponModels = weaponContainers;
                }

                setupPowerupSpawner() {
                    setInterval(() => {
                        if (!this.state.isPaused) {
                            this.spawnRandomPowerup();
                        }
                    }, this.config.powerupSpawnTime);
                }

                spawnRandomPowerup() {
                    // Don't spawn random powerups in testing mode
                    if (this.gameMode === 'testing') {
                        return;
                    }

                    const types = [
                        'health', 
                        'speed', 
                        'invincibility', 
                        'shotgun', 
                        'machinegun', 
                        'rocketLauncher', 
                        'railgun'
                    ];
                    
                    const type = types[Math.floor(Math.random() * types.length)];
                    
                    let position;
                    let attempts = 0;
                    do {
                        // FIXED: Adjust spawn position calculation to stay within maze bounds
                        const gridX = Math.floor(Math.random() * (this.config.mazeSize - 2)) + 1;
                        const gridZ = Math.floor(Math.random() * (this.config.mazeSize - 2)) + 1;
                        
                        // Convert to world coordinates
                        position = new THREE.Vector3(
                            (gridX - this.config.mazeSize/2) * this.config.cellSize,
                            0.5,
                            (gridZ - this.config.mazeSize/2) * this.config.cellSize
                        );
                        attempts++;
                    } while (this.checkCollision(position) && attempts < 100);

                    if (attempts < 100) {
                        this.createPowerup(type, position);
                        console.log(`%cNEW ITEM: ${type.toUpperCase()} has appeared at position (${position.x.toFixed(1)}, ${position.y.toFixed(1)}, ${position.z.toFixed(1)})`, 'color: lime; font-weight: bold');
                    }
                }

                createPowerup(type, position) {
                    let powerupMesh;

                    switch(type) {
                        case 'health':
                            // Create white box with red cross
                            const box = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                            const boxMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
                            powerupMesh = new THREE.Mesh(box, boxMaterial);

                            // Add red cross
                            const crossGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.1);
                            const crossMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                            const horizontalCross = new THREE.Mesh(crossGeometry, crossMaterial);
                            const verticalCross = new THREE.Mesh(crossGeometry, crossMaterial);
                            verticalCross.rotation.z = Math.PI / 2;
                            powerupMesh.add(horizontalCross);
                            powerupMesh.add(verticalCross);
                            break;

                        case 'speed':
                            // Create red shoe with wings
                            const shoeGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.6);
                            const shoeMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                            powerupMesh = new THREE.Mesh(shoeGeometry, shoeMaterial);

                            // Add wings
                            const wingGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.2);
                            const wingMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
                            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                            leftWing.position.set(-0.3, 0.1, 0);
                            rightWing.position.set(0.3, 0.1, 0);
                            leftWing.rotation.z = Math.PI / 4;
                            rightWing.rotation.z = -Math.PI / 4;
                            powerupMesh.add(leftWing);
                            powerupMesh.add(rightWing);
                            break;

                        case 'invincibility':
                            // Create golden shield (3D version)
                            powerupMesh = new THREE.Group();
                            
                            // Main shield body - using SphereGeometry for a 3D shield
                            const shieldBody = new THREE.Mesh(
                                new THREE.SphereGeometry(0.3, 16, 16),
                                new THREE.MeshStandardMaterial({ 
                                    color: 0xffd700,
                                    metalness: 0.7,
                                    roughness: 0.3,
                                    transparent: true,
                                    opacity: 0.6
                                })
                            );
                            
                            // Add outer glow effect
                            const outerShield = new THREE.Mesh(
                                new THREE.SphereGeometry(0.35, 16, 16),
                                new THREE.MeshStandardMaterial({ 
                                    color: 0xffd700,
                                    metalness: 0.9,
                                    roughness: 0.1,
                                    transparent: true,
                                    opacity: 0.3
                                })
                            );
                            
                            // Add shield details
                            const ring = new THREE.Mesh(
                                new THREE.TorusGeometry(0.25, 0.03, 16, 32),
                                new THREE.MeshStandardMaterial({ 
                                    color: 0xffff00,
                                    metalness: 0.8,
                                    roughness: 0.2
                                })
                            );
                            
                            // Add point light for glow effect
                            const shieldLight = new THREE.PointLight(0xffd700, 1, 2);
                            
                            powerupMesh.add(shieldBody);
                            powerupMesh.add(outerShield);
                            powerupMesh.add(ring);
                            powerupMesh.add(shieldLight);
                            break;
                            
                        case 'shotgun':
                            // Create shotgun powerup
                            powerupMesh = new THREE.Group();
                            
                            // Main body
                            const shotgunBody = new THREE.Mesh(
                                new THREE.BoxGeometry(0.1, 0.1, 0.4),
                                new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                            );
                            
                            // Pump
                            const shotgunPump = new THREE.Mesh(
                                new THREE.BoxGeometry(0.12, 0.08, 0.15),
                                new THREE.MeshStandardMaterial({ color: 0x000000 })
                            );
                            shotgunPump.position.set(0, 0, 0.15);
                            
                            // Stock
                            const shotgunStock = new THREE.Mesh(
                                new THREE.BoxGeometry(0.08, 0.12, 0.2),
                                new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                            );
                            shotgunStock.position.set(0, 0.02, -0.2);
                            
                            powerupMesh.add(shotgunBody);
                            powerupMesh.add(shotgunPump);
                            powerupMesh.add(shotgunStock);
                            break;
                            
                        case 'machinegun':
                            // Create machinegun powerup
                            powerupMesh = new THREE.Group();
                            
                            // Main body
                            const mgBody = new THREE.Mesh(
                                new THREE.BoxGeometry(0.1, 0.1, 0.4),
                                new THREE.MeshStandardMaterial({ color: 0x2f2f2f })
                            );
                            
                            // Barrel
                            const mgBarrel = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.03, 0.03, 0.2, 8),
                                new THREE.MeshStandardMaterial({ color: 0x1a1a1a })
                            );
                            mgBarrel.rotation.x = Math.PI / 2;
                            mgBarrel.position.set(0, 0, 0.3);
                            
                            // Magazine
                            const mgMag = new THREE.Mesh(
                                new THREE.BoxGeometry(0.08, 0.15, 0.05),
                                new THREE.MeshStandardMaterial({ color: 0x3a3a3a })
                            );
                            mgMag.position.set(0, -0.12, 0.1);
                            
                            powerupMesh.add(mgBody);
                            powerupMesh.add(mgBarrel);
                            powerupMesh.add(mgMag);
                            break;
                            
                        case 'rocketLauncher':
                            // Create rocket launcher powerup
                            powerupMesh = new THREE.Group();
                            
                            // Main tube
                            const rlTube = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.08, 0.08, 0.5, 16),
                                new THREE.MeshStandardMaterial({ color: 0x4f4f4f })
                            );
                            rlTube.rotation.z = Math.PI / 2;
                            
                            // Rear sight
                            const rlRear = new THREE.Mesh(
                                new THREE.BoxGeometry(0.12, 0.12, 0.05),
                                new THREE.MeshStandardMaterial({ color: 0x333333 })
                            );
                            rlRear.position.set(0, 0, -0.25);
                            
                            powerupMesh.add(rlTube);
                            powerupMesh.add(rlRear);
                            break;
                            
                        case 'sniper':
                            // Create sniper rifle powerup
                            powerupMesh = new THREE.Group();
                            
                            // Main body
                            const sniperBody = new THREE.Mesh(
                                new THREE.BoxGeometry(0.06, 0.08, 0.6),
                                new THREE.MeshStandardMaterial({ color: 0x222222 })
                            );
                            
                            // Scope
                            const sniperScope = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.03, 0.03, 0.15, 8),
                                new THREE.MeshStandardMaterial({ color: 0x000000 })
                            );
                            sniperScope.position.set(0, 0.08, 0.1);
                            
                            // Stock
                            const sniperStock = new THREE.Mesh(
                                new THREE.BoxGeometry(0.05, 0.12, 0.2),
                                new THREE.MeshStandardMaterial({ color: 0x663300 })
                            );
                            sniperStock.position.set(0, 0, -0.3);
                            
                            powerupMesh.add(sniperBody);
                            powerupMesh.add(sniperScope);
                            powerupMesh.add(sniperStock);
                            break;
                        case 'railgun': // Changed from sniper
                            powerupMesh = new THREE.Group();
                            
                            // Main body - more angular and sci-fi looking
                            const railBody = new THREE.Mesh(
                                new THREE.BoxGeometry(0.08, 0.12, 0.7),
                                new THREE.MeshStandardMaterial({ 
                                    color: 0x444444,
                                    metalness: 0.9,
                                    roughness: 0.2
                                })
                            );
                            
                            // Energy coils (distinctive Quake 2 railgun feature)
                            const coilGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.4, 8);
                            const coilMaterial = new THREE.MeshStandardMaterial({
                                color: 0x00ffff,
                                emissive: 0x00ffff,
                                emissiveIntensity: 0.5
                            });
                            
                            const coil1 = new THREE.Mesh(coilGeometry, coilMaterial);
                            const coil2 = new THREE.Mesh(coilGeometry, coilMaterial);
                            
                            coil1.position.set(0.06, 0, 0.1);
                            coil2.position.set(-0.06, 0, 0.1);
                            
                            // Add pulsing light to coils
                            const coilLight = new THREE.PointLight(0x00ffff, 1, 2);
                            coilLight.position.set(0, 0, 0.1);
                            
                            powerupMesh.add(railBody);
                            powerupMesh.add(coil1);
                            powerupMesh.add(coil2);
                            powerupMesh.add(coilLight);
                            break;
                    }

                    if (powerupMesh) {
                        // Position the powerup and add floating animation
                        powerupMesh.position.copy(position);
                        powerupMesh.userData = {
                            type: type,
                            rotationSpeed: 0.02,
                            floatSpeed: 0.005,
                            floatHeight: 0.2,
                            baseY: position.y,
                            floatTime: Math.random() * Math.PI * 2 // Random starting phase
                        };
                        
                        // Add glow effect for weapons
                        if (['shotgun', 'machinegun', 'rocketLauncher', 'sniper', 'railgun'].includes(type)) {
                            const pointLight = new THREE.PointLight(0x00ffff, 0.5, 2);
                            pointLight.position.set(0, 0, 0);
                            powerupMesh.add(pointLight);
                        }
                        
                        this.powerups.push(powerupMesh);
                        this.scene.add(powerupMesh);
                    }
                }

                updatePowerups() {
                    const currentTime = Date.now();
                    
                    if (this.state.powerups.speed.active && currentTime > this.state.powerups.speed.endTime) {
                        this.state.powerups.speed.active = false;
                        console.log('%cPOWERUP EXPIRED: Speed boost has worn off', 'color: orange; font-weight: bold');
                        this.updateSoldierFace();
                    }
                    if (this.state.powerups.invincibility.active && currentTime > this.state.powerups.invincibility.endTime) {
                        this.state.powerups.invincibility.active = false;
                        console.log('%cPOWERUP EXPIRED: Invincibility has worn off', 'color: orange; font-weight: bold');
                        this.updateSoldierFace();
                    }

                    this.powerups.forEach(powerup => {
                        // Rotate powerup
                        powerup.rotation.y += powerup.userData.rotationSpeed;
                        
                        // Add floating animation
                        if (powerup.userData.floatSpeed) {
                            powerup.userData.floatTime += powerup.userData.floatSpeed;
                            const floatOffset = Math.sin(powerup.userData.floatTime) * powerup.userData.floatHeight;
                            powerup.position.y = powerup.userData.baseY + floatOffset;
                        }
                    });

                    this.checkPowerupCollisions();
                }

                checkPowerupCollisions() {
                    const playerPosition = this.camera.position.clone();
                    const collectionRadius = 1.5;

                    for (let i = this.powerups.length - 1; i >= 0; i--) {
                        const powerup = this.powerups[i];
                        const distance = playerPosition.distanceTo(powerup.position);
                        
                        if (distance < collectionRadius) {
                            this.collectPowerup(powerup);
                            this.scene.remove(powerup);
                            this.powerups.splice(i, 1);
                        }
                    }
                }

                collectPowerup(powerup) {
                    // Play pickup sound
                    this.sounds.pickup = this.sounds.pickup || { play: () => this.playSound(660, 0.1, 'sine') };
                    this.sounds.pickup.play();
                    
                    const type = powerup.userData.type;
                    console.log(`%cITEM COLLECTED: ${type.toUpperCase()}`, 'color: yellow; font-weight: bold');
                    
                    switch(type) {
                        case 'health':
                            const healthBefore = this.state.health;
                            this.state.health = Math.min(this.state.health + 50, 100);
                            console.log(`Health increased from ${healthBefore} to ${this.state.health}`);
                            break;
                        case 'speed':
                            this.state.powerups.speed.active = true;
                            this.state.powerups.speed.endTime = Date.now() + this.config.powerupDuration;
                            const speedEndTime = new Date(this.state.powerups.speed.endTime);
                            console.log(`Speed boost activated until ${speedEndTime.toLocaleTimeString()}`);
                            break;
                        case 'invincibility':
                            this.state.powerups.invincibility.active = true;
                            this.state.powerups.invincibility.endTime = Date.now() + this.config.powerupDuration;
                            const invincibilityEndTime = new Date(this.state.powerups.invincibility.endTime);
                            console.log(`Invincibility activated until ${invincibilityEndTime.toLocaleTimeString()}`);
                            break;
                        default:
                            // Weapon pickup
                            const weapon = type;
                            if (this.state.weapons[weapon]) {
                                if (this.state.weapons[weapon].owned) {
                                    // Add ammo if already owned
                                    const ammoBefore = this.state.weapons[weapon].ammo;
                                    this.state.weapons[weapon].ammo = Math.min(
                                        this.state.weapons[weapon].ammo + this.config.weapons[weapon].ammo,
                                        this.config.weapons[weapon].maxAmmo
                                    );
                                    console.log(`Added ammo to ${weapon}: ${ammoBefore} → ${this.state.weapons[weapon].ammo}`);
                                } else {
                                    // Get new weapon
                                    this.state.weapons[weapon].owned = true;
                                    this.state.weapons[weapon].ammo = this.config.weapons[weapon].ammo;
                                    this.state.currentWeapon = weapon; // Auto-equip new weapon
                                    
                                    // Ensure crosshair is visible when getting new weapon
                                    const crosshair = document.getElementById('crosshair');
                                    if (crosshair) {
                                        crosshair.style.display = 'block';
                                    }
                                    
                                    console.log(`Acquired new weapon: ${weapon} with ${this.state.weapons[weapon].ammo} ammo`);
                                }
                            }
                    }
                    
                    // Display pickup message
                    this.showPickupMessage(type);
                    
                    this.updateHUD();
                    this.updateWeaponPanel();
                    this.updateSoldierFace();
                }

                // New method to show pickup messages
                showPickupMessage(type) {
                    let message = '';
                    switch(type) {
                        case 'health':
                            message = 'Health Pack +50 HP';
                            break;
                        case 'speed':
                            message = 'Speed Boost Activated!';
                            break;
                        case 'invincibility':
                            message = 'Invincibility Shield Activated!';
                            break;
                        case 'shotgun':
                            message = 'Picked up Shotgun';
                            break;
                        case 'machinegun':
                            message = 'Picked up Machine Gun';
                            break;
                        case 'rocketLauncher':
                            message = 'Picked up Rocket Launcher';
                            break;
                        case 'railgun':
                            message = 'Picked up Railgun';
                            break;
                    }
                    
                    if (message) {
                        // Create or reuse pickup message element
                        let pickupMsg = document.getElementById('pickup-message');
                        if (!pickupMsg) {
                            pickupMsg = document.createElement('div');
                            pickupMsg.id = 'pickup-message';
                            pickupMsg.style.cssText = `
                                position: fixed;
                                top: 50%;
                                left: 50%;
                                transform: translate(-50%, -50%);
                                color: #fff;
                                font-size: 24px;
                                font-weight: bold;
                                text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
                                text-align: center;
                                opacity: 0;
                                transition: opacity 0.3s ease-in-out;
                                pointer-events: none;
                            `;
                            document.body.appendChild(pickupMsg);
                        }
                        
                        // Display message with fade effect
                        pickupMsg.textContent = message;
                        pickupMsg.style.opacity = 1;
                        
                        // Clear any existing timeout
                        if (this.pickupMessageTimeout) {
                            clearTimeout(this.pickupMessageTimeout);
                        }
                        
                        // Set fade out
                        this.pickupMessageTimeout = setTimeout(() => {
                            pickupMsg.style.opacity = 0;
                        }, 1500);
                    }
                }

                // New method to spawn initial weapons in the level
                spawnInitialWeapons() {
                    // Don't spawn initial weapons in testing mode
                    if (this.gameMode === 'testing') {
                        return;
                    }

                    // Original weapon spawning logic for normal mode
                    const weapons = ['shotgun', 'machinegun', 'rocketLauncher', 'railgun'];
                    
                    weapons.forEach(weapon => {
                        let position;
                        let attempts = 0;
                        let minDistanceFromPlayer = 10;
                        
                        do {
                            position = new THREE.Vector3(
                                (Math.random() - 0.5) * this.config.mazeSize * 1.5,
                                0.5,
                                (Math.random() - 0.5) * this.config.mazeSize * 1.5
                            );
                            
                            const distanceFromPlayer = position.distanceTo(this.camera.position);
                            attempts++;
                            
                            if (!this.checkCollision(position) && distanceFromPlayer >= minDistanceFromPlayer) {
                                let tooClose = false;
                                for (const powerup of this.powerups) {
                                    if (position.distanceTo(powerup.position) < 5) {
                                        tooClose = true;
                                        break;
                                    }
                                }
                                
                                if (!tooClose) {
                                    break;
                                }
                            }
                        } while (attempts < 100);
                        
                        if (attempts < 100) {
                            this.createPowerup(weapon, position);
                            console.log(`Spawned initial ${weapon} at position`, position);
                        }
                    });
                }

                updateHUD() {
                    // Remove this line since we removed the health element:
                    // document.getElementById('health').textContent = this.state.health;
                    
                    // Update only the level and enemies count
                    document.getElementById('level').textContent = this.state.level;
                    document.getElementById('enemies').textContent = this.state.enemiesRemaining;
                }

                setupWeaponPanel() {
                    const panel = document.createElement('div');
                    panel.style.cssText = `
                        position: fixed;
                        bottom: 0;
                        left: 0;
                        width: 100%;
                        height: 90px;
                        background: rgba(0, 0, 0, 0.7);
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        padding: 5px;
                    `;

                    const contentContainer = document.createElement('div');
                    contentContainer.style.cssText = `
                        display: flex;
                        align-items: center;
                        gap: 8px;
                    `;

                    // Add soldier face with scaled down dimensions
                    const faceContainer = this.setupSoldierFace();
                    faceContainer.style.cssText = `
                        width: 90px;
                        height: 80px;
                        background-color: rgba(0, 0, 0, 0.5);
                        border: 2px solid #666;
                        border-radius: 8px;
                        padding: 5px;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                    `;

                    // Scale down the face elements
                    const faceDiv = faceContainer.querySelector('#soldier-face');
                    if (faceDiv) {
                        faceDiv.style.width = '70px';
                        faceDiv.style.height = '70px';
                        faceDiv.style.borderRadius = '35px';
                    }

                    // Scale down the eyes
                    const eyes = faceContainer.querySelectorAll('.eye');
                    eyes.forEach(eye => {
                        eye.style.width = '18px';
                        eye.style.height = '12px';
                        eye.style.top = '10px';
                    });
                    const leftEye = faceContainer.querySelector('#left-eye');
                    if (leftEye) leftEye.style.left = '15px';
                    const rightEye = faceContainer.querySelector('#right-eye');
                    if (rightEye) rightEye.style.right = '15px';

                    // Scale down the pupils
                    const pupils = faceContainer.querySelectorAll('.pupil');
                    pupils.forEach(pupil => {
                        pupil.style.width = '7px';
                        pupil.style.height = '7px';
                    });

                    // Scale down the mouth
                    const mouth = faceContainer.querySelector('#mouth');
                    if (mouth) {
                        mouth.style.width = '35px';
                        mouth.style.height = '9px';
                        mouth.style.top = '40px';  // Changed to position from top instead of bottom
                        mouth.style.left = '18px';
                    }

                    // Scale down the health text
                    const healthText = faceContainer.querySelector('#soldier-health-text');
                    if (healthText) {
                        healthText.style.fontSize = '12px';
                        healthText.style.marginTop = '2px';
                    }

                    contentContainer.appendChild(faceContainer);

                    const weapons = ['pistol', 'shotgun', 'machinegun', 'rocketLauncher', 'railgun'];
                    weapons.forEach((weapon, index) => {
                        const weaponDiv = document.createElement('div');
                        weaponDiv.id = `weapon-${weapon}`;
                        weaponDiv.style.cssText = `
                            color: white;
                            padding: 5px;
                            text-align: center;
                            border: 2px solid #666;
                            width: 90px;
                            height: 80px;
                            display: flex;
                            flex-direction: column;
                            justify-content: center;
                            background-color: rgba(0, 0, 0, 0.5);
                            border-radius: 8px;
                            font-size: 14px;
                        `;
                        
                        weaponDiv.innerHTML = `
                            <div style="margin-bottom: 4px;">${weapon.charAt(0).toUpperCase() + weapon.slice(1)}</div>
                            <div id="ammo-${weapon}" style="margin-bottom: 2px;">0/${this.config.weapons[weapon].maxAmmo}</div>
                            <div style="font-size: 10px;">(${index + 1})</div>
                        `;
                        
                        contentContainer.appendChild(weaponDiv);
                    });

                    panel.appendChild(contentContainer);
                    document.body.appendChild(panel);
                    
                    // Initial update of soldier face
                    this.updateSoldierFace();
                }

                updateWeaponPanel() {
                    const weapons = ['pistol', 'shotgun', 'machinegun', 'rocketLauncher', 'railgun'];
                    
                    weapons.forEach(weapon => {
                        const weaponDiv = document.getElementById(`weapon-${weapon}`);
                        const ammoDiv = document.getElementById(`ammo-${weapon}`);
                        
                        if (this.state.currentWeapon === weapon) {
                            weaponDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                        } else {
                            weaponDiv.style.backgroundColor = 'transparent';
                        }

                        if (this.state.weapons[weapon].owned) {
                            weaponDiv.style.opacity = '1';
                            if (weapon === 'pistol') {
                                ammoDiv.textContent = '∞';  // Show infinity symbol for pistol
                            } else {
                                ammoDiv.textContent = `${this.state.weapons[weapon].ammo}/${this.config.weapons[weapon].maxAmmo}`;
                            }
                        } else {
                            weaponDiv.style.opacity = '0.5';
                            ammoDiv.textContent = '---';
                        }
                    });
                }

                setupHealthBar() {
                    const healthContainer = document.createElement('div');
                    healthContainer.style.cssText = `
                        position: fixed;
                        top: 20px;
                        left: 20px;
                        width: 200px;
                        height: 20px;
                        background: rgba(0, 0, 0, 0.5);
                        border: 2px solid #fff;
                    `;

                    const healthBar = document.createElement('div');
                    healthBar.id = 'health-bar';
                    healthBar.style.cssText = `
                        width: 100%;
                        height: 100%;
                        background: #ff0000;
                        transition: width 0.3s;
                    `;

                    healthContainer.appendChild(healthBar);
                    document.body.appendChild(healthContainer);
                }

                updateHealthBar() {
                    const healthBar = document.getElementById('health-bar');
                    if (healthBar) {
                        const healthPercent = (this.state.health / 100) * 100;
                        healthBar.style.width = `${healthPercent}%`;
                    }
                    
                    // Update soldier face when health changes
                    this.updateSoldierFace();
                }

                updateWeaponPosition() {
                    if (!this.weaponModels[this.state.currentWeapon]) return;

                    const weapon = this.weaponModels[this.state.currentWeapon];
                    if (!this.weaponContainer.children.includes(weapon)) {
                        this.weaponContainer.clear();
                        this.weaponContainer.add(weapon);
                        
                        weapon.traverse(child => {
                            if (child.isMesh) {
                                child.renderOrder = 999;
                                if (child.material) {
                                    child.material.depthTest = false;
                                    child.material.depthWrite = false;
                                }
                            }
                        });
                    }

                    // Base position
                    const basePosition = new THREE.Vector3(0., -0.4, -0.5);
                    
                    // Handle weapon bob
                    if (this.keys.w || this.keys.s || this.keys.a || this.keys.d) {
                        this.state.weaponBob.time += 0.1;
                        this.state.weaponBob.offset.y = Math.sin(this.state.weaponBob.time) * this.state.weaponBob.intensity;
                        this.state.weaponBob.offset.x = Math.cos(this.state.weaponBob.time * 0.5) * this.state.weaponBob.intensity * 0.5;
                    } else {
                        this.state.weaponBob.offset.lerp(new THREE.Vector3(0, 0, 0), 0.1);
                    }

                    // Handle recoil recovery
                    const currentTime = Date.now();
                    if (currentTime - this.state.recoil.lastShootTime > this.state.recoil.recoveryDelay) {
                        this.state.recoil.current *= 0.9; // Exponential decay
                        if (this.state.recoil.current < 0.001) this.state.recoil.current = 0;
                    }

                    // Calculate recoil offset
                    const recoilOffset = new THREE.Vector3(
                        0,
                        -Math.sin(this.state.recoil.current * Math.PI) * 0.1,
                        this.state.recoil.current
                    );

                    // Apply all offsets
                    weapon.position.copy(basePosition)
                        .add(this.state.weaponBob.offset)
                        .add(recoilOffset);

                    // Apply rotation with recoil
                    const recoilRotation = -this.state.recoil.current * 0.5;
                    if (this.state.currentWeapon === 'rocketLauncher') {
                        weapon.rotation.set(
                            this.rotationX * 0.2 + recoilRotation,
                            -Math.PI / 2,
                            0
                        );
                    } else {
                        weapon.rotation.set(
                            this.rotationX * 0.2 + recoilRotation,
                            0,
                            0
                        );
                    }

                    weapon.scale.set(1.5, 1.5, 1.5);
                }

                render() {
                    // Ensure weapon container and its children have highest render order
                    this.weaponContainer.renderOrder = 999;
                    this.weaponContainer.traverse(child => {
                        if (child.isMesh) {
                            child.renderOrder = 999;
                            if (child.material) {
                                child.material.transparent = true;
                                child.material.depthTest = false;
                                child.material.depthWrite = false;
                            }
                        }
                    });
                    
                    // Render scene
                    this.renderer.render(this.scene, this.camera);
                }

                // Add this cleanup method
                cleanup() {
                    // Remove all weapons from both scenes
                    if (this.weaponScene) {
                        while(this.weaponScene.children.length > 0) {
                            this.weaponScene.remove(this.weaponScene.children[0]);
                        }
                    }
                    
                    const weaponsToRemove = this.scene.children.filter(child => 
                        child.name === 'weapon' || child.name === 'pistol' || child.name === 'gun'
                    );
                    weaponsToRemove.forEach(weapon => this.scene.remove(weapon));
                }

                // Call cleanup when changing weapons or restarting game
                // Add to your game reset or level change functions
                resetGame() {
                    this.cleanup();
                    this.setupWeapons();
                    // ... other reset code ...
                }

                // Create the soldier face UI
                setupSoldierFace() {
                    // Create container for soldier face
                    const faceContainer = document.createElement('div');
                    faceContainer.id = 'soldier-face-container';
                    faceContainer.style.cssText = `
                        width: 150px;
                        height: 150px;
                        background-color: rgba(0, 0, 0, 0.5);
                        border: 2px solid #666;
                        border-radius: 10px;
                        padding: 10px;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                    `;
                    
                    // Create face elements
                    const faceDiv = document.createElement('div');
                    faceDiv.id = 'soldier-face';
                    faceDiv.style.cssText = `
                        width: 120px;
                        height: 120px;
                        position: relative;
                        background-color: #a87c5c;
                        border-radius: 60px;
                        overflow: hidden;
                    `;
                    
                    // Create eyes
                    const leftEye = document.createElement('div');
                    leftEye.id = 'left-eye';
                    leftEye.className = 'eye';
                    leftEye.style.cssText = `
                        position: absolute;
                        width: 30px;
                        height: 20px;
                        background-color: white;
                        border-radius: 50%;
                        top: 30px;
                        left: 25px;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                    `;
                    
                    const rightEye = document.createElement('div');
                    rightEye.id = 'right-eye';
                    rightEye.className = 'eye';
                    rightEye.style.cssText = `
                        position: absolute;
                        width: 30px;
                        height: 20px;
                        background-color: white;
                        border-radius: 50%;
                        top: 30px;
                        right: 25px;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                    `;
                    
                    // Create pupils
                    const leftPupil = document.createElement('div');
                    leftPupil.id = 'left-pupil';
                    leftPupil.className = 'pupil';
                    leftPupil.style.cssText = `
                        width: 12px;
                        height: 12px;
                        background-color: #000;
                        border-radius: 50%;
                    `;
                    
                    const rightPupil = document.createElement('div');
                    rightPupil.id = 'right-pupil';
                    rightPupil.className = 'pupil';
                    rightPupil.style.cssText = `
                        width: 12px;
                        height: 12px;
                        background-color: #000;
                        border-radius: 50%;
                    `;
                    
                    // Create mouth
                    const mouth = document.createElement('div');
                    mouth.id = 'mouth';
                    mouth.style.cssText = `
                        position: absolute;
                        width: 60px;
                        height: 15px;
                        background-color: #600;
                        border-radius: 0 0 30px 30px;
                        bottom: 30px;
                        left: -30px;
                    `;
                    
                    // Create blood overlay
                    const bloodOverlay = document.createElement('div');
                    bloodOverlay.id = 'blood-overlay';
                    bloodOverlay.style.cssText = `
                        position: absolute;
                        width: 100%;
                        height: 100%;
                        background: linear-gradient(transparent 50%, rgba(255,0,0,0.5));
                        top: 0;
                        left: 0;
                        pointer-events: none;
                        display: none;
                        z-index: 2;
                    `;
                    
                    // Create health text
                    const healthText = document.createElement('div');
                    healthText.id = 'soldier-health-text';
                    healthText.style.cssText = `
                        color: white;
                        font-size: 18px;
                        font-weight: bold;
                        text-align: center;
                        margin-top: 5px;
                    `;
                    healthText.textContent = '100%';
                    
                    // Assemble the face elements
                    leftEye.appendChild(leftPupil);
                    rightEye.appendChild(rightPupil);
                    
                    // Add elements to face in correct order
                    faceDiv.appendChild(bloodOverlay);
                    faceDiv.appendChild(leftEye);
                    faceDiv.appendChild(rightEye);
                    faceDiv.appendChild(mouth);
                    
                    faceContainer.appendChild(faceDiv);
                    faceContainer.appendChild(healthText);
                    
                    return faceContainer;
                }

                // Update the soldier face based on health and powerups
                updateSoldierFace() {
                    const health = this.state.health;
                    const hasSpeed = this.state.powerups.speed.active;
                    const hasInvincibility = this.state.powerups.invincibility.active;
                    
                    // Update health text
                    const healthText = document.getElementById('soldier-health-text');
                    if (healthText) {
                        healthText.textContent = `${health}%`;
                        
                        // Change color based on health
                        if (health > 75) {
                            healthText.style.color = '#0f0'; // Green for high health
                        } else if (health > 50) {
                            healthText.style.color = '#ff0'; // Yellow for medium health
                        } else if (health > 25) {
                            healthText.style.color = '#f90'; // Orange for low health
                        } else {
                            healthText.style.color = '#f00'; // Red for critical health
                        }
                    }
                    
                    // Blood effect when health is low
                    const bloodOverlay = document.getElementById('blood-overlay');
                    if (bloodOverlay) {
                        // Changed condition to show blood earlier and made it more visible
                        if (health <= 50) {
                            bloodOverlay.style.display = 'block';
                            const opacity = (100 - health) / 100 * 0.7; // Adjusted opacity calculation
                            bloodOverlay.style.background = `linear-gradient(transparent 50%, rgba(255,0,0,${opacity}))`;
                        } else {
                            bloodOverlay.style.display = 'none';
                        }
                    }
                    
                    // Update mouth based on health - adjusted expressions
                    const mouth = document.getElementById('mouth');
                    if (mouth) {
                        if (health > 75) {
                            // Happy
                            mouth.style.height = '15px';
                            mouth.style.borderRadius = '0 0 30px 30px';
                            mouth.style.bottom = '30px';
                        } else if (health > 50) {
                            // Slight smile
                            mouth.style.height = '10px';
                            mouth.style.borderRadius = '0 0 20px 20px';
                            mouth.style.bottom = '32px';
                        } else if (health > 25) {
                            // Straight
                            mouth.style.height = '5px';
                            mouth.style.borderRadius = '0';
                            mouth.style.bottom = '35px';
                        } else {
                            // Pain - made more pronounced
                            mouth.style.height = '15px';
                            mouth.style.borderRadius = '30px 30px 0 0'; // Inverted curve for frown
                            mouth.style.bottom = '25px'; // Moved lower
                            mouth.style.backgroundColor = '#800'; // Darker red
                        }
                    }
                    
                    // Update eyes based on powerups and health - made low health more visible
                    const eyes = document.querySelectorAll('.eye');
                    const pupils = document.querySelectorAll('.pupil');
                    
                    if (hasInvincibility) {
                        // Golden eyes for invincibility
                        eyes.forEach(eye => {
                            eye.style.height = '20px';
                            eye.style.backgroundColor = '#ffd700';
                            eye.style.boxShadow = '0 0 10px #ffd700';
                        });
                        pupils.forEach(pupil => {
                            pupil.style.backgroundColor = '#ff8c00';
                        });
                    } else if (hasSpeed) {
                        // Flame eyes for speed
                        eyes.forEach(eye => {
                            eye.style.height = '20px';
                            eye.style.backgroundColor = '#ff3300';
                            eye.style.boxShadow = '0 0 10px #ff3300';
                        });
                        pupils.forEach(pupil => {
                            pupil.style.backgroundColor = '#ffcc00';
                        });
                    } else if (health <= 25) {
                        // Pain expression - made more dramatic
                        eyes.forEach(eye => {
                            eye.style.height = '6px'; // More squinted
                            eye.style.backgroundColor = '#ffcccc'; // Slightly reddish
                            eye.style.transform = 'rotate(-10deg)'; // Angled for pain
                        });
                        pupils.forEach(pupil => {
                            pupil.style.height = '3px'; // More squinted
                            pupil.style.backgroundColor = '#600'; // Dark red
                        });
                    } else {
                        // Normal eyes
                        eyes.forEach(eye => {
                            eye.style.height = '20px';
                            eye.style.backgroundColor = 'white';
                            eye.style.boxShadow = 'none';
                            eye.style.transform = 'none';
                        });
                        pupils.forEach(pupil => {
                            pupil.style.height = '12px';
                            pupil.style.backgroundColor = 'black';
                        });
                    }
                }

                checkRailgunWallCollision(raycaster) {
                    const cellSize = this.config.cellSize;
                    const maxDistance = 100;
                    const steps = 100;
                    const stepSize = maxDistance / steps;
                    
                    for (let i = 0; i < steps; i++) {
                        const point = raycaster.ray.at(i * stepSize, new THREE.Vector3());
                        const gridX = Math.floor((point.x + (this.config.mazeSize * cellSize / 2)) / cellSize);
                        const gridZ = Math.floor((point.z + (this.config.mazeSize * cellSize / 2)) / cellSize);
                        
                        if (gridX < 0 || gridX >= this.config.mazeSize || 
                            gridZ < 0 || gridZ >= this.config.mazeSize ||
                            this.maze[gridX][gridZ] === 1) {
                            return point;
                        }
                    }
                    return null;
                }

                fireRailgun() {
                    const weaponConfig = this.config.weapons.railgun;

                    // Get exact direction where camera/crosshair is pointing
                    const direction = new THREE.Vector3(0, 0, -1);
                    direction.unproject(this.camera);
                    direction.sub(this.camera.position).normalize();

                    const railgunGroup = new THREE.Group();

                    // Define railgun projectile geometry
                    const railPoints = [
                        new THREE.Vector2(0, 0),
                        new THREE.Vector2(0.03, 0.2),
                        new THREE.Vector2(0.03, 1.0),
                        new THREE.Vector2(0, 1.0)
                    ];
                    const railGeometry = new THREE.LatheGeometry(railPoints, 8);
                    const railMaterial = new THREE.MeshStandardMaterial({
                        color: weaponConfig.beamColor,
                        emissive: weaponConfig.beamColor,
                        emissiveIntensity: 1,
                        metalness: 0.9,
                        roughness: 0.2
                    });
                    const railProjectile = new THREE.Mesh(railGeometry, railMaterial);
                    railProjectile.rotation.x = Math.PI / 2;
                    railgunGroup.add(railProjectile);

                    // Add a glow light
                    const glowLight = new THREE.PointLight(weaponConfig.beamColor, 2, 2);
                    railgunGroup.add(glowLight);

                    // Create a longer, spinning tail
                    const tailLength = 50;
                    const trailGeometry = new THREE.BufferGeometry();
                    const trailMaterial = new THREE.LineBasicMaterial({
                        color: weaponConfig.beamColor,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    // Create spiral trail positions
                    const trailPositions = new Float32Array(tailLength * 3);
                    const radius = 0.1;
                    for (let i = 0; i < tailLength; i++) {
                        const t = i / tailLength;
                        const angle = t * Math.PI * 8;
                        trailPositions[i * 3] = Math.cos(angle) * radius * (1 - t);
                        trailPositions[i * 3 + 1] = Math.sin(angle) * radius * (1 - t);
                        trailPositions[i * 3 + 2] = -i * 0.1;
                    }
                    
                    trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
                    const trail = new THREE.Line(trailGeometry, trailMaterial);
                    railgunGroup.add(trail);

                    railgunGroup.position.copy(this.camera.position);
                    railgunGroup.position.add(direction.clone().multiplyScalar(0));
                    railgunGroup.position.y -= 0.1;
                    
                    const quaternion = new THREE.Quaternion();
                    quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction);
                    railgunGroup.quaternion.copy(quaternion);

                    railgunGroup.userData = {
                        velocity: direction.clone().multiplyScalar(0.5),
                        distance: 0,
                        maxDistance: 100,
                        damage: weaponConfig.damage,
                        type: 'railgun',
                        prevPosition: railgunGroup.position.clone(),
                        piercing: true,
                        spinSpeed: 0.5,
                        trail: trail,
                        trailCounter: 0,
                        rotationAngle: 0,
                        hitMonsters: new Set()
                    };

                    this.projectiles.push(railgunGroup);
                    this.scene.add(railgunGroup);

                    // Railgun sound effects
                    this.playSound(880, 0.1, 'sawtooth', 0.3);
                    this.playSound(440, 0.2, 'square', 0.2);
                    
                    // Set correct render order
                    railgunGroup.renderOrder = 0;
                    railgunGroup.traverse(child => {
                        if (child.isMesh) {
                            child.renderOrder = 0;
                            child.material.depthTest = true;
                            child.material.depthWrite = true;
                        }
                    });
                }

            addScreenShake(intensity = 0.1, duration = 100) {
                if (!this.screenShakeEffect) {
                    this.screenShakeEffect = {
                        intensity: 0,
                        duration: 0,
                        startTime: 0,
                        originalPosition: new THREE.Vector3(),
                        shakeOffset: new THREE.Vector3()
                    };
                }
                
                // Set shake parameters
                this.screenShakeEffect.intensity = intensity;
                this.screenShakeEffect.duration = duration;
                this.screenShakeEffect.startTime = Date.now();
                this.screenShakeEffect.originalPosition.copy(this.camera.position);
                
                // Apply initial shake
                this.applyScreenShake();
                
                // Set interval to update shake
                const shakeInterval = setInterval(() => {
                    if (Date.now() - this.screenShakeEffect.startTime >= this.screenShakeEffect.duration) {
                        clearInterval(shakeInterval);
                        // Reset camera position
                        this.camera.position.sub(this.screenShakeEffect.shakeOffset);
                        this.screenShakeEffect.shakeOffset.set(0, 0, 0);
                    } else {
                        this.applyScreenShake();
                    }
                }, 16); // ~60fps
            }
            
            applyScreenShake() {
                // Remove previous offset
                this.camera.position.sub(this.screenShakeEffect.shakeOffset);
                
                // Calculate new random offset
                const timeLeft = 1 - ((Date.now() - this.screenShakeEffect.startTime) / this.screenShakeEffect.duration);
                const currentIntensity = this.screenShakeEffect.intensity * timeLeft;
                
                this.screenShakeEffect.shakeOffset.set(
                    (Math.random() * 2 - 1) * currentIntensity,
                    (Math.random() * 2 - 1) * currentIntensity * 0.5,  // Less vertical shake
                    (Math.random() * 2 - 1) * currentIntensity
                );
                
                // Apply new offset
                this.camera.position.add(this.screenShakeEffect.shakeOffset);
            }

            // New helper function to find direction away from nearest wall
            findNearestWallDirection(position) {
                const cellSize = this.config.cellSize;
                const gridX = Math.floor((position.x + (this.config.mazeSize * cellSize / 2)) / cellSize);
                const gridZ = Math.floor((position.z + (this.config.mazeSize * cellSize / 2)) / cellSize);
                
                let closestWallDistance = Infinity;
                let closestWallDirection = null;
                
                // Check all adjacent cells (including diagonals)
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        if (dx === 0 && dz === 0) continue; // Skip self
                        
                        const checkX = gridX + dx;
                        const checkZ = gridZ + dz;
                        
                        if (checkX < 0 || checkX >= this.config.mazeSize || 
                            checkZ < 0 || checkZ >= this.config.mazeSize) {
                            continue;
                        }
                        
                        if (this.maze[checkX][checkZ] === 1) { // It's a wall
                            const wallX = (checkX - this.config.mazeSize/2) * cellSize;
                            const wallZ = (checkZ - this.config.mazeSize/2) * cellSize;
                            
                            const dx = position.x - wallX;
                            const dz = position.z - wallZ;
                            const distance = Math.sqrt(dx*dx + dz*dz);
                            
                            if (distance < closestWallDistance) {
                                closestWallDistance = distance;
                                closestWallDirection = new THREE.Vector3(dx, 0, dz).normalize();
                            }
                        }
                    }
                }
                
                return closestWallDirection;
            }

            spawnTestMonster(type) {
                let position;
                let attempts = 0;
                const maxAttempts = 100;
                
                do {
                    // Calculate position within the maze bounds
                    const gridX = Math.floor(Math.random() * (this.config.mazeSize - 2)) + 1;
                    const gridZ = Math.floor(Math.random() * (this.config.mazeSize - 2)) + 1;
                    
                    position = new THREE.Vector3(
                        (gridX - this.config.mazeSize/2) * this.config.cellSize,
                        type === 'flying' ? 3.0 : 0,
                        (gridZ - this.config.mazeSize/2) * this.config.cellSize
                    );
                    
                    attempts++;
                } while (this.checkCollision(position, true) && attempts < maxAttempts);
                
                if (attempts < maxAttempts) {
                    const monster = this.createMonster(type);
                    monster.position.copy(position);
                    this.monsters.push(monster);
                    this.scene.add(monster);
                    this.state.enemiesRemaining = this.monsters.length;
                    document.getElementById('enemies').textContent = this.state.enemiesRemaining;
                    console.log(`Spawned test ${type} monster at position (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)})`);
                } else {
                    console.warn("Could not find valid spawn position for monster after", maxAttempts, "attempts");
                }
            }

            spawnTestWeapon(type) {
                let position;
                let attempts = 0;
                const maxAttempts = 100;
                
                do {
                    // Calculate position within the maze bounds
                    const gridX = Math.floor(Math.random() * (this.config.mazeSize - 2)) + 1;
                    const gridZ = Math.floor(Math.random() * (this.config.mazeSize - 2)) + 1;
                    
                    position = new THREE.Vector3(
                        (gridX - this.config.mazeSize/2) * this.config.cellSize,
                        0.5,
                        (gridZ - this.config.mazeSize/2) * this.config.cellSize
                    );
                    
                    attempts++;
                } while (this.checkCollision(position) && attempts < maxAttempts);
                
                if (attempts < maxAttempts) {
                    this.createPowerup(type, position);
                    console.log(`Spawned test ${type} at position (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)})`);
                } else {
                    console.warn("Could not find valid spawn position for", type, "after", maxAttempts, "attempts");
                }
            }

        } // Close the Game class definition here

        let game = null;

        function startGame(mode) {
            // Hide mode selection and show game
            document.getElementById('mode-selection').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
            
            // Initialize game with selected mode
            game = new Game(mode);
            
            // Add spawn panel if in test mode
            if (mode === 'testing') {
                const spawnPanel = document.createElement('div');
                spawnPanel.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    height: 100vh;
                    width: 150px;
                    background: rgba(0, 0, 0, 0.8);
                    padding: 10px;
                    border-right: 2px solid #ff0000;
                    color: white;
                    z-index: 1000;
                    overflow-y: auto;
                `;
                
                spawnPanel.innerHTML = `
                    <h3 style="font-size: 14px; margin: 5px 0;">Test Controls</h3>
                    <div style="margin: 5px 0;">
                        <h4 style="font-size: 12px; margin: 5px 0;">Player</h4>
                        <button onclick="game.state.health = 100; game.updateHealthBar(); game.updateSoldierFace();" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px; background: #4CAF50; color: white;">Refill Health</button>
                    </div>
                    <div style="margin: 5px 0;">
                        <h4 style="font-size: 12px; margin: 5px 0;">Monsters</h4>
                        <button onclick="game.spawnTestMonster('ground')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Ground Monster</button>
                        <button onclick="game.spawnTestMonster('flying')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Flying Monster</button>
                        <button onclick="game.spawnTestMonster('archer')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Archer Monster</button>
                        <button onclick="game.spawnTestMonster('spider')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Spider Monster</button>
                        <button onclick="game.spawnTestMonster('giant')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Giant Monster</button>
                    </div>
                    <div style="margin: 5px 0;">
                        <h4 style="font-size: 12px; margin: 5px 0;">Weapons</h4>
                        <button onclick="game.spawnTestWeapon('shotgun')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Shotgun</button>
                        <button onclick="game.spawnTestWeapon('machinegun')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Machine Gun</button>
                        <button onclick="game.spawnTestWeapon('rocketLauncher')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Rocket Launcher</button>
                        <button onclick="game.spawnTestWeapon('railgun')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Railgun</button>
                    </div>
                    <div style="margin: 5px 0;">
                        <h4 style="font-size: 12px; margin: 5px 0;">Power-Ups</h4>
                        <button onclick="game.spawnTestWeapon('health')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Health Pack</button>
                        <button onclick="game.spawnTestWeapon('speed')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Speed Boost</button>
                        <button onclick="game.spawnTestWeapon('invincibility')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Invincibility</button>
                    </div>
                `;
                
                document.body.appendChild(spawnPanel);
            }
            
            // Add resize listener
            window.addEventListener('resize', () => {
                game.camera.aspect = window.innerWidth / window.innerHeight;
                game.camera.updateProjectionMatrix();
                game.renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }


        </script>
    </body>
</html>
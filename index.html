l<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Doom-style Shooter</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
            background-color: black;
            transition: background-color 0.15s;
        }
        #game-container { 
            width: 100vw; 
            height: 100vh; 
            display: none;
        }
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #ff0000;
            font-size: 24px;
            text-shadow: 2px 2px 2px black;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: red;
        }

        /* Vertical line */
        #crosshair::before {
            left: 50%;
            top: 0;
            width: 2px;
            height: 20px;
            transform: translateX(-50%);
        }

        /* Horizontal line */
        #crosshair::after {
            top: 50%;
            left: 0;
            width: 20px;
            height: 2px;
            transform: translateY(-50%);
        }

        /* Gap in the center */
        #crosshair::before {
            background: linear-gradient(to bottom, 
                red 0%, 
                red 45%, 
                transparent 45%, 
                transparent 55%, 
                red 55%, 
                red 100%
            );
        }

        #crosshair::after {
            background: linear-gradient(to right, 
                red 0%, 
                red 45%, 
                transparent 45%, 
                transparent 55%, 
                red 55%, 
                red 100%
            );
        }
    /* Blood overlay for player damage */
    #screen-blood-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        background: radial-gradient(ellipse at center, transparent 50%, rgba(255,0,0,0.5) 100%);
        opacity: 0;
        transition: opacity 0.5s;
        z-index: 100;
        display: none;
    }
    #mode-selection {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        padding: 30px;
        border: 2px solid #ff0000;
        color: white;
        text-align: center;
        font-family: Arial, sans-serif;
        z-index: 1000;
    }
    .mode-button {
        display: block;
        width: 200px;
        padding: 15px;
        margin: 10px auto;
        background: #ff0000;
        color: white;
        border: none;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.3s;
    }
    .mode-button:hover {
        background: #cc0000;
    }
    </style>
</head>
<body>
    <div id="mode-selection">
        <h2>Select Game Mode</h2>
        <button class="mode-button" onclick="startGame('testing')">Testing Mode</button>
        <button class="mode-button" onclick="startGame('normal')">Normal Mode</button>
        <button class="mode-button" onclick="startGame('multiplayer')">Multiplayer Mode</button>
    </div>
    <div id="game-container">
        <div id="hud">
            Level: <span id="level">1</span> | 
            Enemies: <span id="enemies">5</span>
        </div>
        <div id="crosshair"></div>
    <div id="screen-blood-overlay"></div>
        <div id="pause-menu" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: rgba(0,0,0,0.8); padding: 20px; color: red; text-align: center; border: 2px solid red;">
            <h2>PAUSED</h2>
            <p>Press ESC to resume</p>
            <p>Current Level: <span id="pause-level">1</span></p>
            <p>Enemies Remaining: <span id="pause-enemies">5</span></p>
        </div>
        <canvas id="minimap" style="position: fixed; top: 20px; right: 20px;"></canvas>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <script>
        class Monster {
            constructor(game) {
                this.game = game;
                this.mesh = new THREE.Group();
                this.health = 100;
                this.speed = game.config.monsterSpeed;
                this.damage = game.config.monsterDamage;
                this.detectionRadius = 15;
                this.attackRange = 2.0;
                this.attackCooldown = 1000;
                this.lastAttackTime = 0;
                this.state = "patrolling";
                this.patrolTimeRemaining = 0;
                this.animationTime = Math.random() * Math.PI * 2;
                this.animationSpeed = 0.1;
                this.isGrounded = true;
                this.baseHeight = 0;
                this.collisionRadius = 0.2; // Default collision radius
            }

            createMesh() {
                // To be implemented by subclasses
                throw new Error("createMesh must be implemented by subclass");
            }

            update() {
                // To be implemented by subclasses
                throw new Error("update must be implemented by subclass");
            }

            takeDamage(damage) {
                this.health -= damage;
                return this.health <= 0;
            }

            findValidPosition() {
                let validPosition = false;
                let attempts = 0;
                const maxAttempts = 100;
                
                while (!validPosition && attempts < maxAttempts) {
                    attempts++;
                    
                    const gridX = Math.floor(Math.random() * (this.game.config.mazeSize - 2)) + 1;
                    const gridZ = Math.floor(Math.random() * (this.game.config.mazeSize - 2)) + 1;
                    
                    const x = (gridX - this.game.config.mazeSize/2) * this.game.config.cellSize;
                    const z = (gridZ - this.game.config.mazeSize/2) * this.game.config.cellSize;
                    
                    this.mesh.position.set(x, this.baseHeight, z);
                    
                    if (!this.game.checkCollision(this.mesh.position, true) && 
                        this.mesh.position.distanceTo(this.game.camera.position) > 10) {
                        validPosition = true;
                    }
                }
                
                if (!validPosition) {
                    console.warn("Could not find valid position for monster");
                    this.mesh.position.set(0, this.baseHeight, 0);
                }
            }
        }

        class ChargerMonster extends Monster {
            constructor(game) {
                super(game);
                this.baseHeight = 0;
                this.health = 200;
                this.speed = game.config.monsterSpeed * 0.7;
                this.chargeSpeed = game.config.monsterSpeed * 10;
                this.damage = game.config.monsterDamage * 2;
                this.detectionRadius = 20;
                this.attackRange = 2;
                this.isCharging = false;
                this.isPreparingCharge = false;
                this.isStunned = false;
                this.chargeDirection = new THREE.Vector3();
                this.chargeAlignmentTime = 0;
                this.chargeStartTime = 0;
                this.chargeDuration = 2000; // 2 seconds preparation
                this.stunEndTime = 0;
                this.originalBodyColor = 0x403030; // Store original color
                this.chargeBodyColor = 0xff0000; // Red color for charging
                this.bodyMaterial = null; // Will store reference to body material
                this.headMaterial = null; // Will store reference to head material
                this.meleeAttackDamage = this.damage * 0.75; // 75% damage of charge
                this.collisionRadius = 0.9; // Based on large body size
                this.lineOfSightBlockedTime = 0; // Track how long sight has been blocked
                this.createMesh();
                this.findValidPosition();
            }

            createMesh() {
                const chargerGroup = new THREE.Group();
                
                // Rhino body colors - darker brown to match image
                const bodyColor = 0x403030; // Dark brownish for rhino skin
                const hornColor = 0x8a7a6d; // Bone-like color for horns/spikes
                
                // Body - larger and more organic shape using combined geometries
                const bodyGroup = new THREE.Group();
                
                // Main torso - use ellipsoid instead of box for more organic shape
                const torsoGeometry = new THREE.SphereGeometry(1.0, 13, 10);
                this.bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: this.originalBodyColor,
                    roughness: 0.9,
                    metalness: 0.2
                });
                const torso = new THREE.Mesh(torsoGeometry, this.bodyMaterial);
                torso.scale.set(1.0, 0.7, 1.2); // Flatten and elongate
                torso.position.y = 0.85;
                bodyGroup.add(torso);
                
                // Lower body/haunches - for better limb coverage
                const lowerBodyGeometry = new THREE.SphereGeometry(0.9, 9, 8);
                const lowerBody = new THREE.Mesh(lowerBodyGeometry, this.bodyMaterial);
                lowerBody.scale.set(1.0, 0.6, 1.0);
                lowerBody.position.set(0, 0.6, 0);
                bodyGroup.add(lowerBody);
                
                // Shoulder area - for better front limb coverage
                const shoulderGeometry = new THREE.SphereGeometry(0.8, 13, 10);
                const shoulder = new THREE.Mesh(shoulderGeometry, this.bodyMaterial);
                shoulder.scale.set(1.1, 0.7, 0.8);
                shoulder.position.set(0, 0.9, 0.6);
                bodyGroup.add(shoulder);
                
                // Head - replace box with organic shape
                const headGroup = new THREE.Group();
                
                // Base head shape - elongated sphere
                const baseHeadGeometry = new THREE.SphereGeometry(0.5, 8, 10);
                this.headMaterial = new THREE.MeshStandardMaterial({ 
                    color: bodyColor,
                    roughness: 0.9,
                    metalness: 0.2
                });
                const baseHead = new THREE.Mesh(baseHeadGeometry, this.headMaterial);
                baseHead.scale.set(0.9, 0.8, 1.2);
                baseHead.position.set(0, 0, 0.1);
                headGroup.add(baseHead);
                
                // Snout/muzzle - more pointed for rhino
                const snoutGeometry = new THREE.SphereGeometry(0.4, 9, 9);
                const snout = new THREE.Mesh(snoutGeometry, this.headMaterial);
                snout.scale.set(1.0, 0.75, 1.2);
                snout.position.set(0, -0.1, 0.4);
                headGroup.add(snout);
                
                // Slight bulge on top for more natural shape
                const headTopGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                const headTop = new THREE.Mesh(headTopGeometry, this.headMaterial);
                headTop.scale.set(1.1, 0.6, 0.8);
                headTop.position.set(0, 0.3, -0.1);
                headGroup.add(headTop);
                
                // Position the entire head group
                headGroup.position.set(0, 1.3, 0.9);
                
                // Add eyes
                const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff0000, // Red glowing eyes
                    emissive: 0xff0000,
                    emissiveIntensity: 0.5,
                    roughness: 0.3,
                    metalness: 0.7
                });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.25, 1.45, 1.5);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.25, 1.45, 1.5);
                
                // Replace flat mouth with curved mouth
                const mouthGroup = new THREE.Group();
                
                // Create a curved mouth using a partial torus
                const mouthGeometry = new THREE.TorusGeometry(0.15, 0.05, 8, 12, Math.PI);
                const mouthMaterial = new THREE.MeshStandardMaterial({
                    color: 0x1a0000, // Dark reddish black
                    roughness: 1.0,
                    metalness: 0.1
                });
                const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.rotation.x = Math.PI / 2; // Orient the torus
                mouth.rotation.y = Math.PI; // Turn it so open part faces down
                mouth.scale.set(1, 1, 0.5); // Flatten it a bit
                mouth.position.set(0, 1.15, 1.6);
                mouthGroup.add(mouth);
                
                // Add teeth - curved arrangement
                const teethGeometry = new THREE.BoxGeometry(0.04, 0.06, 0.04);
                const teethMaterial = new THREE.MeshStandardMaterial({
                    color: 0xf0f0f0, // Off-white
                    roughness: 0.5,
                    metalness: 0.2
                });
                
                const teeth = [];
                // Create teeth in a curved arrangement
                const teethCount = 5;
                const teethArc = Math.PI * 0.6; // Arc for teeth placement
                
                for (let i = 0; i < teethCount; i++) {
                    const tooth = new THREE.Mesh(teethGeometry, teethMaterial);
                    
                    // Calculate position along curve
                    const angle = (i / (teethCount - 1)) * teethArc - (teethArc / 2);
                    const radius = 0.25; // Match the torus radius
                    
                    // Position tooth along curve
                    const x = Math.sin(angle) * radius;
                    const z = Math.cos(angle) * radius + 1.55; // Offset forward
                    const y = 1.13 - Math.abs(x) * 0.05; // Slight vertical curve
                    
                    tooth.position.set(x, y, z);
                    
                    // Rotate each tooth to face outward from the curve
                    tooth.rotation.y = -angle;
                    
                    tooth.userData.originalY = tooth.position.y;
                    teeth.push(tooth);
                    mouthGroup.add(tooth);
                }
                
                // Add sharper fangs at corners
                const fangGeometry = new THREE.ConeGeometry(0.04, 0.12, 8);
                
                const leftFang = new THREE.Mesh(fangGeometry, teethMaterial);
                leftFang.position.set(-0.23, 1.11, 1.65);
                leftFang.rotation.x = -Math.PI / 8;
                leftFang.rotation.z = -Math.PI / 10;
                leftFang.userData.originalY = leftFang.position.y;
                teeth.push(leftFang);
                mouthGroup.add(leftFang);
                
                const rightFang = new THREE.Mesh(fangGeometry, teethMaterial);
                rightFang.position.set(0.23, 1.11, 1.65);
                rightFang.rotation.x = -Math.PI / 8;
                rightFang.rotation.z = Math.PI / 10;
                rightFang.userData.originalY = rightFang.position.y;
                teeth.push(rightFang);
                mouthGroup.add(rightFang);
                
                // Main horn - large and intimidating
                const primaryHornGeometry = new THREE.ConeGeometry(0.18, 0.9, 8);
                const hornMaterial = new THREE.MeshStandardMaterial({
                    color: hornColor,
                    roughness: 0.5,
                    metalness: 0.4
                });
                const primaryHorn = new THREE.Mesh(primaryHornGeometry, hornMaterial);
                primaryHorn.rotation.x = Math.PI / 2; // Point forward correctly
                primaryHorn.position.set(0, 1.5, 1.7);
                
                // Secondary horn - smaller above the main horn
                const secondaryHornGeometry = new THREE.ConeGeometry(0.12, 0.5, 8);
                const secondaryHorn = new THREE.Mesh(secondaryHornGeometry, hornMaterial);
                secondaryHorn.rotation.x = Math.PI / 4; // Slightly angled
                secondaryHorn.position.set(0, 1.7, 1.7);
                
                // Legs - thick and stocky
                const createLeg = (isLeft, isFront) => {
                    const legGroup = new THREE.Group();
                    
                    // Thicker legs for rhino
                    const legGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.7, 8);
                    const leg = new THREE.Mesh(legGeometry, this.bodyMaterial);
                    leg.position.y = 0.35;
                    
                    // Foot
                    const footGeometry = new THREE.SphereGeometry(0.26, 8, 8);
                    const foot = new THREE.Mesh(footGeometry, new THREE.MeshStandardMaterial({
                        color: 0x2a1f1f, // Darker color for hooves
                        roughness: 0.9,
                        metalness: 0.3
                    }));
                    foot.scale.set(1, 0.4, 1);
                    foot.position.y = 0;
                    
                    legGroup.add(leg);
                    legGroup.add(foot);
                    
                    // Position the leg based on whether it's front or back, left or right
                    // Position legs more under the body for better appearance during animation
                    const xPos = isLeft ? -0.45 : 0.45;
                    const zPos = isFront ? 0.5 : -0.5;
                    legGroup.position.set(xPos, 0.25, zPos);
                    
                    return legGroup;
                };
                
                // Add all parts to the rhino mesh
                chargerGroup.add(bodyGroup);
                chargerGroup.add(headGroup);  // Use headGroup instead of head
                chargerGroup.add(leftEye);
                chargerGroup.add(rightEye);
                chargerGroup.add(mouthGroup);
                chargerGroup.add(primaryHorn);
                chargerGroup.add(secondaryHorn);
                
                // Create legs
                const frontLeftLeg = createLeg(true, true);
                const frontRightLeg = createLeg(false, true);
                const backLeftLeg = createLeg(true, false);
                const backRightLeg = createLeg(false, false);
                
                // Add legs
                chargerGroup.add(frontLeftLeg);
                chargerGroup.add(frontRightLeg);
                chargerGroup.add(backLeftLeg);
                chargerGroup.add(backRightLeg);
                
                // Add spikes
                const createSpike = (xPos, yPos, zPos, height, width, angle) => {
                    const spikeGeometry = new THREE.ConeGeometry(width, height, 8);
                    const spike = new THREE.Mesh(spikeGeometry, hornMaterial);
                    spike.rotation.x = angle;
                    spike.position.set(xPos, yPos, zPos);
                    return spike;
                };
                
                // Add multiple spikes along the back
                const spikes = [
                    createSpike(0, 1.7, 0.3, 0.7, 0.15, Math.PI / 6),
                    createSpike(0, 1.6, 0, 0.6, 0.14, 0),
                    createSpike(0, 1.5, -0.3, 0.8, 0.16, Math.PI / 12),
                    createSpike(0, 1.4, -0.6, 0.7, 0.15, Math.PI / 8),
                    // Side spikes
                    createSpike(0.4, 1.6, 0.1, 0.5, 0.12, -Math.PI / 3),
                    createSpike(-0.4, 1.6, 0.1, 0.5, 0.12, -Math.PI / 3),
                    createSpike(0.5, 1.5, -0.4, 0.6, 0.13, -Math.PI / 5),
                    createSpike(-0.5, 1.5, -0.4, 0.6, 0.13, -Math.PI / 5)
                ];
                spikes.forEach(spike => chargerGroup.add(spike));
                
                // Small tail
                const tailGeometry = new THREE.CylinderGeometry(0.08, 0.03, 0.5, 8);
                const tail = new THREE.Mesh(tailGeometry, this.bodyMaterial);
                tail.rotation.x = Math.PI / 3; // Angle up slightly
                tail.position.set(0, 0.9, -1.5);
                chargerGroup.add(tail);
                
                this.mesh = chargerGroup;
                
                // Store references for animation
                this.parts = {
                    bodyGroup, headGroup, leftEye, rightEye, mouthGroup, teeth, frontLeftLeg, frontRightLeg, backLeftLeg, backRightLeg,
                    originalPositions: {
                        bodyGroup: bodyGroup.position.clone(),
                        headGroup: headGroup.position.clone(),
                        leftEye: leftEye.position.clone(),
                        rightEye: rightEye.position.clone(),
                        mouthGroup: mouthGroup.position.clone(),
                        frontLeftLeg: frontLeftLeg.position.clone(),
                        frontRightLeg: frontRightLeg.position.clone(),
                        backLeftLeg: backLeftLeg.position.clone(),
                        backRightLeg: backRightLeg.position.clone()
                    }
                };
            }

            update() {
                // Force ground level
                this.mesh.position.y = this.baseHeight;

                // Check if stunned
                if (this.isStunned) {
                    if (Date.now() >= this.stunEndTime) {
                        this.isStunned = false;
                        // Reset color when no longer stunned
                        this.bodyMaterial.color.setHex(this.originalBodyColor);
                        this.headMaterial.color.setHex(this.originalBodyColor);
                    } else {
                        return; // Skip movement while stunned
                    }
                }

                // Direction to player
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, this.mesh.position)
                    .normalize();
                directionToPlayer.y = 0;

                const distanceToPlayer = this.mesh.position.distanceTo(this.game.camera.position);
                const isChasing = distanceToPlayer <= this.detectionRadius;
                this.state = isChasing ? "chasing" : "patrolling";
                
                let speed = this.speed;
                let moveDirection = new THREE.Vector3();
                
                if (this.isCharging) {
                    // Continue charge in the same direction
                    moveDirection.copy(this.chargeDirection);
                    speed = this.chargeSpeed;
                    
                    // Check if charge hit a wall
                    const moveVector = moveDirection.clone().multiplyScalar(speed);
                    const nextPos = this.mesh.position.clone().add(moveVector);
                    if (this.game.checkCollision(nextPos, true, false, this.collisionRadius)) {
                        this.isCharging = false;
                        this.isStunned = true;
                        this.stunEndTime = Date.now() + 2000; // 2 second stun
                        this.bodyMaterial.color.setHex(this.originalBodyColor); // Reset body color
                        this.headMaterial.color.setHex(this.originalBodyColor); // Reset head color
                        return;
                    }
                    
                    // Improved player hit detection - use a wider range while charging
                    const chargeAttackRange = this.attackRange * 1.2; // Much wider detection range while charging
                    
                    // Create a vector to the expected next position
                    const nextPosition = this.mesh.position.clone().add(moveDirection.clone().multiplyScalar(speed));
                    const nextDistanceToPlayer = nextPosition.distanceTo(this.game.camera.position);
                    
                    // Check if either current position or next position is close enough to player
                    if ((distanceToPlayer <= chargeAttackRange || nextDistanceToPlayer <= chargeAttackRange) && 
                        !this.game.state.powerups.invincibility.active) {
                        // Handle player damage and knockback
                        this.isCharging = false;
                        this.isStunned = false; // Don't stun charger when hitting player
                        this.bodyMaterial.color.setHex(this.originalBodyColor); // Reset body color
                        this.headMaterial.color.setHex(this.originalBodyColor); // Reset head color
                        
                        // Move charger to the point of impact with the player
                        // Calculate the exact impact point (slightly in front of the player)
                        const impactPoint = this.game.camera.position.clone();
                        impactPoint.y = this.mesh.position.y; // Keep the same height
                        
                        // Move slightly back from player to avoid clipping
                        const offsetFromPlayer = directionToPlayer.clone().multiplyScalar(-0.5);
                        impactPoint.add(offsetFromPlayer);
                        
                        // Only move if there's no collision
                        if (!this.game.checkCollision(impactPoint, true, false, this.collisionRadius)) {
                            this.mesh.position.copy(impactPoint);
                        }
                        
                        // Apply knockback to player - simplified and stronger
                        const knockbackDirection = directionToPlayer.clone().normalize();
                        const knockbackForce = 5.0; // Much stronger knockback
                        
                        // Instead of teleporting the player, create knockback velocity
                        // that will be applied gradually over time
                        if (!this.game.playerKnockback) {
                            this.game.playerKnockback = new THREE.Vector3();
                        }
                        
                        // Set knockback velocity
                        this.game.playerKnockback.x = knockbackDirection.x * knockbackForce;
                        this.game.playerKnockback.z = knockbackDirection.z * knockbackForce;
                        this.game.playerKnockbackTime = Date.now();
                        this.game.playerKnockbackDuration = 300; // Duration in ms
                        
                        // Apply damage
                        const currentTime = Date.now();
                        if (currentTime - this.lastAttackTime >= this.attackCooldown) {
                            this.game.state.health -= this.damage;
                            this.lastAttackTime = currentTime;
                            
                            // Visual feedback
                            document.body.style.backgroundColor = 'rgba(255,0,0,0.7)';
                            setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                            
                            const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                            if (screenBloodOverlay) {
                                screenBloodOverlay.style.opacity = '0.9';
                                setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                            }
                            
                            this.game.playSound(100, 0.1, 'square', 0.3);
                            this.game.playSound(50, 0.3, 'sawtooth', 0.3);
                            this.game.updateHUD();
                            this.game.updateHealthBar();
                            
                            if (this.game.state.health <= 0) {
                                this.game.gameOver();
                            }
                        }
                        
                        return;
                    }
                } else if (this.isPreparingCharge) {
                    // Handle charge preparation
                    const currentTime = Date.now();
                    const elapsedTime = currentTime - this.chargeStartTime;
                    
                    // Check line of sight to player during preparation
                    const hasLineOfSight = !this.game.checkCollision(
                        new THREE.Vector3(
                            this.mesh.position.x + directionToPlayer.x * distanceToPlayer * 0.5,
                            this.mesh.position.y,
                            this.mesh.position.z + directionToPlayer.z * distanceToPlayer * 0.5
                        ),
                        true,
                        false, 
                        this.collisionRadius
                    );
                    
                    // Track how long line of sight has been blocked
                    if (!hasLineOfSight) {
                        this.lineOfSightBlockedTime += 1/60; // Assuming 60fps, add 1/60th of a second
                        
                        // If blocked for more than 1 second, cancel charge
                        if (this.lineOfSightBlockedTime >= 1.0) {
                            this.isPreparingCharge = false;
                            this.lineOfSightBlockedTime = 0;
                            this.bodyMaterial.color.setHex(this.originalBodyColor);
                            this.headMaterial.color.setHex(this.originalBodyColor);
                            return;
                        }
                    } else {
                        // Reset counter if line of sight is restored
                        this.lineOfSightBlockedTime = 0;
                    }
                    
                    if (elapsedTime >= this.chargeDuration) {
                        // Preparation complete, start charging
                        this.isPreparingCharge = false;
                        this.isCharging = true;
                        this.chargeDirection.copy(directionToPlayer);
                        // Set to full red color for both body and head
                        this.bodyMaterial.color.setHex(this.chargeBodyColor);
                        this.headMaterial.color.setHex(this.chargeBodyColor);
                    } else {
                        // Gradually turn red during preparation
                        const progress = elapsedTime / this.chargeDuration; // 0 to 1
                        const lerpedColor = new THREE.Color().lerpColors(
                            new THREE.Color(this.originalBodyColor),
                            new THREE.Color(this.chargeBodyColor),
                            progress
                        );
                        this.bodyMaterial.color.copy(lerpedColor);
                        this.headMaterial.color.copy(lerpedColor);
                        
                        // Face the player during preparation
                        moveDirection.copy(directionToPlayer);
                        speed = 0; // Don't move while preparing to charge
                    }
                } else if (isChasing) {
                    // Align with player
                    moveDirection.copy(directionToPlayer);
                    
                    // Check if player is in attack range
                    if (distanceToPlayer <= this.attackRange && !this.game.state.powerups.invincibility.active) {
                        // Auto attack when in range
                        const currentTime = Date.now();
                        if (currentTime - this.lastAttackTime >= this.attackCooldown) {
                            this.game.state.health -= this.meleeAttackDamage;
                            this.lastAttackTime = currentTime;
                            
                            // Apply knockback to player
                            const knockbackDirection = directionToPlayer.clone().normalize();
                            const knockbackForce = 3.0;
                            
                            if (!this.game.playerKnockback) {
                                this.game.playerKnockback = new THREE.Vector3();
                            }
                            
                            // Set knockback velocity
                            this.game.playerKnockback.x = knockbackDirection.x * knockbackForce;
                            this.game.playerKnockback.z = knockbackDirection.z * knockbackForce;
                            this.game.playerKnockbackTime = Date.now();
                            this.game.playerKnockbackDuration = 300; // Duration in ms
                            
                            // Visual feedback
                            document.body.style.backgroundColor = 'rgba(255,0,0,0.7)';
                            setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                            
                            const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                            if (screenBloodOverlay) {
                                screenBloodOverlay.style.opacity = '0.9';
                                setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                            }
                            
                            this.game.playSound(120, 0.15, 'square', 0.4);
                            this.game.playSound(60, 0.35, 'sawtooth', 0.4);
                            this.game.updateHUD();
                            this.game.updateHealthBar();
                            
                            if (this.game.state.health <= 0) {
                                this.game.gameOver();
                            }
                        }
                    }
                    // Charge only when player is at a distance greater than 6
                    else if (distanceToPlayer > 6) {
                        // Check if aligned for charge
                        const alignment = directionToPlayer.dot(this.mesh.getWorldDirection(new THREE.Vector3()));
                        if (alignment > 0.95) { // Almost perfectly aligned
                            // Add line of sight check before preparing to charge
                            const hasLineOfSight = !this.game.checkCollision(
                                new THREE.Vector3(
                                    this.mesh.position.x + directionToPlayer.x * distanceToPlayer * 0.5,
                                    this.mesh.position.y,
                                    this.mesh.position.z + directionToPlayer.z * distanceToPlayer * 0.5
                                ),
                                true,
                                false, 
                                this.collisionRadius
                            );
                            
                            if (hasLineOfSight) {
                                this.chargeAlignmentTime++;
                                if (this.chargeAlignmentTime >= 30) { // About 0.5 seconds at 60fps
                                    // Start preparing to charge
                                    this.isPreparingCharge = true;
                                    this.chargeStartTime = Date.now();
                                    this.chargeAlignmentTime = 0;
                                }
                            } else {
                                this.chargeAlignmentTime = 0;
                            }
                        } else {
                            this.chargeAlignmentTime = 0;
                        }
                    }
                } else {
                    // Patrol logic
                    if (!this.patrolDirection || this.patrolTimeRemaining <= 0) {
                        this.patrolDirection = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            0,
                            Math.random() * 2 - 1
                        ).normalize();
                        this.patrolTimeRemaining = 60;
                    }
                    moveDirection.copy(this.patrolDirection);
                    this.patrolTimeRemaining--;
                }
                
                // Movement and collision
                if (moveDirection.lengthSq() > 0) {
                    const currentPos = this.mesh.position.clone();
                    const moveAttempt = moveDirection.clone().multiplyScalar(speed);
                    
                    // Try X movement
                    const newPosX = currentPos.clone();
                    newPosX.x += moveAttempt.x;
                    if (!this.game.checkCollision(newPosX, true, false, this.collisionRadius)) {
                        this.mesh.position.x = newPosX.x;
                    }
                    
                    // Try Z movement
                    const newPosZ = currentPos.clone();
                    newPosZ.z += moveAttempt.z;
                    if (!this.game.checkCollision(newPosZ, true, false, this.collisionRadius)) {
                        this.mesh.position.z = newPosZ.z;
                    }
                }
                
                // Update orientation
                if (moveDirection.lengthSq() > 0) {
                    const facePos = this.mesh.position.clone().add(moveDirection);
                    this.mesh.lookAt(facePos);
                }
                
                // Animation
                this.animationTime += this.animationSpeed;
                const walkCycle = Math.sin(this.animationTime);
                const swingAmount = this.isCharging ? 0.4 : 0.2;
                
                // Animate limbs
                if (moveDirection.lengthSq() > 0) {
                    // Animate rhino legs in diagonal pairs (front-left with back-right, front-right with back-left)
                    this.parts.frontLeftLeg.position.z = this.parts.originalPositions.frontLeftLeg.z + walkCycle * swingAmount;
                    this.parts.backRightLeg.position.z = this.parts.originalPositions.backRightLeg.z + walkCycle * swingAmount;
                    this.parts.frontRightLeg.position.z = this.parts.originalPositions.frontRightLeg.z - walkCycle * swingAmount;
                    this.parts.backLeftLeg.position.z = this.parts.originalPositions.backLeftLeg.z - walkCycle * swingAmount;
                    

                    // Body bounce
                    const bounceHeight = this.isCharging ? 0.1 : 0.05;
                    const bounceOffset = Math.abs(Math.sin(this.animationTime * 2)) * bounceHeight;
                    this.parts.bodyGroup.position.y = this.parts.originalPositions.bodyGroup.y + bounceOffset;
                }
                
                // Animate head elements
                const headBob = this.isCharging ? 0.15 : 0.05;
                this.parts.headGroup.position.y = this.parts.originalPositions.headGroup.y + Math.abs(Math.sin(this.animationTime * 2)) * headBob;
                this.parts.leftEye.position.y = this.parts.originalPositions.leftEye.y + Math.abs(Math.sin(this.animationTime * 2)) * headBob;
                this.parts.rightEye.position.y = this.parts.originalPositions.rightEye.y + Math.abs(Math.sin(this.animationTime * 2)) * headBob;
                this.parts.mouthGroup.position.y = this.parts.originalPositions.mouthGroup.y + Math.abs(Math.sin(this.animationTime * 2)) * headBob;
            }

            checkHit(projectilePosition) {
                // Get relative position from monster to projectile
                const relativePos = new THREE.Vector3().subVectors(projectilePosition, this.mesh.position);
                
                // Transform relative position to account for monster's rotation
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(-this.mesh.rotation.y);
                relativePos.applyMatrix4(rotationMatrix);

                // Define hit regions with their bounds and damage multipliers
                const hitRegions = {
                    front: {
                        bounds: {
                            x: [-0.6, 0.6],
                            y: [0.0, 1.5],
                            z: [0.0, 1.5]
                        },
                        multiplier: 0.7 // Reduced damage from front
                    },
                    back: {
                        bounds: {
                            x: [-0.8, 0.8],
                            y: [0.0, 1.5],
                            z: [-1.5, -0.0]
                        },
                        multiplier: 1.5 // Increased damage from back
                    }
                };

                // Check each hit region
                for (const [region, data] of Object.entries(hitRegions)) {
                    if (this.isPointInBounds(relativePos, data.bounds)) {
                        return {
                            hit: true,
                            region: region,
                            multiplier: data.multiplier
                        };
                    }
                }

                return { hit: false };
            }

            isPointInBounds(point, bounds) {
                return point.x >= bounds.x[0] && point.x <= bounds.x[1] &&
                       point.y >= bounds.y[0] && point.y <= bounds.y[1] &&
                       point.z >= bounds.z[0] && point.z <= bounds.z[1];
            }
        }

l<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Doom-style Shooter</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
            background-color: black;
            transition: background-color 0.15s;
        }
        #game-container { 
            width: 100vw; 
            height: 100vh; 
            display: none;
        }
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #ff0000;
            font-size: 24px;
            text-shadow: 2px 2px 2px black;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: red;
        }

        /* Vertical line */
        #crosshair::before {
            left: 50%;
            top: 0;
            width: 2px;
            height: 20px;
            transform: translateX(-50%);
        }

        /* Horizontal line */
        #crosshair::after {
            top: 50%;
            left: 0;
            width: 20px;
            height: 2px;
            transform: translateY(-50%);
        }

        /* Gap in the center */
        #crosshair::before {
            background: linear-gradient(to bottom, 
                red 0%, 
                red 45%, 
                transparent 45%, 
                transparent 55%, 
                red 55%, 
                red 100%
            );
        }

        #crosshair::after {
            background: linear-gradient(to right, 
                red 0%, 
                red 45%, 
                transparent 45%, 
                transparent 55%, 
                red 55%, 
                red 100%
            );
        }
    /* Blood overlay for player damage */
    #screen-blood-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        background: radial-gradient(ellipse at center, transparent 50%, rgba(255,0,0,0.5) 100%);
        opacity: 0;
        transition: opacity 0.5s;
        z-index: 100;
        display: none;
    }
    #mode-selection {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        padding: 30px;
        border: 2px solid #ff0000;
        color: white;
        text-align: center;
        font-family: Arial, sans-serif;
        z-index: 1000;
    }
    .mode-button {
        display: block;
        width: 200px;
        padding: 15px;
        margin: 10px auto;
        background: #ff0000;
        color: white;
        border: none;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.3s;
    }
    .mode-button:hover {
        background: #cc0000;
    }
    </style>
</head>
<body>
    <div id="mode-selection">
        <h2>Select Game Mode</h2>
        <button class="mode-button" onclick="startGame('testing')">Testing Mode</button>
        <button class="mode-button" onclick="startGame('normal')">Normal Mode</button>
        <button class="mode-button" onclick="startGame('multiplayer')">Multiplayer Mode</button>
    </div>
    <div id="game-container">
        <div id="hud">
            Level: <span id="level">1</span> | 
            Enemies: <span id="enemies">5</span>
        </div>
        <div id="crosshair"></div>
    <div id="screen-blood-overlay"></div>
        <div id="pause-menu" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: rgba(0,0,0,0.8); padding: 20px; color: red; text-align: center; border: 2px solid red;">
            <h2>PAUSED</h2>
            <p>Press ESC to resume</p>
            <p>Current Level: <span id="pause-level">1</span></p>
            <p>Enemies Remaining: <span id="pause-enemies">5</span></p>
        </div>
        <canvas id="minimap" style="position: fixed; top: 20px; right: 20px;"></canvas>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <script>
        class Monster {
            constructor(game) {
                this.game = game;
                this.mesh = new THREE.Group();
                this.health = 100;
                this.speed = game.config.monsterSpeed;
                this.damage = game.config.monsterDamage;
                this.detectionRadius = 15;
                this.attackRange = 2.0;
                this.attackCooldown = 1000;
                this.lastAttackTime = 0;
                this.state = "patrolling";
                this.patrolTimeRemaining = 0;
                this.animationTime = Math.random() * Math.PI * 2;
                this.animationSpeed = 0.1;
                this.isGrounded = true;
                this.baseHeight = 0;
                this.collisionRadius = 0.2; // Default collision radius
            }

            createMesh() {
                // To be implemented by subclasses
                throw new Error("createMesh must be implemented by subclass");
            }

            update() {
                // To be implemented by subclasses
                throw new Error("update must be implemented by subclass");
            }

            takeDamage(damage) {
                this.health -= damage;
                return this.health <= 0;
            }

            findValidPosition() {
                let validPosition = false;
                let attempts = 0;
                const maxAttempts = 100;
                
                while (!validPosition && attempts < maxAttempts) {
                    attempts++;
                    
                    const gridX = Math.floor(Math.random() * (this.game.config.mazeSize - 2)) + 1;
                    const gridZ = Math.floor(Math.random() * (this.game.config.mazeSize - 2)) + 1;
                    
                    const x = (gridX - this.game.config.mazeSize/2) * this.game.config.cellSize;
                    const z = (gridZ - this.game.config.mazeSize/2) * this.game.config.cellSize;
                    
                    this.mesh.position.set(x, this.baseHeight, z);
                    
                    if (!this.game.checkCollision(this.mesh.position, true) && 
                        this.mesh.position.distanceTo(this.game.camera.position) > 10) {
                        validPosition = true;
                    }
                }
                
                if (!validPosition) {
                    console.warn("Could not find valid position for monster");
                    this.mesh.position.set(0, this.baseHeight, 0);
                }
            }
        }

        class ChargerMonster extends Monster {
            constructor(game) {
                super(game);
                this.baseHeight = 0;
                this.health = 200;
                this.speed = game.config.monsterSpeed * 0.7;
                this.chargeSpeed = game.config.monsterSpeed * 10;
                this.damage = game.config.monsterDamage * 2;
                this.detectionRadius = 20;
                this.attackRange = 2;
                this.isCharging = false;
                this.isPreparingCharge = false;
                this.isStunned = false;
                this.chargeDirection = new THREE.Vector3();
                this.chargeAlignmentTime = 0;
                this.chargeStartTime = 0;
                this.chargeDuration = 2000; // 2 seconds preparation
                this.stunEndTime = 0;
                this.originalBodyColor = 0x403030; // Store original color
                this.chargeBodyColor = 0xff0000; // Red color for charging
                this.bodyMaterial = null; // Will store reference to body material
                this.headMaterial = null; // Will store reference to head material
                this.meleeAttackDamage = this.damage * 0.75; // 75% damage of charge
                this.collisionRadius = 0.9; // Based on large body size
                this.lineOfSightBlockedTime = 0; // Track how long sight has been blocked
                this.createMesh();
                this.findValidPosition();
            }

            createMesh() {
                const chargerGroup = new THREE.Group();
                
                // Rhino body colors - darker brown to match image
                const bodyColor = 0x403030; // Dark brownish for rhino skin
                const hornColor = 0x8a7a6d; // Bone-like color for horns/spikes
                
                // Body - larger and more organic shape using combined geometries
                const bodyGroup = new THREE.Group();
                
                // Main torso - use ellipsoid instead of box for more organic shape
                const torsoGeometry = new THREE.SphereGeometry(1.0, 13, 10);
                this.bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: this.originalBodyColor,
                    roughness: 0.9,
                    metalness: 0.2
                });
                const torso = new THREE.Mesh(torsoGeometry, this.bodyMaterial);
                torso.scale.set(1.0, 0.7, 1.2); // Flatten and elongate
                torso.position.y = 0.85;
                bodyGroup.add(torso);
                
                // Lower body/haunches - for better limb coverage
                const lowerBodyGeometry = new THREE.SphereGeometry(0.9, 9, 8);
                const lowerBody = new THREE.Mesh(lowerBodyGeometry, this.bodyMaterial);
                lowerBody.scale.set(1.0, 0.6, 1.0);
                lowerBody.position.set(0, 0.6, 0);
                bodyGroup.add(lowerBody);
                
                // Shoulder area - for better front limb coverage
                const shoulderGeometry = new THREE.SphereGeometry(0.8, 13, 10);
                const shoulder = new THREE.Mesh(shoulderGeometry, this.bodyMaterial);
                shoulder.scale.set(1.1, 0.7, 0.8);
                shoulder.position.set(0, 0.9, 0.6);
                bodyGroup.add(shoulder);
                
                // Head - replace box with organic shape
                const headGroup = new THREE.Group();
                
                // Base head shape - elongated sphere
                const baseHeadGeometry = new THREE.SphereGeometry(0.5, 8, 10);
                this.headMaterial = new THREE.MeshStandardMaterial({ 
                    color: bodyColor,
                    roughness: 0.9,
                    metalness: 0.2
                });
                const baseHead = new THREE.Mesh(baseHeadGeometry, this.headMaterial);
                baseHead.scale.set(0.9, 0.8, 1.2);
                baseHead.position.set(0, 0, 0.1);
                headGroup.add(baseHead);
                
                // Snout/muzzle - more pointed for rhino
                const snoutGeometry = new THREE.SphereGeometry(0.4, 9, 9);
                const snout = new THREE.Mesh(snoutGeometry, this.headMaterial);
                snout.scale.set(1.0, 0.75, 1.2);
                snout.position.set(0, -0.1, 0.4);
                headGroup.add(snout);
                
                // Slight bulge on top for more natural shape
                const headTopGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                const headTop = new THREE.Mesh(headTopGeometry, this.headMaterial);
                headTop.scale.set(1.1, 0.6, 0.8);
                headTop.position.set(0, 0.3, -0.1);
                headGroup.add(headTop);
                
                // Position the entire head group
                headGroup.position.set(0, 1.3, 0.9);
                
                // Add eyes
                const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff0000, // Red glowing eyes
                    emissive: 0xff0000,
                    emissiveIntensity: 0.5,
                    roughness: 0.3,
                    metalness: 0.7
                });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.25, 1.45, 1.5);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.25, 1.45, 1.5);
                
                // Replace flat mouth with curved mouth
                const mouthGroup = new THREE.Group();
                
                // Create a curved mouth using a partial torus
                const mouthGeometry = new THREE.TorusGeometry(0.15, 0.05, 8, 12, Math.PI);
                const mouthMaterial = new THREE.MeshStandardMaterial({
                    color: 0x1a0000, // Dark reddish black
                    roughness: 1.0,
                    metalness: 0.1
                });
                const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.rotation.x = Math.PI / 2; // Orient the torus
                mouth.rotation.y = Math.PI; // Turn it so open part faces down
                mouth.scale.set(1, 1, 0.5); // Flatten it a bit
                mouth.position.set(0, 1.15, 1.6);
                mouthGroup.add(mouth);
                
                // Add teeth - curved arrangement
                const teethGeometry = new THREE.BoxGeometry(0.04, 0.06, 0.04);
                const teethMaterial = new THREE.MeshStandardMaterial({
                    color: 0xf0f0f0, // Off-white
                    roughness: 0.5,
                    metalness: 0.2
                });
                
                const teeth = [];
                // Create teeth in a curved arrangement
                const teethCount = 5;
                const teethArc = Math.PI * 0.6; // Arc for teeth placement
                
                for (let i = 0; i < teethCount; i++) {
                    const tooth = new THREE.Mesh(teethGeometry, teethMaterial);
                    
                    // Calculate position along curve
                    const angle = (i / (teethCount - 1)) * teethArc - (teethArc / 2);
                    const radius = 0.25; // Match the torus radius
                    
                    // Position tooth along curve
                    const x = Math.sin(angle) * radius;
                    const z = Math.cos(angle) * radius + 1.55; // Offset forward
                    const y = 1.13 - Math.abs(x) * 0.05; // Slight vertical curve
                    
                    tooth.position.set(x, y, z);
                    
                    // Rotate each tooth to face outward from the curve
                    tooth.rotation.y = -angle;
                    
                    tooth.userData.originalY = tooth.position.y;
                    teeth.push(tooth);
                    mouthGroup.add(tooth);
                }
                
                // Add sharper fangs at corners
                const fangGeometry = new THREE.ConeGeometry(0.04, 0.12, 8);
                
                const leftFang = new THREE.Mesh(fangGeometry, teethMaterial);
                leftFang.position.set(-0.23, 1.11, 1.65);
                leftFang.rotation.x = -Math.PI / 8;
                leftFang.rotation.z = -Math.PI / 10;
                leftFang.userData.originalY = leftFang.position.y;
                teeth.push(leftFang);
                mouthGroup.add(leftFang);
                
                const rightFang = new THREE.Mesh(fangGeometry, teethMaterial);
                rightFang.position.set(0.23, 1.11, 1.65);
                rightFang.rotation.x = -Math.PI / 8;
                rightFang.rotation.z = Math.PI / 10;
                rightFang.userData.originalY = rightFang.position.y;
                teeth.push(rightFang);
                mouthGroup.add(rightFang);
                
                // Main horn - large and intimidating
                const primaryHornGeometry = new THREE.ConeGeometry(0.18, 0.9, 8);
                const hornMaterial = new THREE.MeshStandardMaterial({
                    color: hornColor,
                    roughness: 0.5,
                    metalness: 0.4
                });
                const primaryHorn = new THREE.Mesh(primaryHornGeometry, hornMaterial);
                primaryHorn.rotation.x = Math.PI / 2; // Point forward correctly
                primaryHorn.position.set(0, 1.5, 1.7);
                
                // Secondary horn - smaller above the main horn
                const secondaryHornGeometry = new THREE.ConeGeometry(0.12, 0.5, 8);
                const secondaryHorn = new THREE.Mesh(secondaryHornGeometry, hornMaterial);
                secondaryHorn.rotation.x = Math.PI / 4; // Slightly angled
                secondaryHorn.position.set(0, 1.7, 1.7);
                
                // Legs - thick and stocky
                const createLeg = (isLeft, isFront) => {
                    const legGroup = new THREE.Group();
                    
                    // Thicker legs for rhino
                    const legGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.7, 8);
                    const leg = new THREE.Mesh(legGeometry, this.bodyMaterial);
                    leg.position.y = 0.35;
                    
                    // Foot
                    const footGeometry = new THREE.SphereGeometry(0.26, 8, 8);
                    const foot = new THREE.Mesh(footGeometry, new THREE.MeshStandardMaterial({
                        color: 0x2a1f1f, // Darker color for hooves
                        roughness: 0.9,
                        metalness: 0.3
                    }));
                    foot.scale.set(1, 0.4, 1);
                    foot.position.y = 0;
                    
                    legGroup.add(leg);
                    legGroup.add(foot);
                    
                    // Position the leg based on whether it's front or back, left or right
                    // Position legs more under the body for better appearance during animation
                    const xPos = isLeft ? -0.45 : 0.45;
                    const zPos = isFront ? 0.5 : -0.5;
                    legGroup.position.set(xPos, 0.25, zPos);
                    
                    return legGroup;
                };
                
                // Add all parts to the rhino mesh
                chargerGroup.add(bodyGroup);
                chargerGroup.add(headGroup);  // Use headGroup instead of head
                chargerGroup.add(leftEye);
                chargerGroup.add(rightEye);
                chargerGroup.add(mouthGroup);
                chargerGroup.add(primaryHorn);
                chargerGroup.add(secondaryHorn);
                
                // Create legs
                const frontLeftLeg = createLeg(true, true);
                const frontRightLeg = createLeg(false, true);
                const backLeftLeg = createLeg(true, false);
                const backRightLeg = createLeg(false, false);
                
                // Add legs
                chargerGroup.add(frontLeftLeg);
                chargerGroup.add(frontRightLeg);
                chargerGroup.add(backLeftLeg);
                chargerGroup.add(backRightLeg);
                
                // Add spikes
                const createSpike = (xPos, yPos, zPos, height, width, angle) => {
                    const spikeGeometry = new THREE.ConeGeometry(width, height, 8);
                    const spike = new THREE.Mesh(spikeGeometry, hornMaterial);
                    spike.rotation.x = angle;
                    spike.position.set(xPos, yPos, zPos);
                    return spike;
                };
                
                // Add multiple spikes along the back
                const spikes = [
                    createSpike(0, 1.7, 0.3, 0.7, 0.15, Math.PI / 6),
                    createSpike(0, 1.6, 0, 0.6, 0.14, 0),
                    createSpike(0, 1.5, -0.3, 0.8, 0.16, Math.PI / 12),
                    createSpike(0, 1.4, -0.6, 0.7, 0.15, Math.PI / 8),
                    // Side spikes
                    createSpike(0.4, 1.6, 0.1, 0.5, 0.12, -Math.PI / 3),
                    createSpike(-0.4, 1.6, 0.1, 0.5, 0.12, -Math.PI / 3),
                    createSpike(0.5, 1.5, -0.4, 0.6, 0.13, -Math.PI / 5),
                    createSpike(-0.5, 1.5, -0.4, 0.6, 0.13, -Math.PI / 5)
                ];
                spikes.forEach(spike => chargerGroup.add(spike));
                
                // Small tail
                const tailGeometry = new THREE.CylinderGeometry(0.08, 0.03, 0.5, 8);
                const tail = new THREE.Mesh(tailGeometry, this.bodyMaterial);
                tail.rotation.x = Math.PI / 3; // Angle up slightly
                tail.position.set(0, 0.9, -1.5);
                chargerGroup.add(tail);
                
                this.mesh = chargerGroup;
                
                // Store references for animation
                this.parts = {
                    bodyGroup, headGroup, leftEye, rightEye, mouthGroup, teeth, frontLeftLeg, frontRightLeg, backLeftLeg, backRightLeg,
                    originalPositions: {
                        bodyGroup: bodyGroup.position.clone(),
                        headGroup: headGroup.position.clone(),
                        leftEye: leftEye.position.clone(),
                        rightEye: rightEye.position.clone(),
                        mouthGroup: mouthGroup.position.clone(),
                        frontLeftLeg: frontLeftLeg.position.clone(),
                        frontRightLeg: frontRightLeg.position.clone(),
                        backLeftLeg: backLeftLeg.position.clone(),
                        backRightLeg: backRightLeg.position.clone()
                    }
                };
            }

            update() {
                // Force ground level
                this.mesh.position.y = this.baseHeight;

                // Check if stunned
                if (this.isStunned) {
                    if (Date.now() >= this.stunEndTime) {
                        this.isStunned = false;
                        // Reset color when no longer stunned
                        this.bodyMaterial.color.setHex(this.originalBodyColor);
                        this.headMaterial.color.setHex(this.originalBodyColor);
                    } else {
                        return; // Skip movement while stunned
                    }
                }

                // Direction to player
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, this.mesh.position)
                    .normalize();
                directionToPlayer.y = 0;

                const distanceToPlayer = this.mesh.position.distanceTo(this.game.camera.position);
                const isChasing = distanceToPlayer <= this.detectionRadius;
                this.state = isChasing ? "chasing" : "patrolling";
                
                let speed = this.speed;
                let moveDirection = new THREE.Vector3();
                
                if (this.isCharging) {
                    // Continue charge in the same direction
                    moveDirection.copy(this.chargeDirection);
                    speed = this.chargeSpeed;
                    
                    // Check if charge hit a wall
                    const moveVector = moveDirection.clone().multiplyScalar(speed);
                    const nextPos = this.mesh.position.clone().add(moveVector);
                    if (this.game.checkCollision(nextPos, true, false, this.collisionRadius)) {
                        this.isCharging = false;
                        this.isStunned = true;
                        this.stunEndTime = Date.now() + 2000; // 2 second stun
                        this.bodyMaterial.color.setHex(this.originalBodyColor); // Reset body color
                        this.headMaterial.color.setHex(this.originalBodyColor); // Reset head color
                        return;
                    }
                    
                    // Improved player hit detection - use a wider range while charging
                    const chargeAttackRange = this.attackRange * 1.2; // Much wider detection range while charging
                    
                    // Create a vector to the expected next position
                    const nextPosition = this.mesh.position.clone().add(moveDirection.clone().multiplyScalar(speed));
                    const nextDistanceToPlayer = nextPosition.distanceTo(this.game.camera.position);
                    
                    // Check if either current position or next position is close enough to player
                    if ((distanceToPlayer <= chargeAttackRange || nextDistanceToPlayer <= chargeAttackRange) && 
                        !this.game.state.powerups.invincibility.active) {
                        // Handle player damage and knockback
                        this.isCharging = false;
                        this.isStunned = false; // Don't stun charger when hitting player
                        this.bodyMaterial.color.setHex(this.originalBodyColor); // Reset body color
                        this.headMaterial.color.setHex(this.originalBodyColor); // Reset head color
                        
                        // Move charger to the point of impact with the player
                        // Calculate the exact impact point (slightly in front of the player)
                        const impactPoint = this.game.camera.position.clone();
                        impactPoint.y = this.mesh.position.y; // Keep the same height
                        
                        // Move slightly back from player to avoid clipping
                        const offsetFromPlayer = directionToPlayer.clone().multiplyScalar(-0.5);
                        impactPoint.add(offsetFromPlayer);
                        
                        // Only move if there's no collision
                        if (!this.game.checkCollision(impactPoint, true, false, this.collisionRadius)) {
                            this.mesh.position.copy(impactPoint);
                        }
                        
                        // Apply knockback to player - simplified and stronger
                        const knockbackDirection = directionToPlayer.clone().normalize();
                        const knockbackForce = 5.0; // Much stronger knockback
                        
                        // Instead of teleporting the player, create knockback velocity
                        // that will be applied gradually over time
                        if (!this.game.playerKnockback) {
                            this.game.playerKnockback = new THREE.Vector3();
                        }
                        
                        // Set knockback velocity
                        this.game.playerKnockback.x = knockbackDirection.x * knockbackForce;
                        this.game.playerKnockback.z = knockbackDirection.z * knockbackForce;
                        this.game.playerKnockbackTime = Date.now();
                        this.game.playerKnockbackDuration = 300; // Duration in ms
                        
                        // Apply damage
                        const currentTime = Date.now();
                        if (currentTime - this.lastAttackTime >= this.attackCooldown) {
                            this.game.state.health -= this.damage;
                            this.lastAttackTime = currentTime;
                            
                            // Visual feedback
                            document.body.style.backgroundColor = 'rgba(255,0,0,0.7)';
                            setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                            
                            const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                            if (screenBloodOverlay) {
                                screenBloodOverlay.style.opacity = '0.9';
                                setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                            }
                            
                            this.game.playSound(100, 0.1, 'square', 0.3);
                            this.game.playSound(50, 0.3, 'sawtooth', 0.3);
                            this.game.updateHUD();
                            this.game.updateHealthBar();
                            
                            if (this.game.state.health <= 0) {
                                this.game.gameOver();
                            }
                        }
                        
                        return;
                    }
                } else if (this.isPreparingCharge) {
                    // Handle charge preparation
                    const currentTime = Date.now();
                    const elapsedTime = currentTime - this.chargeStartTime;
                    
                    // Check line of sight to player during preparation
                    const hasLineOfSight = !this.game.checkCollision(
                        new THREE.Vector3(
                            this.mesh.position.x + directionToPlayer.x * distanceToPlayer * 0.5,
                            this.mesh.position.y,
                            this.mesh.position.z + directionToPlayer.z * distanceToPlayer * 0.5
                        ),
                        true,
                        false, 
                        this.collisionRadius
                    );
                    
                    // Track how long line of sight has been blocked
                    if (!hasLineOfSight) {
                        this.lineOfSightBlockedTime += 1/60; // Assuming 60fps, add 1/60th of a second
                        
                        // If blocked for more than 1 second, cancel charge
                        if (this.lineOfSightBlockedTime >= 1.0) {
                            this.isPreparingCharge = false;
                            this.lineOfSightBlockedTime = 0;
                            this.bodyMaterial.color.setHex(this.originalBodyColor);
                            this.headMaterial.color.setHex(this.originalBodyColor);
                            return;
                        }
                    } else {
                        // Reset counter if line of sight is restored
                        this.lineOfSightBlockedTime = 0;
                    }
                    
                    if (elapsedTime >= this.chargeDuration) {
                        // Preparation complete, start charging
                        this.isPreparingCharge = false;
                        this.isCharging = true;
                        this.chargeDirection.copy(directionToPlayer);
                        // Set to full red color for both body and head
                        this.bodyMaterial.color.setHex(this.chargeBodyColor);
                        this.headMaterial.color.setHex(this.chargeBodyColor);
                    } else {
                        // Gradually turn red during preparation
                        const progress = elapsedTime / this.chargeDuration; // 0 to 1
                        const lerpedColor = new THREE.Color().lerpColors(
                            new THREE.Color(this.originalBodyColor),
                            new THREE.Color(this.chargeBodyColor),
                            progress
                        );
                        this.bodyMaterial.color.copy(lerpedColor);
                        this.headMaterial.color.copy(lerpedColor);
                        
                        // Face the player during preparation
                        moveDirection.copy(directionToPlayer);
                        speed = 0; // Don't move while preparing to charge
                    }
                } else if (isChasing) {
                    // Align with player
                    moveDirection.copy(directionToPlayer);
                    
                    // Check if player is in attack range
                    if (distanceToPlayer <= this.attackRange && !this.game.state.powerups.invincibility.active) {
                        // Auto attack when in range
                        const currentTime = Date.now();
                        if (currentTime - this.lastAttackTime >= this.attackCooldown) {
                            this.game.state.health -= this.meleeAttackDamage;
                            this.lastAttackTime = currentTime;
                            
                            // Apply knockback to player
                            const knockbackDirection = directionToPlayer.clone().normalize();
                            const knockbackForce = 3.0;
                            
                            if (!this.game.playerKnockback) {
                                this.game.playerKnockback = new THREE.Vector3();
                            }
                            
                            // Set knockback velocity
                            this.game.playerKnockback.x = knockbackDirection.x * knockbackForce;
                            this.game.playerKnockback.z = knockbackDirection.z * knockbackForce;
                            this.game.playerKnockbackTime = Date.now();
                            this.game.playerKnockbackDuration = 300; // Duration in ms
                            
                            // Visual feedback
                            document.body.style.backgroundColor = 'rgba(255,0,0,0.7)';
                            setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                            
                            const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                            if (screenBloodOverlay) {
                                screenBloodOverlay.style.opacity = '0.9';
                                setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                            }
                            
                            this.game.playSound(120, 0.15, 'square', 0.4);
                            this.game.playSound(60, 0.35, 'sawtooth', 0.4);
                            this.game.updateHUD();
                            this.game.updateHealthBar();
                            
                            if (this.game.state.health <= 0) {
                                this.game.gameOver();
                            }
                        }
                    }
                    // Charge only when player is at a distance greater than 6
                    else if (distanceToPlayer > 6) {
                        // Check if aligned for charge
                        const alignment = directionToPlayer.dot(this.mesh.getWorldDirection(new THREE.Vector3()));
                        if (alignment > 0.95) { // Almost perfectly aligned
                            // Add line of sight check before preparing to charge
                            const hasLineOfSight = !this.game.checkCollision(
                                new THREE.Vector3(
                                    this.mesh.position.x + directionToPlayer.x * distanceToPlayer * 0.5,
                                    this.mesh.position.y,
                                    this.mesh.position.z + directionToPlayer.z * distanceToPlayer * 0.5
                                ),
                                true,
                                false, 
                                this.collisionRadius
                            );
                            
                            if (hasLineOfSight) {
                                this.chargeAlignmentTime++;
                                if (this.chargeAlignmentTime >= 30) { // About 0.5 seconds at 60fps
                                    // Start preparing to charge
                                    this.isPreparingCharge = true;
                                    this.chargeStartTime = Date.now();
                                    this.chargeAlignmentTime = 0;
                                }
                            } else {
                                this.chargeAlignmentTime = 0;
                            }
                        } else {
                            this.chargeAlignmentTime = 0;
                        }
                    }
                } else {
                    // Patrol logic
                    if (!this.patrolDirection || this.patrolTimeRemaining <= 0) {
                        this.patrolDirection = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            0,
                            Math.random() * 2 - 1
                        ).normalize();
                        this.patrolTimeRemaining = 60;
                    }
                    moveDirection.copy(this.patrolDirection);
                    this.patrolTimeRemaining--;
                }
                
                // Movement and collision
                if (moveDirection.lengthSq() > 0) {
                    const currentPos = this.mesh.position.clone();
                    const moveAttempt = moveDirection.clone().multiplyScalar(speed);
                    
                    // Try X movement
                    const newPosX = currentPos.clone();
                    newPosX.x += moveAttempt.x;
                    if (!this.game.checkCollision(newPosX, true, false, this.collisionRadius)) {
                        this.mesh.position.x = newPosX.x;
                    }
                    
                    // Try Z movement
                    const newPosZ = currentPos.clone();
                    newPosZ.z += moveAttempt.z;
                    if (!this.game.checkCollision(newPosZ, true, false, this.collisionRadius)) {
                        this.mesh.position.z = newPosZ.z;
                    }
                }
                
                // Update orientation
                if (moveDirection.lengthSq() > 0) {
                    const facePos = this.mesh.position.clone().add(moveDirection);
                    this.mesh.lookAt(facePos);
                }
                
                // Animation
                this.animationTime += this.animationSpeed;
                const walkCycle = Math.sin(this.animationTime);
                const swingAmount = this.isCharging ? 0.4 : 0.2;
                
                // Animate limbs
                if (moveDirection.lengthSq() > 0) {
                    // Animate rhino legs in diagonal pairs (front-left with back-right, front-right with back-left)
                    this.parts.frontLeftLeg.position.z = this.parts.originalPositions.frontLeftLeg.z + walkCycle * swingAmount;
                    this.parts.backRightLeg.position.z = this.parts.originalPositions.backRightLeg.z + walkCycle * swingAmount;
                    this.parts.frontRightLeg.position.z = this.parts.originalPositions.frontRightLeg.z - walkCycle * swingAmount;
                    this.parts.backLeftLeg.position.z = this.parts.originalPositions.backLeftLeg.z - walkCycle * swingAmount;
                    

                    // Body bounce
                    const bounceHeight = this.isCharging ? 0.1 : 0.05;
                    const bounceOffset = Math.abs(Math.sin(this.animationTime * 2)) * bounceHeight;
                    this.parts.bodyGroup.position.y = this.parts.originalPositions.bodyGroup.y + bounceOffset;
                }
                
                // Animate head elements
                const headBob = this.isCharging ? 0.15 : 0.05;
                this.parts.headGroup.position.y = this.parts.originalPositions.headGroup.y + Math.abs(Math.sin(this.animationTime * 2)) * headBob;
                this.parts.leftEye.position.y = this.parts.originalPositions.leftEye.y + Math.abs(Math.sin(this.animationTime * 2)) * headBob;
                this.parts.rightEye.position.y = this.parts.originalPositions.rightEye.y + Math.abs(Math.sin(this.animationTime * 2)) * headBob;
                this.parts.mouthGroup.position.y = this.parts.originalPositions.mouthGroup.y + Math.abs(Math.sin(this.animationTime * 2)) * headBob;
            }

            checkHit(projectilePosition) {
                // Get relative position from monster to projectile
                const relativePos = new THREE.Vector3().subVectors(projectilePosition, this.mesh.position);
                
                // Transform relative position to account for monster's rotation
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(-this.mesh.rotation.y);
                relativePos.applyMatrix4(rotationMatrix);

                // Define hit regions with their bounds and damage multipliers
                const hitRegions = {
                    front: {
                        bounds: {
                            x: [-0.6, 0.6],
                            y: [0.0, 1.5],
                            z: [0.0, 1.5]
                        },
                        multiplier: 0.7 // Reduced damage from front
                    },
                    back: {
                        bounds: {
                            x: [-0.8, 0.8],
                            y: [0.0, 1.5],
                            z: [-1.5, -0.0]
                        },
                        multiplier: 1.5 // Increased damage from back
                    }
                };

                // Check each hit region
                for (const [region, data] of Object.entries(hitRegions)) {
                    if (this.isPointInBounds(relativePos, data.bounds)) {
                        return {
                            hit: true,
                            region: region,
                            multiplier: data.multiplier
                        };
                    }
                }

                return { hit: false };
            }

            isPointInBounds(point, bounds) {
                return point.x >= bounds.x[0] && point.x <= bounds.x[1] &&
                       point.y >= bounds.y[0] && point.y <= bounds.y[1] &&
                       point.z >= bounds.z[0] && point.z <= bounds.z[1];
            }
        }

        class GroundMonster extends Monster {
            constructor(game) {
                super(game);
                this.collisionRadius = 0.4; // Based on body size
                this.createMesh();
                this.findValidPosition();
            }

            createMesh() {
                // Create a zombie-like monster with decaying features
                
                // 1. Head - make it more zombie-like with pale skin and sunken features
                const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xc1d5c0, // Pale greenish skin
                    roughness: 0.9,
                    metalness: 0.1,
                    emissive: 0x003300,
                    emissiveIntensity: 0.2
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.8;
                
                // Add sunken glowing eyes
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff3300,
                    emissive: 0xff0000,
                    emissiveIntensity: 1
                });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.15, 0.05, 0.2);
                rightEye.position.set(0.15, 0.05, 0.2);
                leftEye.scale.y = 0.5; // Make eyes more sunken
                rightEye.scale.y = 0.5;
                head.add(leftEye);
                head.add(rightEye);
                
                // Add eye glow lights
                const leftLight = new THREE.PointLight(0xff0000, 1, 0.5);
                const rightLight = new THREE.PointLight(0xff0000, 1, 0.5);
                leftEye.add(leftLight);
                rightEye.add(rightLight);
                
                // Add decaying teeth
                const teethGeometry = new THREE.ConeGeometry(0.05, 0.15, 3); // More jagged teeth
                const teethMaterial = new THREE.MeshStandardMaterial({
                    color: 0xd6c48f, // Yellowed teeth
                    roughness: 0.8
                });
                
                for (let i = 0; i < 6; i++) {
                    const tooth = new THREE.Mesh(teethGeometry, teethMaterial);
                    tooth.position.set(
                        (i - 2.5) * 0.08,
                        -0.15,
                        0.2
                    );
                    tooth.rotation.x = 0.3 + Math.random() * 0.2; // Random rotation for broken look
                    tooth.rotation.z = Math.random() * 0.2 - 0.1;
                    head.add(tooth);
                }
                
                // 2. Torso - tattered and decaying
                const torsoGeometry = new THREE.BoxGeometry(0.6, 1.0, 0.6);
                const torsoMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x556677, // Dirty, tattered shirt
                    roughness: 1.0,
                    metalness: 0.0,
                    emissive: 0x000000,
                    emissiveIntensity: 0.1
                });
                const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
                torso.position.y = 1.1;
                
                // Add torn flesh effects
                const woundGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.1);
                const woundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x660000,
                    roughness: 0.7,
                    metalness: 0.3,
                    emissive: 0x330000,
                    emissiveIntensity: 0.2
                });
                
                for (let i = 0; i < 3; i++) {
                    const wound = new THREE.Mesh(woundGeometry, woundMaterial);
                    wound.position.set(
                        Math.random() * 0.4 - 0.2,
                        Math.random() * 0.8 - 0.4,
                        0.31
                    );
                    wound.rotation.z = Math.random() * Math.PI / 4;
                    torso.add(wound);
                }
                
                // 3. Arms - decaying with exposed bones
                const armGeometry = new THREE.CylinderGeometry(0.12, 0.08, 0.8, 8);
                const armMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xc1d5c0, // Matching skin tone
                    roughness: 0.9,
                    metalness: 0.1,
                    emissive: 0x003300,
                    emissiveIntensity: 0.2
                });
                
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                
                // Update arm positions and rotations for zombie pose
                // Position arms at shoulder height and move them forward
                leftArm.position.set(-0.2, 1.2, 0.3); // Moved forward (z positive)
                rightArm.position.set(0.2, 1.2, 0.3);
                
                // Rotate arms to point forward
                leftArm.rotation.x = -Math.PI / 2.5;  // Angle forward
                rightArm.rotation.x = -Math.PI / 2.5;

                
                // Store original rotations for animation
                leftArm.userData = { originalRotation: leftArm.rotation.clone() };
                rightArm.userData = { originalRotation: rightArm.rotation.clone() };
                
                // Add bone protrusions
                const boneGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.15, 4);
                const boneMaterial = new THREE.MeshStandardMaterial({
                    color: 0xf0f0e0,
                    roughness: 0.5,
                    metalness: 0.2
                });
                
                for (let arm of [leftArm, rightArm]) {
                    const bone = new THREE.Mesh(boneGeometry, boneMaterial);
                    bone.position.set(0, -0.2, 0.1);
                    bone.rotation.x = Math.PI / 6;
                    arm.add(bone);
                }
                
                // Add zombie claws - adjust claw positions for new arm orientation
                const clawGeometry = new THREE.ConeGeometry(0.05, 0.25, 4);
                const clawMaterial = new THREE.MeshStandardMaterial({
                    color: 0x222222,
                    metalness: 0.4,
                    roughness: 0.9
                });
                
                for (let arm of [leftArm, rightArm]) {
                    for (let i = 0; i < 3; i++) {
                        const claw = new THREE.Mesh(clawGeometry, clawMaterial);
                        claw.position.set(
                            (i - 1) * 0.06,
                            -0.4,
                            0
                        );
                        claw.rotation.x = Math.PI / 6; // Adjust claw angle for new arm position
                        arm.add(claw);
                    }
                }
                
                // 4. Legs - torn pants and decaying flesh
                const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 1.0, 8);
                const legMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333366, // Dark torn pants
                    roughness: 1.0,
                    metalness: 0.0
                });
                
                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                
                leftLeg.position.set(-0.15, 0.5, 0);
                rightLeg.position.set(0.15, 0.5, 0);
                
                // Add torn pants effect
                const tearGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.02);
                const tearMaterial = new THREE.MeshStandardMaterial({
                    color: 0xc1d5c0, // Exposed flesh
                    roughness: 0.9,
                    metalness: 0.1
                });
                
                for (let leg of [leftLeg, rightLeg]) {
                    for (let i = 0; i < 2; i++) {
                        const tear = new THREE.Mesh(tearGeometry, tearMaterial);
                        tear.position.set(
                            0,
                            Math.random() * 0.6 - 0.3,
                            0.11
                        );
                        tear.rotation.z = Math.random() * Math.PI / 4;
                        leg.add(tear);
                    }
                }
                
                // Add all parts to the monster mesh
                this.mesh.add(head);
                this.mesh.add(torso);
                this.mesh.add(leftArm);
                this.mesh.add(rightArm);
                this.mesh.add(leftLeg);
                this.mesh.add(rightLeg);
                
                // Store references for animation
                this.parts = {
                    head, torso, leftArm, rightArm, leftLeg, rightLeg,
                    originalPositions: {
                        head: head.position.clone(),
                        torso: torso.position.clone(),
                        leftArm: leftArm.position.clone(),
                        rightArm: rightArm.position.clone(),
                        leftLeg: leftLeg.position.clone(),
                        rightLeg: rightLeg.position.clone()
                    }
                };
            }

            update() {
                // Force ground level
                this.mesh.position.y = this.baseHeight;

                // Direction to player
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, this.mesh.position)
                    .normalize();
                directionToPlayer.y = 0;

                const distanceToPlayer = this.mesh.position.distanceTo(this.game.camera.position);
                const isChasing = distanceToPlayer <= this.detectionRadius;
                this.state = isChasing ? "chasing" : "patrolling";
                
                let speed = this.speed;
                let moveDirection = new THREE.Vector3();
                
                if (isChasing) {
                    speed *= 1.5;
                    moveDirection.copy(directionToPlayer);
                    
                    // Attack if close enough
                    if (distanceToPlayer <= this.attackRange && !this.game.state.powerups.invincibility.active) {
                        const currentTime = Date.now();
                        if (currentTime - this.lastAttackTime >= this.attackCooldown) {
                            // Apply melee damage
                            this.game.state.health -= this.damage;
                            this.lastAttackTime = currentTime;
                            
                            // Visual feedback
                            document.body.style.backgroundColor = 'rgba(255,0,0,0.7)';
                            setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                            
                            const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                            if (screenBloodOverlay) {
                                screenBloodOverlay.style.opacity = '0.9';
                                setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                            }
                            
                            this.game.playSound(100, 0.1, 'square', 0.3);
                            this.game.playSound(50, 0.3, 'sawtooth', 0.3);
                            this.game.updateHUD();
                            this.game.updateHealthBar();
                            
                            if (this.game.state.health <= 0) {
                                this.game.gameOver();
                            }
                        }
                    }
                } else {
                    // Patrol logic
                    if (!this.patrolDirection || this.patrolTimeRemaining <= 0) {
                        this.patrolDirection = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            0,
                            Math.random() * 2 - 1
                        ).normalize();
                        this.patrolTimeRemaining = 60;
                    }
                    moveDirection.copy(this.patrolDirection);
                    this.patrolTimeRemaining--;
                }
                
                // Movement and collision
                if (moveDirection.lengthSq() > 0) {
                    const currentPos = this.mesh.position.clone();
                    const moveAttempt = moveDirection.clone().multiplyScalar(speed);
                    
                    // Try X movement
                    const newPosX = currentPos.clone();
                    newPosX.x += moveAttempt.x;
                    if (!this.game.checkCollision(newPosX, true, false, this.collisionRadius)) {
                        this.mesh.position.x = newPosX.x;
                    }
                    
                    // Try Z movement
                    const newPosZ = currentPos.clone();
                    newPosZ.z += moveAttempt.z;
                    if (!this.game.checkCollision(newPosZ, true, false, this.collisionRadius)) {
                        this.mesh.position.z = newPosZ.z;
                    }
                }
                
                // Update orientation
                if (moveDirection.lengthSq() > 0) {
                    const facePos = this.mesh.position.clone().add(moveDirection);
                    this.mesh.lookAt(facePos);
                }
                
                // Animation
                this.animationTime += this.animationSpeed;
                const walkCycle = Math.sin(this.animationTime);
                const swingAmount = isChasing ? 0.3 : 0.2;
                
                // Animate limbs
                if (moveDirection.lengthSq() > 0) {
                    this.parts.leftArm.position.z = this.parts.originalPositions.leftArm.z + walkCycle * swingAmount;
                    this.parts.rightArm.position.z = this.parts.originalPositions.rightArm.z - walkCycle * swingAmount;
                    this.parts.leftLeg.position.z = this.parts.originalPositions.leftLeg.z - walkCycle * swingAmount;
                    this.parts.rightLeg.position.z = this.parts.originalPositions.rightLeg.z + walkCycle * swingAmount;
                    
                    const bounceHeight = isChasing ? 0.05 : 0.03;
                    const bounceOffset = Math.abs(Math.sin(this.animationTime * 2)) * bounceHeight;
                    this.parts.torso.position.y = this.parts.originalPositions.torso.y + bounceOffset;
                    this.parts.head.position.y = this.parts.originalPositions.head.y + bounceOffset;
                }
            }

            checkHit(projectilePosition) {
                // Get relative position from monster to projectile
                const relativePos = new THREE.Vector3().subVectors(projectilePosition, this.mesh.position);
                
                // Transform relative position to account for monster's rotation
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(-this.mesh.rotation.y);
                relativePos.applyMatrix4(rotationMatrix);

                // Define simplified hit regions with their bounds and damage multipliers
                // Made hit boxes more generous and added overlap between regions
                const hitRegions = {
                    head: {
                        bounds: {
                            x: [-0.5, 0.5],    // Wider head hitbox
                            y: [1.6, 2.2],     // Lower starting point for head
                            z: [-0.5, 0.5]     // Deeper head hitbox
                        },
                        multiplier: 2.0  // Headshots do double damage
                    },
                    body: {
                        bounds: {
                            x: [-0.5, 0.5],    // Wider body hitbox
                            y: [0, 1.6],       // Overlaps slightly with head
                            z: [-0.5, 0.5]     // Deeper body hitbox
                        },
                        multiplier: 1.0  // Normal damage for body shots
                    }
                };

                // Debug hit detection
                //console.log(`Hit check at relative position: (${relativePos.x.toFixed(2)}, ${relativePos.y.toFixed(2)}, ${relativePos.z.toFixed(2)})`);

                // Check each hit region
                for (const [region, data] of Object.entries(hitRegions)) {
                    if (this.isPointInBounds(relativePos, data.bounds)) {
                        //console.log(`Hit registered in ${region} region!`);
                        return {
                            hit: true,
                            region: region,
                            multiplier: data.multiplier
                        };
                    }
                }

                // If no hit registered, log the miss
                //console.log('No hit registered - projectile outside all hit regions');
                return { hit: false };
            }

            isPointInBounds(point, bounds) {
                const inBounds = point.x >= bounds.x[0] && point.x <= bounds.x[1] &&
                       point.y >= bounds.y[0] && point.y <= bounds.y[1] &&
                       point.z >= bounds.z[0] && point.z <= bounds.z[1];
                
                // Debug bounds check
                // if (!inBounds) {
                //     const failedAxis = [];
                //   if (point.x < bounds.x[0] || point.x > bounds.x[1]) failedAxis.push('X');
                //   if (point.y < bounds.y[0] || point.y > bounds.y[1]) failedAxis.push('Y');
                //  if (point.z < bounds.z[0] || point.z > bounds.z[1]) failedAxis.push('Z');
                //  console.log(`Bounds check failed on axes: ${failedAxis.join(', ')}`);
                //  }
                
                return inBounds;
            }
        }

        class FlyingMonster extends Monster {
            constructor(game) {
                super(game);
                this.baseHeight = 3.0;
                this.health = 70;
                this.speed = game.config.monsterSpeed * 1.2;
                this.verticalSpeed = 0.05;  // Removed testing mode check
                this.verticalRange = 1.0;
                this.verticalPosition = 0;
                this.wingAnimationEnabled = true;  // Removed testing mode check
                this.collisionRadius = 0.5; // Based on body and wing size
                this.createMesh();
                this.findValidPosition();
            }

            createMesh() {
                // Body
                const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: 0x000088,
                    emissive: 0x000033,
                    emissiveIntensity: 0.5,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.mesh.add(body);

                // Wings
                const wingGeometry = new THREE.BoxGeometry(2, 0.1, 0.8);
                const wingMaterial = new THREE.MeshStandardMaterial({
                    color: 0x0000aa,
                    emissive: 0x000066,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.8
                });
                
                const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                leftWing.position.set(-0.8, 0, 0);
                this.mesh.add(leftWing);
                
                const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                rightWing.position.set(0.8, 0, 0);
                this.mesh.add(rightWing);

                // Eyes
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.2, 0, 0.4);
                this.mesh.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.2, 0, 0.4);
                this.mesh.add(rightEye);

                // Add point light for glow effect
                const light = new THREE.PointLight(0x0000ff, 1, 2);
                this.mesh.add(light);

                // Store parts for animation
                this.parts = {
                    body,
                    leftWing,
                    rightWing,
                    originalPositions: {
                        leftWing: leftWing.position.clone(),
                        rightWing: rightWing.position.clone()
                    }
                };
            }

            update() {
                // Direction to player
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, this.mesh.position)
                    .normalize();
                directionToPlayer.y = 0;

                const distanceToPlayer = this.mesh.position.distanceTo(this.game.camera.position);
                const isChasing = distanceToPlayer <= this.detectionRadius;
                this.state = isChasing ? "chasing" : "patrolling";
                
                let speed = this.speed;
                let moveDirection = new THREE.Vector3();
                
                if (isChasing) {
                    speed *= 1.5;
                    moveDirection.copy(directionToPlayer);
                    moveDirection.y = 0; // Keep vertical movement separate
                } else {
                    if (!this.patrolDirection || this.patrolTimeRemaining <= 0) {
                        this.patrolDirection = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            0,
                            Math.random() * 2 - 1
                        ).normalize();
                        this.patrolTimeRemaining = 60;
                    }
                    moveDirection.copy(this.patrolDirection);
                    this.patrolTimeRemaining--;
                }
                
                // Movement and collision
                if (moveDirection.lengthSq() > 0) {
                    const currentPos = this.mesh.position.clone();
                    const moveAttempt = moveDirection.clone().multiplyScalar(speed);
                    
                    // Try X movement
                    const newPosX = currentPos.clone();
                    newPosX.x += moveAttempt.x;
                    if (!this.game.checkCollision(newPosX, true, false, this.collisionRadius)) {
                        this.mesh.position.x = newPosX.x;
                    }
                    
                    // Try Z movement
                    const newPosZ = currentPos.clone();
                    newPosZ.z += moveAttempt.z;
                    if (!this.game.checkCollision(newPosZ, true, false, this.collisionRadius)) {
                        this.mesh.position.z = newPosZ.z;
                    }
                }
                
                // Update orientation
                if (moveDirection.lengthSq() > 0) {
                    const facePos = this.mesh.position.clone().add(moveDirection);
                    this.mesh.lookAt(facePos);
                }
                
                // Only update vertical position and wing animation if not in testing mode

                // Vertical movement
                this.verticalPosition += this.verticalSpeed;
                if (Math.abs(this.verticalPosition) > this.verticalRange) {
                    this.verticalSpeed = -this.verticalSpeed;
                }
                this.mesh.position.y = this.baseHeight + this.verticalPosition;

                // Wing animation
                this.animationTime += this.animationSpeed * 2;
                const wingFlap = Math.sin(this.animationTime) * 0.5;
                // Find wing meshes by their position (they're positioned at x: 0.8)
                this.mesh.children.forEach(child => {
                    if (child.position.x < -0.5) {  // Left wing
                        child.rotation.z = wingFlap;
                    } else if (child.position.x > 0.5) {  // Right wing
                        child.rotation.z = -wingFlap;
                    }
                });
                
                
                // Attack logic
                if (distanceToPlayer < this.attackRange && !this.game.state.powerups.invincibility.active) {
                    const currentTime = Date.now();
                    if (currentTime - this.lastAttackTime >= this.attackCooldown) {
                        this.game.state.health -= this.damage;
                        this.lastAttackTime = currentTime;
                        
                        // Visual feedback
                        document.body.style.backgroundColor = 'rgba(0,0,255,0.7)';
                        setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                        
                        const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                        if (screenBloodOverlay) {
                            screenBloodOverlay.style.opacity = '0.9';
                            setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                        }
                        
                        this.game.playSound(200, 0.1, 'sine', 0.3);
                        this.game.updateHUD();
                        this.game.updateHealthBar();
                        
                        if (this.game.state.health <= 0) {
                            this.game.gameOver();
                        }
                    }
                }
            }

            checkHit(projectilePosition) {
                // Get relative position from monster to projectile
                const relativePos = new THREE.Vector3().subVectors(projectilePosition, this.mesh.position);
                
                // Transform relative position to account for monster's rotation
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(-this.mesh.rotation.y);
                relativePos.applyMatrix4(rotationMatrix);

                // Define hit regions with their bounds and damage multipliers
                const hitRegions = {
                    body: {
                        bounds: {
                            x: [-0.5, 0.5],
                            y: [-0.5, 0.5],
                            z: [-0.5, 0.5]
                        },
                        multiplier: 1.0  // Normal damage for body shots
                    },
                    wings: {
                        bounds: [
                            {  // Left wing
                                x: [-1.8, -0.5],
                                y: [-0.25, 0.25],
                                z: [-0.5, 0.5]
                            },
                            {  // Right wing
                                x: [0.5, 1.8],
                                y: [-0.25, 0.25],
                                z: [-0.5, 0.5]
                            }
                        ],
                        multiplier: 0.5  // Wings are more vulnerable
                    }
                };

                // Check each hit region
                for (const [region, data] of Object.entries(hitRegions)) {
                    if (Array.isArray(data.bounds)) {
                        // For regions with multiple parts (like wings)
                        for (const partBounds of data.bounds) {
                            if (this.isPointInBounds(relativePos, partBounds)) {
                                return {
                                    hit: true,
                                    region: region,
                                    multiplier: data.multiplier
                                };
                            }
                        }
                    } else {
                        // For single regions (like body)
                        if (this.isPointInBounds(relativePos, data.bounds)) {
                            return {
                                hit: true,
                                region: region,
                                multiplier: data.multiplier
                            };
                        }
                    }
                }

                return { hit: false };
            }

            isPointInBounds(point, bounds) {
                return point.x >= bounds.x[0] && point.x <= bounds.x[1] &&
                       point.y >= bounds.y[0] && point.y <= bounds.y[1] &&
                       point.z >= bounds.z[0] && point.z <= bounds.z[1];
            }
        }

        class ArcherMonster extends Monster {
            constructor(game) {
                super(game);
                this.baseHeight = 0;
                this.health = 70;
                this.speed = game.config.monsterSpeed * 0.8; // Slightly slower than ground monster
                this.damage = game.config.monsterDamage * 0.7; // Less damage for close combat
                this.detectionRadius = 20; // Longer detection range
                this.attackRange = 15.0; // Much longer attack range for arrows
                this.attackCooldown = 2000; // Longer cooldown for bow attacks
                this.arrowSpeed = 0.3;
                this.arrowDamage = game.config.monsterDamage * 1.2; // More damage for arrows
                this.collisionRadius = 0.4; // Based on body size
                this.createMesh();
                this.findValidPosition();
            }

            createMesh() {
                // Create a zombie-like archer with decaying features
                const archerGroup = new THREE.Group();
                
                // 1. Head - zombie-like with pale skin and sunken features
                const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xc1d5c0, // Pale greenish skin
                    roughness: 0.9,
                    metalness: 0.1,
                    emissive: 0x003300,
                    emissiveIntensity: 0.2
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.8;
                
                // Add sunken glowing eyes
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff3300,
                    emissive: 0xff0000,
                    emissiveIntensity: 1
                });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.15, 0.05, 0.2);
                rightEye.position.set(0.15, 0.05, 0.2);
                leftEye.scale.y = 0.5;
                rightEye.scale.y = 0.5;
                head.add(leftEye);
                head.add(rightEye);
                
                // Add eye glow
                const leftLight = new THREE.PointLight(0xff0000, 1, 0.5);
                const rightLight = new THREE.PointLight(0xff0000, 1, 0.5);
                leftEye.add(leftLight);
                rightEye.add(rightLight);
                
                // 2. Torso - tattered and decaying
                const torsoGeometry = new THREE.BoxGeometry(0.6, 1.0, 0.6);
                const torsoMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x556677,
                    roughness: 1.0,
                    metalness: 0.0
                });
                const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
                torso.position.y = 1.1;
                
                // Add torn flesh effects
                const woundGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.1);
                const woundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x660000,
                    roughness: 0.7,
                    metalness: 0.3,
                    emissive: 0x330000,
                    emissiveIntensity: 0.2
                });
                
                for (let i = 0; i < 3; i++) {
                    const wound = new THREE.Mesh(woundGeometry, woundMaterial);
                    wound.position.set(
                        Math.random() * 0.4 - 0.2,
                        Math.random() * 0.8 - 0.4,
                        0.31
                    );
                    wound.rotation.z = Math.random() * Math.PI / 4;
                    torso.add(wound);
                }
                
                // 3. Arms - decaying with exposed bones
                const armGeometry = new THREE.CylinderGeometry(0.12, 0.08, 0.8, 8);
                const armMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xc1d5c0,
                    roughness: 0.9,
                    metalness: 0.1
                });
                
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                
                // Position arms for bow holding pose
                leftArm.position.set(-0.4, 1.4, 0);
                rightArm.position.set(0.4, 1.4, 0);
                
                // Rotate arms for bow holding pose
                leftArm.rotation.z = Math.PI / 4;
                rightArm.rotation.z = -Math.PI / 4;
                
                // 4. Bow
                const bowGroup = new THREE.Group();
                
                // Main bow curve
                const bowGeometry = new THREE.TorusGeometry(0.5, 0.05, 8, 16, Math.PI);
                const bowMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    roughness: 0.7,
                    metalness: 0.3
                });
                const bow = new THREE.Mesh(bowGeometry, bowMaterial);
                
                // Bowstring
                const stringGeometry = new THREE.CylinderGeometry(0.01, 0.01, 1, 4);
                const stringMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc });
                const bowstring = new THREE.Mesh(stringGeometry, stringMaterial);
                
                bowGroup.add(bow);
                bowGroup.add(bowstring);
                bowGroup.position.set(0.4, 1.4, 0.3);
                bowGroup.rotation.y = Math.PI / 2;
                
                // 5. Legs
                const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 1.0, 8);
                const legMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333366
                });
                
                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                
                leftLeg.position.set(-0.2, 0.5, 0);
                rightLeg.position.set(0.2, 0.5, 0);
                
                // Add all parts to the archer mesh
                archerGroup.add(head);
                archerGroup.add(torso);
                archerGroup.add(leftArm);
                archerGroup.add(rightArm);
                archerGroup.add(leftLeg);
                archerGroup.add(rightLeg);
                archerGroup.add(bowGroup);
                
                this.mesh = archerGroup;
                
                // Store references for animation
                this.parts = {
                    head, torso, leftArm, rightArm, leftLeg, rightLeg, bow: bowGroup,
                    originalPositions: {
                        head: head.position.clone(),
                        torso: torso.position.clone(),
                        leftArm: leftArm.position.clone(),
                        rightArm: rightArm.position.clone(),
                        leftLeg: leftLeg.position.clone(),
                        rightLeg: rightLeg.position.clone(),
                        bow: bowGroup.position.clone()
                    }
                };
            }

            update() {
                // Force ground level and prevent falling
                this.mesh.position.y = this.baseHeight;

                // Direction to player
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, this.mesh.position)
                    .normalize();
                directionToPlayer.y = 0;

                const distanceToPlayer = this.mesh.position.distanceTo(this.game.camera.position);
                const isChasing = distanceToPlayer <= this.detectionRadius;
                this.state = isChasing ? "chasing" : "patrolling";
                
                let speed = this.speed;
                let moveDirection = new THREE.Vector3();
                
                if (isChasing) {
                    // Always face the player
                    const lookAtPos = new THREE.Vector3(
                        this.game.camera.position.x,
                        this.mesh.position.y,  // Keep y-level consistent
                        this.game.camera.position.z
                    );
                    this.mesh.lookAt(lookAtPos);
                    
                    // If too close to player, back away
                    const optimalRange = this.attackRange * 0.7; // Try to stay at 70% of max attack range
                    if (distanceToPlayer < optimalRange) {
                        // Move away from player
                        moveDirection.copy(directionToPlayer).negate();
                        speed *= 1.5; // Move away faster
                    } else if (distanceToPlayer > this.attackRange) {
                        // Move closer to player
                        moveDirection.copy(directionToPlayer);
                        speed *= 1.2;
                    } else {
                        // At good range, strafe sideways
                        const right = new THREE.Vector3().crossVectors(directionToPlayer, new THREE.Vector3(0, 1, 0));
                        moveDirection.copy(right).multiplyScalar(Math.sin(this.animationTime));
                        speed *= 0.8; // Slower when strafing
                    }
                    
                    // Check if we can shoot at the player
                    const currentTime = Date.now();
                    const canShoot = currentTime - this.lastAttackTime >= this.attackCooldown;
                    const inRange = distanceToPlayer <= this.attackRange;
                    const hasLineOfSight = !this.game.checkCollision(
                        new THREE.Vector3(
                            this.mesh.position.x + directionToPlayer.x * distanceToPlayer * 0.5,
                            this.mesh.position.y,
                            this.mesh.position.z + directionToPlayer.z * distanceToPlayer * 0.5
                        ),
                        false,
                        true
                    );

                    // Attack with bow if conditions are met
                    if (inRange && canShoot && hasLineOfSight && !this.game.state.powerups.invincibility.active) {
                        this.shootArrow();
                        this.lastAttackTime = currentTime;
                    }
                } else {
                    // Patrol logic
                    if (!this.patrolDirection || this.patrolTimeRemaining <= 0) {
                        this.patrolDirection = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            0,
                            Math.random() * 2 - 1
                        ).normalize();
                        this.patrolTimeRemaining = 60;
                    }
                    moveDirection.copy(this.patrolDirection);
                    this.patrolTimeRemaining--;
                    
                    // Update orientation for patrol
                    const facePos = this.mesh.position.clone().add(moveDirection);
                    facePos.y = this.mesh.position.y;  // Keep y-level consistent
                    this.mesh.lookAt(facePos);
                }
                
                // Movement and collision
                if (moveDirection.lengthSq() > 0) {
                    const currentPos = this.mesh.position.clone();
                    const moveAttempt = moveDirection.clone().multiplyScalar(speed);
                    
                    // Try X movement
                    const newPosX = currentPos.clone();
                    newPosX.x += moveAttempt.x;
                    if (!this.game.checkCollision(newPosX, true, false, this.collisionRadius)) {
                        this.mesh.position.x = newPosX.x;
                    }
                    
                    // Try Z movement
                    const newPosZ = currentPos.clone();
                    newPosZ.z += moveAttempt.z;
                    if (!this.game.checkCollision(newPosZ, true, false, this.collisionRadius)) {
                        this.mesh.position.z = newPosZ.z;
                    }
                }
                
                // Animation
                this.animationTime += this.animationSpeed;
                const walkCycle = Math.sin(this.animationTime);
                const swingAmount = isChasing ? 0.2 : 0.15;
                
                // Animate limbs
                if (moveDirection.lengthSq() > 0) {
                    this.parts.leftLeg.position.z = this.parts.originalPositions.leftLeg.z - walkCycle * swingAmount;
                    this.parts.rightLeg.position.z = this.parts.originalPositions.rightLeg.z + walkCycle * swingAmount;
                    
                    const bounceHeight = isChasing ? 0.03 : 0.02;
                    const bounceOffset = Math.abs(Math.sin(this.animationTime * 2)) * bounceHeight;
                    this.parts.torso.position.y = this.parts.originalPositions.torso.y + bounceOffset;
                    this.parts.head.position.y = this.parts.originalPositions.head.y + bounceOffset;
                }
            }

            shootArrow() {
                // Create arrow
                const arrowGroup = new THREE.Group();
                
                // Arrow shaft - made larger for visibility
                const shaftGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.6, 8);
                const shaftMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    metalness: 0.3,
                    roughness: 0.7,
                    emissive: 0x3a1707,
                    emissiveIntensity: 0.3
                });
                const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
                
                // Arrow head - made larger
                const headGeometry = new THREE.ConeGeometry(0.08, 0.2, 8);
                const headMaterial = new THREE.MeshStandardMaterial({
                    color: 0x666666,
                    metalness: 0.8,
                    roughness: 0.2,
                    emissive: 0x333333,
                    emissiveIntensity: 0.3
                });
                const arrowHead = new THREE.Mesh(headGeometry, headMaterial);
                arrowHead.position.y = 0.4;
                
                // Arrow fletching - made larger and more visible
                const fletchingGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.02);
                const fletchingMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff0000,
                    metalness: 0.1,
                    roughness: 0.9,
                    emissive: 0x660000,
                    emissiveIntensity: 0.5
                });
                
                const fletching1 = new THREE.Mesh(fletchingGeometry, fletchingMaterial);
                const fletching2 = new THREE.Mesh(fletchingGeometry, fletchingMaterial);
                fletching1.position.y = -0.25;
                fletching2.position.y = -0.25;
                fletching1.rotation.y = Math.PI / 4;
                fletching2.rotation.y = -Math.PI / 4;
                
                arrowGroup.add(shaft);
                arrowGroup.add(arrowHead);
                //arrowGroup.add(fletching1);
                //arrowGroup.add(fletching2);
                
                // Add a point light to make arrow more visible
                //const arrowLight = new THREE.PointLight(0xff6600, 0.5, 2);
                //arrowLight.position.set(0, 0, 0);
                //arrowGroup.add(arrowLight);
                
                // Position and orient arrow - adjusted spawn position
                arrowGroup.position.copy(this.mesh.position);
                arrowGroup.position.y += 1.4; // Shoot from bow height
                arrowGroup.position.z += this.mesh.rotation.y; // Offset based on archer's rotation
                
                // Calculate direction to player with slight randomness
                const spread = 0.1;
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, arrowGroup.position)
                    .normalize();
                
                // Add slight spread
                directionToPlayer.x += (Math.random() - 0.5) * spread;
                directionToPlayer.z += (Math.random() - 0.5) * spread;
                directionToPlayer.normalize();
                
                // Orient arrow
                arrowGroup.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), directionToPlayer);
                
                // Add arrow properties
                arrowGroup.userData = {
                    velocity: directionToPlayer.multiplyScalar(this.arrowSpeed),
                    damage: this.arrowDamage,
                    distance: 0,
                    maxDistance: 30,
                    isArrow: true,
                    isMonsterProjectile: true,  // Add this flag to identify monster projectiles
                    prevPosition: arrowGroup.position.clone(),
                    shooterId: this.mesh.uuid
                };
                
                // Add to game projectiles
                this.game.projectiles.push(arrowGroup);
                this.game.scene.add(arrowGroup);
                
                // Play sound effect
                this.game.playSound(440, 0.1, 'sine', 0.2);
            }

            checkHit(projectilePosition, projectile) {
                // Skip hit detection if the projectile was shot by this archer
                if (projectile && projectile.userData.shooterId === this.mesh.uuid) {
                    return { hit: false };
                }

                // Get relative position from monster to projectile
                const relativePos = new THREE.Vector3().subVectors(projectilePosition, this.mesh.position);
                
                // Transform relative position to account for monster's rotation
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(-this.mesh.rotation.y);
                relativePos.applyMatrix4(rotationMatrix);

                // Define hit regions with generous bounds
                const hitRegions = {
                    head: {
                        bounds: {
                            x: [-0.5, 0.5],    // Wide head hitbox
                            y: [1.6, 2.2],     // Head height range
                            z: [-0.5, 0.5]     // Deep head hitbox
                        },
                        multiplier: 2.0  // Headshots do double damage
                    },
                    body: {
                        bounds: {
                            x: [-0.5, 0.5],    // Wide body hitbox
                            y: [0, 1.6],       // Body height range
                            z: [-0.5, 0.5]     // Deep body hitbox
                        },
                        multiplier: 1.0  // Normal damage for body shots
                    },
                };

                // Check each hit region
                for (const [region, data] of Object.entries(hitRegions)) {
                    if (this.isPointInBounds(relativePos, data.bounds)) {
                        return {
                            hit: true,
                            region: region,
                            multiplier: data.multiplier
                        };
                    }
                }

                return { hit: false };
            }

            isPointInBounds(point, bounds) {
                return point.x >= bounds.x[0] && point.x <= bounds.x[1] &&
                       point.y >= bounds.y[0] && point.y <= bounds.y[1] &&
                       point.z >= bounds.z[0] && point.z <= bounds.z[1];
            }
        }

        class SpiderMonster extends Monster {
            constructor(game) {
                super(game);
                this.baseHeight = 0;
                this.health = 50;  // Low health
                this.speed = game.config.monsterSpeed * 2.0; // Twice as fast as normal monsters
                this.damage = game.config.monsterDamage * 0.5; // Half damage
                this.detectionRadius = 12;
                this.attackRange = 1.0;
                this.attackCooldown = 500; // Fast attacks
                this.jumpCooldown = 2000; // Time between jumps
                this.lastJumpTime = 0;
                this.jumpHeight = 2.0;
                this.jumpSpeed = 0.15;
                this.isJumping = false;
                this.jumpVelocity = 0;
                this.isOnWall = false;
                this.wallNormal = new THREE.Vector3();
                this.wallCrawlTime = 0;
                this.isAttacking = false;
                this.attackJumpTarget = null;
                this.collisionRadius = 0.4; // Based on body and legs
                this.createMesh();
                this.findValidPosition();
            }

            createMesh() {
                // Create spider body
                const bodyGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: 0x222222,
                    roughness: 0.7,
                    metalness: 0.3
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.2;

                // Create eyes (red and glowing)
                const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 1
                });

                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.08, 0.05, 0.15);
                rightEye.position.set(0.08, 0.05, 0.15);
                body.add(leftEye);
                body.add(rightEye);

                // Add eye glow
                const leftLight = new THREE.PointLight(0xff0000, 0.5, 0.5);
                const rightLight = new THREE.PointLight(0xff0000, 0.5, 0.5);
                leftEye.add(leftLight);
                rightEye.add(rightLight);

                // Create legs
                const legGeometry = new THREE.CylinderGeometry(0.02, 0.01, 0.3, 4);
                const legMaterial = new THREE.MeshStandardMaterial({
                    color: 0x111111,
                    roughness: 0.9,
                    metalness: 0.1
                });

                // Create 8 legs
                const legs = [];
                for (let i = 0; i < 8; i++) {
                    const leg = new THREE.Group();
                    
                    // Upper leg segment
                    const upperLeg = new THREE.Mesh(legGeometry, legMaterial);
                    upperLeg.position.y = -0.15;
                    
                    // Lower leg segment
                    const lowerLeg = new THREE.Mesh(legGeometry, legMaterial);
                    lowerLeg.position.y = -0.15;
                    
                    leg.add(upperLeg);
                    upperLeg.add(lowerLeg);
                    
                    // Position legs around body
                    const angle = (i * Math.PI / 4) + (Math.PI / 8);
                    leg.position.set(
                        Math.cos(angle) * 0.2,
                        0.2,
                        Math.sin(angle) * 0.2
                    );
                    
                    // Rotate legs outward
                    leg.rotation.z = -Math.PI / 4;
                    leg.rotation.y = angle;
                    
                    legs.push(leg);
                    this.mesh.add(leg);
                }

                this.mesh.add(body);
                
                // Store references for animation
                this.parts = {
                    body,
                    legs,
                    originalPositions: {
                        body: body.position.clone(),
                        legs: legs.map(leg => ({
                            position: leg.position.clone(),
                            rotation: leg.rotation.clone()
                        }))
                    }
                };
            }

            update() {
                // Direction to player
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, this.mesh.position)
                    .normalize();
                const distanceToPlayer = this.mesh.position.distanceTo(this.game.camera.position);
                const isChasing = distanceToPlayer <= this.detectionRadius;
                this.state = isChasing ? "chasing" : "patrolling";
                
                // Handle wall crawling
                if (!this.isJumping && !this.isAttacking) {
                    const nearestWallDir = this.game.findNearestWallDirection(this.mesh.position);
                    if (nearestWallDir) {
                        const wallDistance = nearestWallDir.length();
                        if (wallDistance < 0.5) {
                            this.isOnWall = true;
                            this.wallNormal = nearestWallDir.normalize();
                        } else {
                            this.isOnWall = false;
                        }
                    }
                }

                let speed = this.speed;
                let moveDirection = new THREE.Vector3();
                
                if (isChasing) {
                    speed *= 1.5;
                    
                    // Decide whether to attack jump
                    const currentTime = Date.now();
                    if (!this.isJumping && !this.isAttacking && 
                        currentTime - this.lastJumpTime >= this.jumpCooldown &&
                        distanceToPlayer <= this.detectionRadius && 
                        distanceToPlayer > this.attackRange) {
                        
                        // Higher chance to jump when closer to player
                        const jumpChance = Math.min(0.8, 1 - (distanceToPlayer / this.detectionRadius));
                        if (Math.random() < jumpChance) {
                            this.startAttackJump(this.game.camera.position.clone());
                        }
                    }

                    if (this.isAttacking) {
                        // Move towards attack target
                        if (this.attackJumpTarget) {
                            moveDirection.copy(this.attackJumpTarget)
                                .sub(this.mesh.position)
                                .normalize();
                            speed *= 2; // Faster during attack jump
                        }
                    } else if (!this.isJumping) {
                        moveDirection.copy(directionToPlayer);
                    }
                    
                    // Attack if close enough
                    if (distanceToPlayer <= this.attackRange && !this.game.state.powerups.invincibility.active) {
                        const currentTime = Date.now();
                        if (currentTime - this.lastAttackTime >= this.attackCooldown) {
                            this.game.state.health -= this.damage;
                            this.lastAttackTime = currentTime;
                            
                            // Visual feedback
                            document.body.style.backgroundColor = 'rgba(255,0,0,0.7)';
                            setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                            
                            const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                            if (screenBloodOverlay) {
                                screenBloodOverlay.style.opacity = '0.9';
                                setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                            }
                            
                            // Play bite sound
                            this.game.playSound(150, 0.1, 'square', 0.2);
                            this.game.updateHUD();
                            this.game.updateHealthBar();
                            
                            if (this.game.state.health <= 0) {
                                this.game.gameOver();
                            }
                        }
                    }
                } else {
                    // Patrol logic
                    if (!this.patrolDirection || this.patrolTimeRemaining <= 0) {
                        this.patrolDirection = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            0,
                            Math.random() * 2 - 1
                        ).normalize();
                        this.patrolTimeRemaining = 60;
                    }
                    moveDirection.copy(this.patrolDirection);
                    this.patrolTimeRemaining--;
                }
                
                // Apply wall crawling movement
                if (this.isOnWall && !this.isJumping && !this.isAttacking) {
                    this.wallCrawlTime += 0.1;
                    const wallOffset = Math.sin(this.wallCrawlTime) * 0.1;
                    this.mesh.position.y = 0.5 + wallOffset;
                    
                    // Rotate to face along wall
                    const wallTangent = new THREE.Vector3().crossVectors(this.wallNormal, new THREE.Vector3(0, 1, 0));
                    moveDirection.projectOnPlane(this.wallNormal);
                }

                // Movement and collision
                if (moveDirection.lengthSq() > 0) {
                    const currentPos = this.mesh.position.clone();
                    const moveAttempt = moveDirection.clone().multiplyScalar(speed);
                    
                    // Try X movement
                    const newPosX = currentPos.clone();
                    newPosX.x += moveAttempt.x;
                    if (!this.game.checkCollision(newPosX, true, false, this.collisionRadius)) {
                        this.mesh.position.x = newPosX.x;
                    }
                    
                    // Try Z movement
                    const newPosZ = currentPos.clone();
                    newPosZ.z += moveAttempt.z;
                    if (!this.game.checkCollision(newPosZ, true, false, this.collisionRadius)) {
                        this.mesh.position.z = newPosZ.z;
                    }
                }
                
                // Update orientation
                if (moveDirection.lengthSq() > 0) {
                    const facePos = this.mesh.position.clone().add(moveDirection);
                    this.mesh.lookAt(facePos);
                }
                
                // Handle jumping physics
                if (this.isJumping) {
                    this.jumpVelocity -= 0.015; // Gravity
                    this.mesh.position.y += this.jumpVelocity;
                    
                    // Check for landing
                    if (this.mesh.position.y <= this.baseHeight) {
                        this.mesh.position.y = this.baseHeight;
                        this.isJumping = false;
                        this.isAttacking = false;
                        this.jumpVelocity = 0;
                        this.attackJumpTarget = null;
                    }
                }
                
                // Animate legs
                this.animationTime += this.animationSpeed * 2;
                const walkCycle = Math.sin(this.animationTime);
                const legPhases = [0, Math.PI, Math.PI/2, Math.PI*1.5, 0, Math.PI, Math.PI/2, Math.PI*1.5];
                
                this.parts.legs.forEach((leg, index) => {
                    const phase = legPhases[index];
                    const lift = Math.sin(this.animationTime + phase) * 0.1;
                    leg.position.y = this.parts.originalPositions.legs[index].position.y + lift;
                    
                    leg.rotation.z = this.parts.originalPositions.legs[index].rotation.z + 
                                   (Math.sin(this.animationTime + phase) * 0.2);
                });
            }

            startAttackJump(targetPos) {
                if (!this.isJumping && !this.isAttacking) {
                    this.isJumping = true;
                    this.isAttacking = true;
                    this.jumpVelocity = this.jumpSpeed * 1.5;
                    this.lastJumpTime = Date.now();
                    this.attackJumpTarget = targetPos;
                    
                    // Play jump sound
                    this.game.playSound(200, 0.1, 'sine', 0.2);
                }
            }

            checkHit(projectilePosition) {
                // Get relative position from monster to projectile
                const relativePos = new THREE.Vector3().subVectors(projectilePosition, this.mesh.position);
                
                // Transform relative position to account for monster's rotation
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(-this.mesh.rotation.y);
                relativePos.applyMatrix4(rotationMatrix);

                // Define hit regions with their bounds and damage multipliers
                const hitRegions = {
                    body: {
                        bounds: {
                            x: [-0.5, 0.5],
                            y: [-0.5, 0.5],
                            z: [-0.5, 0.5]
                        },
                        multiplier: 1.0  // Critical hits due to small size
                    },
                };

                // Check each hit region
                for (const [region, data] of Object.entries(hitRegions)) {
                    if (this.isPointInBounds(relativePos, data.bounds)) {
                        return {
                            hit: true,
                            region: region,
                            multiplier: data.multiplier
                        };
                    }
                }

                return { hit: false };
            }

            isPointInBounds(point, bounds) {
                return point.x >= bounds.x[0] && point.x <= bounds.x[1] &&
                       point.y >= bounds.y[0] && point.y <= bounds.y[1] &&
                       point.z >= bounds.z[0] && point.z <= bounds.z[1];
            }
        }

l<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Doom-style Shooter</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
            background-color: black;
            transition: background-color 0.15s;
        }
        #game-container { 
            width: 100vw; 
            height: 100vh; 
            display: none;
        }
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #ff0000;
            font-size: 24px;
            text-shadow: 2px 2px 2px black;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: red;
        }

        /* Vertical line */
        #crosshair::before {
            left: 50%;
            top: 0;
            width: 2px;
            height: 20px;
            transform: translateX(-50%);
        }

        /* Horizontal line */
        #crosshair::after {
            top: 50%;
            left: 0;
            width: 20px;
            height: 2px;
            transform: translateY(-50%);
        }

        /* Gap in the center */
        #crosshair::before {
            background: linear-gradient(to bottom, 
                red 0%, 
                red 45%, 
                transparent 45%, 
                transparent 55%, 
                red 55%, 
                red 100%
            );
        }

        #crosshair::after {
            background: linear-gradient(to right, 
                red 0%, 
                red 45%, 
                transparent 45%, 
                transparent 55%, 
                red 55%, 
                red 100%
            );
        }
    /* Blood overlay for player damage */
    #screen-blood-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        background: radial-gradient(ellipse at center, transparent 50%, rgba(255,0,0,0.5) 100%);
        opacity: 0;
        transition: opacity 0.5s;
        z-index: 100;
        display: none;
    }
    #mode-selection {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        padding: 30px;
        border: 2px solid #ff0000;
        color: white;
        text-align: center;
        font-family: Arial, sans-serif;
        z-index: 1000;
    }
    .mode-button {
        display: block;
        width: 200px;
        padding: 15px;
        margin: 10px auto;
        background: #ff0000;
        color: white;
        border: none;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.3s;
    }
    .mode-button:hover {
        background: #cc0000;
    }
    </style>
</head>
<body>
    <div id="mode-selection">
        <h2>Select Game Mode</h2>
        <button class="mode-button" onclick="startGame('testing')">Testing Mode</button>
        <button class="mode-button" onclick="startGame('normal')">Normal Mode</button>
        <button class="mode-button" onclick="startGame('multiplayer')">Multiplayer Mode</button>
    </div>
    <div id="game-container">
        <div id="hud">
            Level: <span id="level">1</span> | 
            Enemies: <span id="enemies">5</span>
        </div>
        <div id="crosshair"></div>
    <div id="screen-blood-overlay"></div>
        <div id="pause-menu" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: rgba(0,0,0,0.8); padding: 20px; color: red; text-align: center; border: 2px solid red;">
            <h2>PAUSED</h2>
            <p>Press ESC to resume</p>
            <p>Current Level: <span id="pause-level">1</span></p>
            <p>Enemies Remaining: <span id="pause-enemies">5</span></p>
        </div>
        <canvas id="minimap" style="position: fixed; top: 20px; right: 20px;"></canvas>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <script>
        class Monster {
            constructor(game) {
                this.game = game;
                this.mesh = new THREE.Group();
                this.health = 100;
                this.speed = game.config.monsterSpeed;
                this.damage = game.config.monsterDamage;
                this.detectionRadius = 15;
                this.attackRange = 2.0;
                this.attackCooldown = 1000;
                this.lastAttackTime = 0;
                this.state = "patrolling";
                this.patrolTimeRemaining = 0;
                this.animationTime = Math.random() * Math.PI * 2;
                this.animationSpeed = 0.1;
                this.isGrounded = true;
                this.baseHeight = 0;
                this.collisionRadius = 0.2; // Default collision radius
            }

            createMesh() {
                // To be implemented by subclasses
                throw new Error("createMesh must be implemented by subclass");
            }

            update() {
                // To be implemented by subclasses
                throw new Error("update must be implemented by subclass");
            }

            takeDamage(damage) {
                this.health -= damage;
                return this.health <= 0;
            }

            findValidPosition() {
                let validPosition = false;
                let attempts = 0;
                const maxAttempts = 100;
                
                while (!validPosition && attempts < maxAttempts) {
                    attempts++;
                    
                    const gridX = Math.floor(Math.random() * (this.game.config.mazeSize - 2)) + 1;
                    const gridZ = Math.floor(Math.random() * (this.game.config.mazeSize - 2)) + 1;
                    
                    const x = (gridX - this.game.config.mazeSize/2) * this.game.config.cellSize;
                    const z = (gridZ - this.game.config.mazeSize/2) * this.game.config.cellSize;
                    
                    this.mesh.position.set(x, this.baseHeight, z);
                    
                    if (!this.game.checkCollision(this.mesh.position, true) && 
                        this.mesh.position.distanceTo(this.game.camera.position) > 10) {
                        validPosition = true;
                    }
                }
                
                if (!validPosition) {
                    console.warn("Could not find valid position for monster");
                    this.mesh.position.set(0, this.baseHeight, 0);
                }
            }
        }

        class ChargerMonster extends Monster {
            constructor(game) {
                super(game);
                this.baseHeight = 0;
                this.health = 200;
                this.speed = game.config.monsterSpeed * 0.7;
                this.chargeSpeed = game.config.monsterSpeed * 10;
                this.damage = game.config.monsterDamage * 2;
                this.detectionRadius = 20;
                this.attackRange = 2;
                this.isCharging = false;
                this.isPreparingCharge = false;
                this.isStunned = false;
                this.chargeDirection = new THREE.Vector3();
                this.chargeAlignmentTime = 0;
                this.chargeStartTime = 0;
                this.chargeDuration = 2000; // 2 seconds preparation
                this.stunEndTime = 0;
                this.originalBodyColor = 0x403030; // Store original color
                this.chargeBodyColor = 0xff0000; // Red color for charging
                this.bodyMaterial = null; // Will store reference to body material
                this.headMaterial = null; // Will store reference to head material
                this.meleeAttackDamage = this.damage * 0.75; // 75% damage of charge
                this.collisionRadius = 0.9; // Based on large body size
                this.lineOfSightBlockedTime = 0; // Track how long sight has been blocked
                this.createMesh();
                this.findValidPosition();
            }

            createMesh() {
                const chargerGroup = new THREE.Group();
                
                // Rhino body colors - darker brown to match image
                const bodyColor = 0x403030; // Dark brownish for rhino skin
                const hornColor = 0x8a7a6d; // Bone-like color for horns/spikes
                
                // Body - larger and more organic shape using combined geometries
                const bodyGroup = new THREE.Group();
                
                // Main torso - use ellipsoid instead of box for more organic shape
                const torsoGeometry = new THREE.SphereGeometry(1.0, 13, 10);
                this.bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: this.originalBodyColor,
                    roughness: 0.9,
                    metalness: 0.2
                });
                const torso = new THREE.Mesh(torsoGeometry, this.bodyMaterial);
                torso.scale.set(1.0, 0.7, 1.2); // Flatten and elongate
                torso.position.y = 0.85;
                bodyGroup.add(torso);
                
                // Lower body/haunches - for better limb coverage
                const lowerBodyGeometry = new THREE.SphereGeometry(0.9, 9, 8);
                const lowerBody = new THREE.Mesh(lowerBodyGeometry, this.bodyMaterial);
                lowerBody.scale.set(1.0, 0.6, 1.0);
                lowerBody.position.set(0, 0.6, 0);
                bodyGroup.add(lowerBody);
                
                // Shoulder area - for better front limb coverage
                const shoulderGeometry = new THREE.SphereGeometry(0.8, 13, 10);
                const shoulder = new THREE.Mesh(shoulderGeometry, this.bodyMaterial);
                shoulder.scale.set(1.1, 0.7, 0.8);
                shoulder.position.set(0, 0.9, 0.6);
                bodyGroup.add(shoulder);
                
                // Head - replace box with organic shape
                const headGroup = new THREE.Group();
                
                // Base head shape - elongated sphere
                const baseHeadGeometry = new THREE.SphereGeometry(0.5, 8, 10);
                this.headMaterial = new THREE.MeshStandardMaterial({ 
                    color: bodyColor,
                    roughness: 0.9,
                    metalness: 0.2
                });
                const baseHead = new THREE.Mesh(baseHeadGeometry, this.headMaterial);
                baseHead.scale.set(0.9, 0.8, 1.2);
                baseHead.position.set(0, 0, 0.1);
                headGroup.add(baseHead);
                
                // Snout/muzzle - more pointed for rhino
                const snoutGeometry = new THREE.SphereGeometry(0.4, 9, 9);
                const snout = new THREE.Mesh(snoutGeometry, this.headMaterial);
                snout.scale.set(1.0, 0.75, 1.2);
                snout.position.set(0, -0.1, 0.4);
                headGroup.add(snout);
                
                // Slight bulge on top for more natural shape
                const headTopGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                const headTop = new THREE.Mesh(headTopGeometry, this.headMaterial);
                headTop.scale.set(1.1, 0.6, 0.8);
                headTop.position.set(0, 0.3, -0.1);
                headGroup.add(headTop);
                
                // Position the entire head group
                headGroup.position.set(0, 1.3, 0.9);
                
                // Add eyes
                const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff0000, // Red glowing eyes
                    emissive: 0xff0000,
                    emissiveIntensity: 0.5,
                    roughness: 0.3,
                    metalness: 0.7
                });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.25, 1.45, 1.5);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.25, 1.45, 1.5);
                
                // Replace flat mouth with curved mouth
                const mouthGroup = new THREE.Group();
                
                // Create a curved mouth using a partial torus
                const mouthGeometry = new THREE.TorusGeometry(0.15, 0.05, 8, 12, Math.PI);
                const mouthMaterial = new THREE.MeshStandardMaterial({
                    color: 0x1a0000, // Dark reddish black
                    roughness: 1.0,
                    metalness: 0.1
                });
                const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.rotation.x = Math.PI / 2; // Orient the torus
                mouth.rotation.y = Math.PI; // Turn it so open part faces down
                mouth.scale.set(1, 1, 0.5); // Flatten it a bit
                mouth.position.set(0, 1.15, 1.6);
                mouthGroup.add(mouth);
                
                // Add teeth - curved arrangement
                const teethGeometry = new THREE.BoxGeometry(0.04, 0.06, 0.04);
                const teethMaterial = new THREE.MeshStandardMaterial({
                    color: 0xf0f0f0, // Off-white
                    roughness: 0.5,
                    metalness: 0.2
                });
                
                const teeth = [];
                // Create teeth in a curved arrangement
                const teethCount = 5;
                const teethArc = Math.PI * 0.6; // Arc for teeth placement
                
                for (let i = 0; i < teethCount; i++) {
                    const tooth = new THREE.Mesh(teethGeometry, teethMaterial);
                    
                    // Calculate position along curve
                    const angle = (i / (teethCount - 1)) * teethArc - (teethArc / 2);
                    const radius = 0.25; // Match the torus radius
                    
                    // Position tooth along curve
                    const x = Math.sin(angle) * radius;
                    const z = Math.cos(angle) * radius + 1.55; // Offset forward
                    const y = 1.13 - Math.abs(x) * 0.05; // Slight vertical curve
                    
                    tooth.position.set(x, y, z);
                    
                    // Rotate each tooth to face outward from the curve
                    tooth.rotation.y = -angle;
                    
                    tooth.userData.originalY = tooth.position.y;
                    teeth.push(tooth);
                    mouthGroup.add(tooth);
                }
                
                // Add sharper fangs at corners
                const fangGeometry = new THREE.ConeGeometry(0.04, 0.12, 8);
                
                const leftFang = new THREE.Mesh(fangGeometry, teethMaterial);
                leftFang.position.set(-0.23, 1.11, 1.65);
                leftFang.rotation.x = -Math.PI / 8;
                leftFang.rotation.z = -Math.PI / 10;
                leftFang.userData.originalY = leftFang.position.y;
                teeth.push(leftFang);
                mouthGroup.add(leftFang);
                
                const rightFang = new THREE.Mesh(fangGeometry, teethMaterial);
                rightFang.position.set(0.23, 1.11, 1.65);
                rightFang.rotation.x = -Math.PI / 8;
                rightFang.rotation.z = Math.PI / 10;
                rightFang.userData.originalY = rightFang.position.y;
                teeth.push(rightFang);
                mouthGroup.add(rightFang);
                
                // Main horn - large and intimidating
                const primaryHornGeometry = new THREE.ConeGeometry(0.18, 0.9, 8);
                const hornMaterial = new THREE.MeshStandardMaterial({
                    color: hornColor,
                    roughness: 0.5,
                    metalness: 0.4
                });
                const primaryHorn = new THREE.Mesh(primaryHornGeometry, hornMaterial);
                primaryHorn.rotation.x = Math.PI / 2; // Point forward correctly
                primaryHorn.position.set(0, 1.5, 1.7);
                
                // Secondary horn - smaller above the main horn
                const secondaryHornGeometry = new THREE.ConeGeometry(0.12, 0.5, 8);
                const secondaryHorn = new THREE.Mesh(secondaryHornGeometry, hornMaterial);
                secondaryHorn.rotation.x = Math.PI / 4; // Slightly angled
                secondaryHorn.position.set(0, 1.7, 1.7);
                
                // Legs - thick and stocky
                const createLeg = (isLeft, isFront) => {
                    const legGroup = new THREE.Group();
                    
                    // Thicker legs for rhino
                    const legGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.7, 8);
                    const leg = new THREE.Mesh(legGeometry, this.bodyMaterial);
                    leg.position.y = 0.35;
                    
                    // Foot
                    const footGeometry = new THREE.SphereGeometry(0.26, 8, 8);
                    const foot = new THREE.Mesh(footGeometry, new THREE.MeshStandardMaterial({
                        color: 0x2a1f1f, // Darker color for hooves
                        roughness: 0.9,
                        metalness: 0.3
                    }));
                    foot.scale.set(1, 0.4, 1);
                    foot.position.y = 0;
                    
                    legGroup.add(leg);
                    legGroup.add(foot);
                    
                    // Position the leg based on whether it's front or back, left or right
                    // Position legs more under the body for better appearance during animation
                    const xPos = isLeft ? -0.45 : 0.45;
                    const zPos = isFront ? 0.5 : -0.5;
                    legGroup.position.set(xPos, 0.25, zPos);
                    
                    return legGroup;
                };
                
                // Add all parts to the rhino mesh
                chargerGroup.add(bodyGroup);
                chargerGroup.add(headGroup);  // Use headGroup instead of head
                chargerGroup.add(leftEye);
                chargerGroup.add(rightEye);
                chargerGroup.add(mouthGroup);
                chargerGroup.add(primaryHorn);
                chargerGroup.add(secondaryHorn);
                
                // Create legs
                const frontLeftLeg = createLeg(true, true);
                const frontRightLeg = createLeg(false, true);
                const backLeftLeg = createLeg(true, false);
                const backRightLeg = createLeg(false, false);
                
                // Add legs
                chargerGroup.add(frontLeftLeg);
                chargerGroup.add(frontRightLeg);
                chargerGroup.add(backLeftLeg);
                chargerGroup.add(backRightLeg);
                
                // Add spikes
                const createSpike = (xPos, yPos, zPos, height, width, angle) => {
                    const spikeGeometry = new THREE.ConeGeometry(width, height, 8);
                    const spike = new THREE.Mesh(spikeGeometry, hornMaterial);
                    spike.rotation.x = angle;
                    spike.position.set(xPos, yPos, zPos);
                    return spike;
                };
                
                // Add multiple spikes along the back
                const spikes = [
                    createSpike(0, 1.7, 0.3, 0.7, 0.15, Math.PI / 6),
                    createSpike(0, 1.6, 0, 0.6, 0.14, 0),
                    createSpike(0, 1.5, -0.3, 0.8, 0.16, Math.PI / 12),
                    createSpike(0, 1.4, -0.6, 0.7, 0.15, Math.PI / 8),
                    // Side spikes
                    createSpike(0.4, 1.6, 0.1, 0.5, 0.12, -Math.PI / 3),
                    createSpike(-0.4, 1.6, 0.1, 0.5, 0.12, -Math.PI / 3),
                    createSpike(0.5, 1.5, -0.4, 0.6, 0.13, -Math.PI / 5),
                    createSpike(-0.5, 1.5, -0.4, 0.6, 0.13, -Math.PI / 5)
                ];
                spikes.forEach(spike => chargerGroup.add(spike));
                
                // Small tail
                const tailGeometry = new THREE.CylinderGeometry(0.08, 0.03, 0.5, 8);
                const tail = new THREE.Mesh(tailGeometry, this.bodyMaterial);
                tail.rotation.x = Math.PI / 3; // Angle up slightly
                tail.position.set(0, 0.9, -1.5);
                chargerGroup.add(tail);
                
                this.mesh = chargerGroup;
                
                // Store references for animation
                this.parts = {
                    bodyGroup, headGroup, leftEye, rightEye, mouthGroup, teeth, frontLeftLeg, frontRightLeg, backLeftLeg, backRightLeg,
                    originalPositions: {
                        bodyGroup: bodyGroup.position.clone(),
                        headGroup: headGroup.position.clone(),
                        leftEye: leftEye.position.clone(),
                        rightEye: rightEye.position.clone(),
                        mouthGroup: mouthGroup.position.clone(),
                        frontLeftLeg: frontLeftLeg.position.clone(),
                        frontRightLeg: frontRightLeg.position.clone(),
                        backLeftLeg: backLeftLeg.position.clone(),
                        backRightLeg: backRightLeg.position.clone()
                    }
                };
            }

            update() {
                // Force ground level
                this.mesh.position.y = this.baseHeight;

                // Check if stunned
                if (this.isStunned) {
                    if (Date.now() >= this.stunEndTime) {
                        this.isStunned = false;
                        // Reset color when no longer stunned
                        this.bodyMaterial.color.setHex(this.originalBodyColor);
                        this.headMaterial.color.setHex(this.originalBodyColor);
                    } else {
                        return; // Skip movement while stunned
                    }
                }

                // Direction to player
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, this.mesh.position)
                    .normalize();
                directionToPlayer.y = 0;

                const distanceToPlayer = this.mesh.position.distanceTo(this.game.camera.position);
                const isChasing = distanceToPlayer <= this.detectionRadius;
                this.state = isChasing ? "chasing" : "patrolling";
                
                let speed = this.speed;
                let moveDirection = new THREE.Vector3();
                
                if (this.isCharging) {
                    // Continue charge in the same direction
                    moveDirection.copy(this.chargeDirection);
                    speed = this.chargeSpeed;
                    
                    // Check if charge hit a wall
                    const moveVector = moveDirection.clone().multiplyScalar(speed);
                    const nextPos = this.mesh.position.clone().add(moveVector);
                    if (this.game.checkCollision(nextPos, true, false, this.collisionRadius)) {
                        this.isCharging = false;
                        this.isStunned = true;
                        this.stunEndTime = Date.now() + 2000; // 2 second stun
                        this.bodyMaterial.color.setHex(this.originalBodyColor); // Reset body color
                        this.headMaterial.color.setHex(this.originalBodyColor); // Reset head color
                        return;
                    }
                    
                    // Improved player hit detection - use a wider range while charging
                    const chargeAttackRange = this.attackRange * 1.2; // Much wider detection range while charging
                    
                    // Create a vector to the expected next position
                    const nextPosition = this.mesh.position.clone().add(moveDirection.clone().multiplyScalar(speed));
                    const nextDistanceToPlayer = nextPosition.distanceTo(this.game.camera.position);
                    
                    // Check if either current position or next position is close enough to player
                    if ((distanceToPlayer <= chargeAttackRange || nextDistanceToPlayer <= chargeAttackRange) && 
                        !this.game.state.powerups.invincibility.active) {
                        // Handle player damage and knockback
                        this.isCharging = false;
                        this.isStunned = false; // Don't stun charger when hitting player
                        this.bodyMaterial.color.setHex(this.originalBodyColor); // Reset body color
                        this.headMaterial.color.setHex(this.originalBodyColor); // Reset head color
                        
                        // Move charger to the point of impact with the player
                        // Calculate the exact impact point (slightly in front of the player)
                        const impactPoint = this.game.camera.position.clone();
                        impactPoint.y = this.mesh.position.y; // Keep the same height
                        
                        // Move slightly back from player to avoid clipping
                        const offsetFromPlayer = directionToPlayer.clone().multiplyScalar(-0.5);
                        impactPoint.add(offsetFromPlayer);
                        
                        // Only move if there's no collision
                        if (!this.game.checkCollision(impactPoint, true, false, this.collisionRadius)) {
                            this.mesh.position.copy(impactPoint);
                        }
                        
                        // Apply knockback to player - simplified and stronger
                        const knockbackDirection = directionToPlayer.clone().normalize();
                        const knockbackForce = 5.0; // Much stronger knockback
                        
                        // Instead of teleporting the player, create knockback velocity
                        // that will be applied gradually over time
                        if (!this.game.playerKnockback) {
                            this.game.playerKnockback = new THREE.Vector3();
                        }
                        
                        // Set knockback velocity
                        this.game.playerKnockback.x = knockbackDirection.x * knockbackForce;
                        this.game.playerKnockback.z = knockbackDirection.z * knockbackForce;
                        this.game.playerKnockbackTime = Date.now();
                        this.game.playerKnockbackDuration = 300; // Duration in ms
                        
                        // Apply damage
                        const currentTime = Date.now();
                        if (currentTime - this.lastAttackTime >= this.attackCooldown) {
                            this.game.state.health -= this.damage;
                            this.lastAttackTime = currentTime;
                            
                            // Visual feedback
                            document.body.style.backgroundColor = 'rgba(255,0,0,0.7)';
                            setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                            
                            const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                            if (screenBloodOverlay) {
                                screenBloodOverlay.style.opacity = '0.9';
                                setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                            }
                            
                            this.game.playSound(100, 0.1, 'square', 0.3);
                            this.game.playSound(50, 0.3, 'sawtooth', 0.3);
                            this.game.updateHUD();
                            this.game.updateHealthBar();
                            
                            if (this.game.state.health <= 0) {
                                this.game.gameOver();
                            }
                        }
                        
                        return;
                    }
                } else if (this.isPreparingCharge) {
                    // Handle charge preparation
                    const currentTime = Date.now();
                    const elapsedTime = currentTime - this.chargeStartTime;
                    
                    // Check line of sight to player during preparation
                    const hasLineOfSight = !this.game.checkCollision(
                        new THREE.Vector3(
                            this.mesh.position.x + directionToPlayer.x * distanceToPlayer * 0.5,
                            this.mesh.position.y,
                            this.mesh.position.z + directionToPlayer.z * distanceToPlayer * 0.5
                        ),
                        true,
                        false, 
                        this.collisionRadius
                    );
                    
                    // Track how long line of sight has been blocked
                    if (!hasLineOfSight) {
                        this.lineOfSightBlockedTime += 1/60; // Assuming 60fps, add 1/60th of a second
                        
                        // If blocked for more than 1 second, cancel charge
                        if (this.lineOfSightBlockedTime >= 1.0) {
                            this.isPreparingCharge = false;
                            this.lineOfSightBlockedTime = 0;
                            this.bodyMaterial.color.setHex(this.originalBodyColor);
                            this.headMaterial.color.setHex(this.originalBodyColor);
                            return;
                        }
                    } else {
                        // Reset counter if line of sight is restored
                        this.lineOfSightBlockedTime = 0;
                    }
                    
                    if (elapsedTime >= this.chargeDuration) {
                        // Preparation complete, start charging
                        this.isPreparingCharge = false;
                        this.isCharging = true;
                        this.chargeDirection.copy(directionToPlayer);
                        // Set to full red color for both body and head
                        this.bodyMaterial.color.setHex(this.chargeBodyColor);
                        this.headMaterial.color.setHex(this.chargeBodyColor);
                    } else {
                        // Gradually turn red during preparation
                        const progress = elapsedTime / this.chargeDuration; // 0 to 1
                        const lerpedColor = new THREE.Color().lerpColors(
                            new THREE.Color(this.originalBodyColor),
                            new THREE.Color(this.chargeBodyColor),
                            progress
                        );
                        this.bodyMaterial.color.copy(lerpedColor);
                        this.headMaterial.color.copy(lerpedColor);
                        
                        // Face the player during preparation
                        moveDirection.copy(directionToPlayer);
                        speed = 0; // Don't move while preparing to charge
                    }
                } else if (isChasing) {
                    // Align with player
                    moveDirection.copy(directionToPlayer);
                    
                    // Check if player is in attack range
                    if (distanceToPlayer <= this.attackRange && !this.game.state.powerups.invincibility.active) {
                        // Auto attack when in range
                        const currentTime = Date.now();
                        if (currentTime - this.lastAttackTime >= this.attackCooldown) {
                            this.game.state.health -= this.meleeAttackDamage;
                            this.lastAttackTime = currentTime;
                            
                            // Apply knockback to player
                            const knockbackDirection = directionToPlayer.clone().normalize();
                            const knockbackForce = 3.0;
                            
                            if (!this.game.playerKnockback) {
                                this.game.playerKnockback = new THREE.Vector3();
                            }
                            
                            // Set knockback velocity
                            this.game.playerKnockback.x = knockbackDirection.x * knockbackForce;
                            this.game.playerKnockback.z = knockbackDirection.z * knockbackForce;
                            this.game.playerKnockbackTime = Date.now();
                            this.game.playerKnockbackDuration = 300; // Duration in ms
                            
                            // Visual feedback
                            document.body.style.backgroundColor = 'rgba(255,0,0,0.7)';
                            setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                            
                            const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                            if (screenBloodOverlay) {
                                screenBloodOverlay.style.opacity = '0.9';
                                setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                            }
                            
                            this.game.playSound(120, 0.15, 'square', 0.4);
                            this.game.playSound(60, 0.35, 'sawtooth', 0.4);
                            this.game.updateHUD();
                            this.game.updateHealthBar();
                            
                            if (this.game.state.health <= 0) {
                                this.game.gameOver();
                            }
                        }
                    }
                    // Charge only when player is at a distance greater than 6
                    else if (distanceToPlayer > 6) {
                        // Check if aligned for charge
                        const alignment = directionToPlayer.dot(this.mesh.getWorldDirection(new THREE.Vector3()));
                        if (alignment > 0.95) { // Almost perfectly aligned
                            // Add line of sight check before preparing to charge
                            const hasLineOfSight = !this.game.checkCollision(
                                new THREE.Vector3(
                                    this.mesh.position.x + directionToPlayer.x * distanceToPlayer * 0.5,
                                    this.mesh.position.y,
                                    this.mesh.position.z + directionToPlayer.z * distanceToPlayer * 0.5
                                ),
                                true,
                                false, 
                                this.collisionRadius
                            );
                            
                            if (hasLineOfSight) {
                                this.chargeAlignmentTime++;
                                if (this.chargeAlignmentTime >= 30) { // About 0.5 seconds at 60fps
                                    // Start preparing to charge
                                    this.isPreparingCharge = true;
                                    this.chargeStartTime = Date.now();
                                    this.chargeAlignmentTime = 0;
                                }
                            } else {
                                this.chargeAlignmentTime = 0;
                            }
                        } else {
                            this.chargeAlignmentTime = 0;
                        }
                    }
                } else {
                    // Patrol logic
                    if (!this.patrolDirection || this.patrolTimeRemaining <= 0) {
                        this.patrolDirection = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            0,
                            Math.random() * 2 - 1
                        ).normalize();
                        this.patrolTimeRemaining = 60;
                    }
                    moveDirection.copy(this.patrolDirection);
                    this.patrolTimeRemaining--;
                }
                
                // Movement and collision
                if (moveDirection.lengthSq() > 0) {
                    const currentPos = this.mesh.position.clone();
                    const moveAttempt = moveDirection.clone().multiplyScalar(speed);
                    
                    // Try X movement
                    const newPosX = currentPos.clone();
                    newPosX.x += moveAttempt.x;
                    if (!this.game.checkCollision(newPosX, true, false, this.collisionRadius)) {
                        this.mesh.position.x = newPosX.x;
                    }
                    
                    // Try Z movement
                    const newPosZ = currentPos.clone();
                    newPosZ.z += moveAttempt.z;
                    if (!this.game.checkCollision(newPosZ, true, false, this.collisionRadius)) {
                        this.mesh.position.z = newPosZ.z;
                    }
                }
                
                // Update orientation
                if (moveDirection.lengthSq() > 0) {
                    const facePos = this.mesh.position.clone().add(moveDirection);
                    this.mesh.lookAt(facePos);
                }
                
                // Animation
                this.animationTime += this.animationSpeed;
                const walkCycle = Math.sin(this.animationTime);
                const swingAmount = this.isCharging ? 0.4 : 0.2;
                
                // Animate limbs
                if (moveDirection.lengthSq() > 0) {
                    // Animate rhino legs in diagonal pairs (front-left with back-right, front-right with back-left)
                    this.parts.frontLeftLeg.position.z = this.parts.originalPositions.frontLeftLeg.z + walkCycle * swingAmount;
                    this.parts.backRightLeg.position.z = this.parts.originalPositions.backRightLeg.z + walkCycle * swingAmount;
                    this.parts.frontRightLeg.position.z = this.parts.originalPositions.frontRightLeg.z - walkCycle * swingAmount;
                    this.parts.backLeftLeg.position.z = this.parts.originalPositions.backLeftLeg.z - walkCycle * swingAmount;
                    

                    // Body bounce
                    const bounceHeight = this.isCharging ? 0.1 : 0.05;
                    const bounceOffset = Math.abs(Math.sin(this.animationTime * 2)) * bounceHeight;
                    this.parts.bodyGroup.position.y = this.parts.originalPositions.bodyGroup.y + bounceOffset;
                }
                
                // Animate head elements
                const headBob = this.isCharging ? 0.15 : 0.05;
                this.parts.headGroup.position.y = this.parts.originalPositions.headGroup.y + Math.abs(Math.sin(this.animationTime * 2)) * headBob;
                this.parts.leftEye.position.y = this.parts.originalPositions.leftEye.y + Math.abs(Math.sin(this.animationTime * 2)) * headBob;
                this.parts.rightEye.position.y = this.parts.originalPositions.rightEye.y + Math.abs(Math.sin(this.animationTime * 2)) * headBob;
                this.parts.mouthGroup.position.y = this.parts.originalPositions.mouthGroup.y + Math.abs(Math.sin(this.animationTime * 2)) * headBob;
            }

            checkHit(projectilePosition) {
                // Get relative position from monster to projectile
                const relativePos = new THREE.Vector3().subVectors(projectilePosition, this.mesh.position);
                
                // Transform relative position to account for monster's rotation
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(-this.mesh.rotation.y);
                relativePos.applyMatrix4(rotationMatrix);

                // Define hit regions with their bounds and damage multipliers
                const hitRegions = {
                    front: {
                        bounds: {
                            x: [-0.6, 0.6],
                            y: [0.0, 1.5],
                            z: [0.0, 1.5]
                        },
                        multiplier: 0.7 // Reduced damage from front
                    },
                    back: {
                        bounds: {
                            x: [-0.8, 0.8],
                            y: [0.0, 1.5],
                            z: [-1.5, -0.0]
                        },
                        multiplier: 1.5 // Increased damage from back
                    }
                };

                // Check each hit region
                for (const [region, data] of Object.entries(hitRegions)) {
                    if (this.isPointInBounds(relativePos, data.bounds)) {
                        return {
                            hit: true,
                            region: region,
                            multiplier: data.multiplier
                        };
                    }
                }

                return { hit: false };
            }

            isPointInBounds(point, bounds) {
                return point.x >= bounds.x[0] && point.x <= bounds.x[1] &&
                       point.y >= bounds.y[0] && point.y <= bounds.y[1] &&
                       point.z >= bounds.z[0] && point.z <= bounds.z[1];
            }
        }

l<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Doom-style Shooter</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
            background-color: black;
            transition: background-color 0.15s;
        }
        #game-container { 
            width: 100vw; 
            height: 100vh; 
            display: none;
        }
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #ff0000;
            font-size: 24px;
            text-shadow: 2px 2px 2px black;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: red;
        }

        /* Vertical line */
        #crosshair::before {
            left: 50%;
            top: 0;
            width: 2px;
            height: 20px;
            transform: translateX(-50%);
        }

        /* Horizontal line */
        #crosshair::after {
            top: 50%;
            left: 0;
            width: 20px;
            height: 2px;
            transform: translateY(-50%);
        }

        /* Gap in the center */
        #crosshair::before {
            background: linear-gradient(to bottom, 
                red 0%, 
                red 45%, 
                transparent 45%, 
                transparent 55%, 
                red 55%, 
                red 100%
            );
        }

        #crosshair::after {
            background: linear-gradient(to right, 
                red 0%, 
                red 45%, 
                transparent 45%, 
                transparent 55%, 
                red 55%, 
                red 100%
            );
        }
    /* Blood overlay for player damage */
    #screen-blood-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        background: radial-gradient(ellipse at center, transparent 50%, rgba(255,0,0,0.5) 100%);
        opacity: 0;
        transition: opacity 0.5s;
        z-index: 100;
        display: none;
    }
    #mode-selection {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        padding: 30px;
        border: 2px solid #ff0000;
        color: white;
        text-align: center;
        font-family: Arial, sans-serif;
        z-index: 1000;
    }
    .mode-button {
        display: block;
        width: 200px;
        padding: 15px;
        margin: 10px auto;
        background: #ff0000;
        color: white;
        border: none;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.3s;
    }
    .mode-button:hover {
        background: #cc0000;
    }
    </style>
</head>
<body>
    <div id="mode-selection">
        <h2>Select Game Mode</h2>
        <button class="mode-button" onclick="startGame('testing')">Testing Mode</button>
        <button class="mode-button" onclick="startGame('normal')">Normal Mode</button>
        <button class="mode-button" onclick="startGame('multiplayer')">Multiplayer Mode</button>
    </div>
    <div id="game-container">
        <div id="hud">
            Level: <span id="level">1</span> | 
            Enemies: <span id="enemies">5</span>
        </div>
        <div id="crosshair"></div>
    <div id="screen-blood-overlay"></div>
        <div id="pause-menu" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: rgba(0,0,0,0.8); padding: 20px; color: red; text-align: center; border: 2px solid red;">
            <h2>PAUSED</h2>
            <p>Press ESC to resume</p>
            <p>Current Level: <span id="pause-level">1</span></p>
            <p>Enemies Remaining: <span id="pause-enemies">5</span></p>
        </div>
        <canvas id="minimap" style="position: fixed; top: 20px; right: 20px;"></canvas>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <script>
        class Monster {
            constructor(game) {
                this.game = game;
                this.mesh = new THREE.Group();
                this.health = 100;
                this.speed = game.config.monsterSpeed;
                this.damage = game.config.monsterDamage;
                this.detectionRadius = 15;
                this.attackRange = 2.0;
                this.attackCooldown = 1000;
                this.lastAttackTime = 0;
                this.state = "patrolling";
                this.patrolTimeRemaining = 0;
                this.animationTime = Math.random() * Math.PI * 2;
                this.animationSpeed = 0.1;
                this.isGrounded = true;
                this.baseHeight = 0;
                this.collisionRadius = 0.2; // Default collision radius
            }

            createMesh() {
                // To be implemented by subclasses
                throw new Error("createMesh must be implemented by subclass");
            }

            update() {
                // To be implemented by subclasses
                throw new Error("update must be implemented by subclass");
            }

            takeDamage(damage) {
                this.health -= damage;
                return this.health <= 0;
            }

            findValidPosition() {
                let validPosition = false;
                let attempts = 0;
                const maxAttempts = 100;
                
                while (!validPosition && attempts < maxAttempts) {
                    attempts++;
                    
                    const gridX = Math.floor(Math.random() * (this.game.config.mazeSize - 2)) + 1;
                    const gridZ = Math.floor(Math.random() * (this.game.config.mazeSize - 2)) + 1;
                    
                    const x = (gridX - this.game.config.mazeSize/2) * this.game.config.cellSize;
                    const z = (gridZ - this.game.config.mazeSize/2) * this.game.config.cellSize;
                    
                    this.mesh.position.set(x, this.baseHeight, z);
                    
                    if (!this.game.checkCollision(this.mesh.position, true) && 
                        this.mesh.position.distanceTo(this.game.camera.position) > 10) {
                        validPosition = true;
                    }
                }
                
                if (!validPosition) {
                    console.warn("Could not find valid position for monster");
                    this.mesh.position.set(0, this.baseHeight, 0);
                }
            }
        }

        class ChargerMonster extends Monster {
            constructor(game) {
                super(game);
                this.baseHeight = 0;
                this.health = 200;
                this.speed = game.config.monsterSpeed * 0.7;
                this.chargeSpeed = game.config.monsterSpeed * 10;
                this.damage = game.config.monsterDamage * 2;
                this.detectionRadius = 20;
                this.attackRange = 2;
                this.isCharging = false;
                this.isPreparingCharge = false;
                this.isStunned = false;
                this.chargeDirection = new THREE.Vector3();
                this.chargeAlignmentTime = 0;
                this.chargeStartTime = 0;
                this.chargeDuration = 2000; // 2 seconds preparation
                this.stunEndTime = 0;
                this.originalBodyColor = 0x403030; // Store original color
                this.chargeBodyColor = 0xff0000; // Red color for charging
                this.bodyMaterial = null; // Will store reference to body material
                this.headMaterial = null; // Will store reference to head material
                this.meleeAttackDamage = this.damage * 0.75; // 75% damage of charge
                this.collisionRadius = 0.9; // Based on large body size
                this.lineOfSightBlockedTime = 0; // Track how long sight has been blocked
                this.createMesh();
                this.findValidPosition();
            }

            createMesh() {
                const chargerGroup = new THREE.Group();
                
                // Rhino body colors - darker brown to match image
                const bodyColor = 0x403030; // Dark brownish for rhino skin
                const hornColor = 0x8a7a6d; // Bone-like color for horns/spikes
                
                // Body - larger and more organic shape using combined geometries
                const bodyGroup = new THREE.Group();
                
                // Main torso - use ellipsoid instead of box for more organic shape
                const torsoGeometry = new THREE.SphereGeometry(1.0, 13, 10);
                this.bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: this.originalBodyColor,
                    roughness: 0.9,
                    metalness: 0.2
                });
                const torso = new THREE.Mesh(torsoGeometry, this.bodyMaterial);
                torso.scale.set(1.0, 0.7, 1.2); // Flatten and elongate
                torso.position.y = 0.85;
                bodyGroup.add(torso);
                
                // Lower body/haunches - for better limb coverage
                const lowerBodyGeometry = new THREE.SphereGeometry(0.9, 9, 8);
                const lowerBody = new THREE.Mesh(lowerBodyGeometry, this.bodyMaterial);
                lowerBody.scale.set(1.0, 0.6, 1.0);
                lowerBody.position.set(0, 0.6, 0);
                bodyGroup.add(lowerBody);
                
                // Shoulder area - for better front limb coverage
                const shoulderGeometry = new THREE.SphereGeometry(0.8, 13, 10);
                const shoulder = new THREE.Mesh(shoulderGeometry, this.bodyMaterial);
                shoulder.scale.set(1.1, 0.7, 0.8);
                shoulder.position.set(0, 0.9, 0.6);
                bodyGroup.add(shoulder);
                
                // Head - replace box with organic shape
                const headGroup = new THREE.Group();
                
                // Base head shape - elongated sphere
                const baseHeadGeometry = new THREE.SphereGeometry(0.5, 8, 10);
                this.headMaterial = new THREE.MeshStandardMaterial({ 
                    color: bodyColor,
                    roughness: 0.9,
                    metalness: 0.2
                });
                const baseHead = new THREE.Mesh(baseHeadGeometry, this.headMaterial);
                baseHead.scale.set(0.9, 0.8, 1.2);
                baseHead.position.set(0, 0, 0.1);
                headGroup.add(baseHead);
                
                // Snout/muzzle - more pointed for rhino
                const snoutGeometry = new THREE.SphereGeometry(0.4, 9, 9);
                const snout = new THREE.Mesh(snoutGeometry, this.headMaterial);
                snout.scale.set(1.0, 0.75, 1.2);
                snout.position.set(0, -0.1, 0.4);
                headGroup.add(snout);
                
                // Slight bulge on top for more natural shape
                const headTopGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                const headTop = new THREE.Mesh(headTopGeometry, this.headMaterial);
                headTop.scale.set(1.1, 0.6, 0.8);
                headTop.position.set(0, 0.3, -0.1);
                headGroup.add(headTop);
                
                // Position the entire head group
                headGroup.position.set(0, 1.3, 0.9);
                
                // Add eyes
                const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff0000, // Red glowing eyes
                    emissive: 0xff0000,
                    emissiveIntensity: 0.5,
                    roughness: 0.3,
                    metalness: 0.7
                });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.25, 1.45, 1.5);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.25, 1.45, 1.5);
                
                // Replace flat mouth with curved mouth
                const mouthGroup = new THREE.Group();
                
                // Create a curved mouth using a partial torus
                const mouthGeometry = new THREE.TorusGeometry(0.15, 0.05, 8, 12, Math.PI);
                const mouthMaterial = new THREE.MeshStandardMaterial({
                    color: 0x1a0000, // Dark reddish black
                    roughness: 1.0,
                    metalness: 0.1
                });
                const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.rotation.x = Math.PI / 2; // Orient the torus
                mouth.rotation.y = Math.PI; // Turn it so open part faces down
                mouth.scale.set(1, 1, 0.5); // Flatten it a bit
                mouth.position.set(0, 1.15, 1.6);
                mouthGroup.add(mouth);
                
                // Add teeth - curved arrangement
                const teethGeometry = new THREE.BoxGeometry(0.04, 0.06, 0.04);
                const teethMaterial = new THREE.MeshStandardMaterial({
                    color: 0xf0f0f0, // Off-white
                    roughness: 0.5,
                    metalness: 0.2
                });
                
                const teeth = [];
                // Create teeth in a curved arrangement
                const teethCount = 5;
                const teethArc = Math.PI * 0.6; // Arc for teeth placement
                
                for (let i = 0; i < teethCount; i++) {
                    const tooth = new THREE.Mesh(teethGeometry, teethMaterial);
                    
                    // Calculate position along curve
                    const angle = (i / (teethCount - 1)) * teethArc - (teethArc / 2);
                    const radius = 0.25; // Match the torus radius
                    
                    // Position tooth along curve
                    const x = Math.sin(angle) * radius;
                    const z = Math.cos(angle) * radius + 1.55; // Offset forward
                    const y = 1.13 - Math.abs(x) * 0.05; // Slight vertical curve
                    
                    tooth.position.set(x, y, z);
                    
                    // Rotate each tooth to face outward from the curve
                    tooth.rotation.y = -angle;
                    
                    tooth.userData.originalY = tooth.position.y;
                    teeth.push(tooth);
                    mouthGroup.add(tooth);
                }
                
                // Add sharper fangs at corners
                const fangGeometry = new THREE.ConeGeometry(0.04, 0.12, 8);
                
                const leftFang = new THREE.Mesh(fangGeometry, teethMaterial);
                leftFang.position.set(-0.23, 1.11, 1.65);
                leftFang.rotation.x = -Math.PI / 8;
                leftFang.rotation.z = -Math.PI / 10;
                leftFang.userData.originalY = leftFang.position.y;
                teeth.push(leftFang);
                mouthGroup.add(leftFang);
                
                const rightFang = new THREE.Mesh(fangGeometry, teethMaterial);
                rightFang.position.set(0.23, 1.11, 1.65);
                rightFang.rotation.x = -Math.PI / 8;
                rightFang.rotation.z = Math.PI / 10;
                rightFang.userData.originalY = rightFang.position.y;
                teeth.push(rightFang);
                mouthGroup.add(rightFang);
                
                // Main horn - large and intimidating
                const primaryHornGeometry = new THREE.ConeGeometry(0.18, 0.9, 8);
                const hornMaterial = new THREE.MeshStandardMaterial({
                    color: hornColor,
                    roughness: 0.5,
                    metalness: 0.4
                });
                const primaryHorn = new THREE.Mesh(primaryHornGeometry, hornMaterial);
                primaryHorn.rotation.x = Math.PI / 2; // Point forward correctly
                primaryHorn.position.set(0, 1.5, 1.7);
                
                // Secondary horn - smaller above the main horn
                const secondaryHornGeometry = new THREE.ConeGeometry(0.12, 0.5, 8);
                const secondaryHorn = new THREE.Mesh(secondaryHornGeometry, hornMaterial);
                secondaryHorn.rotation.x = Math.PI / 4; // Slightly angled
                secondaryHorn.position.set(0, 1.7, 1.7);
                
                // Legs - thick and stocky
                const createLeg = (isLeft, isFront) => {
                    const legGroup = new THREE.Group();
                    
                    // Thicker legs for rhino
                    const legGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.7, 8);
                    const leg = new THREE.Mesh(legGeometry, this.bodyMaterial);
                    leg.position.y = 0.35;
                    
                    // Foot
                    const footGeometry = new THREE.SphereGeometry(0.26, 8, 8);
                    const foot = new THREE.Mesh(footGeometry, new THREE.MeshStandardMaterial({
                        color: 0x2a1f1f, // Darker color for hooves
                        roughness: 0.9,
                        metalness: 0.3
                    }));
                    foot.scale.set(1, 0.4, 1);
                    foot.position.y = 0;
                    
                    legGroup.add(leg);
                    legGroup.add(foot);
                    
                    // Position the leg based on whether it's front or back, left or right
                    // Position legs more under the body for better appearance during animation
                    const xPos = isLeft ? -0.45 : 0.45;
                    const zPos = isFront ? 0.5 : -0.5;
                    legGroup.position.set(xPos, 0.25, zPos);
                    
                    return legGroup;
                };
                
                // Add all parts to the rhino mesh
                chargerGroup.add(bodyGroup);
                chargerGroup.add(headGroup);  // Use headGroup instead of head
                chargerGroup.add(leftEye);
                chargerGroup.add(rightEye);
                chargerGroup.add(mouthGroup);
                chargerGroup.add(primaryHorn);
                chargerGroup.add(secondaryHorn);
                
                // Create legs
                const frontLeftLeg = createLeg(true, true);
                const frontRightLeg = createLeg(false, true);
                const backLeftLeg = createLeg(true, false);
                const backRightLeg = createLeg(false, false);
                
                // Add legs
                chargerGroup.add(frontLeftLeg);
                chargerGroup.add(frontRightLeg);
                chargerGroup.add(backLeftLeg);
                chargerGroup.add(backRightLeg);
                
                // Add spikes
                const createSpike = (xPos, yPos, zPos, height, width, angle) => {
                    const spikeGeometry = new THREE.ConeGeometry(width, height, 8);
                    const spike = new THREE.Mesh(spikeGeometry, hornMaterial);
                    spike.rotation.x = angle;
                    spike.position.set(xPos, yPos, zPos);
                    return spike;
                };
                
                // Add multiple spikes along the back
                const spikes = [
                    createSpike(0, 1.7, 0.3, 0.7, 0.15, Math.PI / 6),
                    createSpike(0, 1.6, 0, 0.6, 0.14, 0),
                    createSpike(0, 1.5, -0.3, 0.8, 0.16, Math.PI / 12),
                    createSpike(0, 1.4, -0.6, 0.7, 0.15, Math.PI / 8),
                    // Side spikes
                    createSpike(0.4, 1.6, 0.1, 0.5, 0.12, -Math.PI / 3),
                    createSpike(-0.4, 1.6, 0.1, 0.5, 0.12, -Math.PI / 3),
                    createSpike(0.5, 1.5, -0.4, 0.6, 0.13, -Math.PI / 5),
                    createSpike(-0.5, 1.5, -0.4, 0.6, 0.13, -Math.PI / 5)
                ];
                spikes.forEach(spike => chargerGroup.add(spike));
                
                // Small tail
                const tailGeometry = new THREE.CylinderGeometry(0.08, 0.03, 0.5, 8);
                const tail = new THREE.Mesh(tailGeometry, this.bodyMaterial);
                tail.rotation.x = Math.PI / 3; // Angle up slightly
                tail.position.set(0, 0.9, -1.5);
                chargerGroup.add(tail);
                
                this.mesh = chargerGroup;
                
                // Store references for animation
                this.parts = {
                    bodyGroup, headGroup, leftEye, rightEye, mouthGroup, teeth, frontLeftLeg, frontRightLeg, backLeftLeg, backRightLeg,
                    originalPositions: {
                        bodyGroup: bodyGroup.position.clone(),
                        headGroup: headGroup.position.clone(),
                        leftEye: leftEye.position.clone(),
                        rightEye: rightEye.position.clone(),
                        mouthGroup: mouthGroup.position.clone(),
                        frontLeftLeg: frontLeftLeg.position.clone(),
                        frontRightLeg: frontRightLeg.position.clone(),
                        backLeftLeg: backLeftLeg.position.clone(),
                        backRightLeg: backRightLeg.position.clone()
                    }
                };
            }

            update() {
                // Force ground level
                this.mesh.position.y = this.baseHeight;

                // Check if stunned
                if (this.isStunned) {
                    if (Date.now() >= this.stunEndTime) {
                        this.isStunned = false;
                        // Reset color when no longer stunned
                        this.bodyMaterial.color.setHex(this.originalBodyColor);
                        this.headMaterial.color.setHex(this.originalBodyColor);
                    } else {
                        return; // Skip movement while stunned
                    }
                }

                // Direction to player
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, this.mesh.position)
                    .normalize();
                directionToPlayer.y = 0;

                const distanceToPlayer = this.mesh.position.distanceTo(this.game.camera.position);
                const isChasing = distanceToPlayer <= this.detectionRadius;
                this.state = isChasing ? "chasing" : "patrolling";
                
                let speed = this.speed;
                let moveDirection = new THREE.Vector3();
                
                if (this.isCharging) {
                    // Continue charge in the same direction
                    moveDirection.copy(this.chargeDirection);
                    speed = this.chargeSpeed;
                    
                    // Check if charge hit a wall
                    const moveVector = moveDirection.clone().multiplyScalar(speed);
                    const nextPos = this.mesh.position.clone().add(moveVector);
                    if (this.game.checkCollision(nextPos, true, false, this.collisionRadius)) {
                        this.isCharging = false;
                        this.isStunned = true;
                        this.stunEndTime = Date.now() + 2000; // 2 second stun
                        this.bodyMaterial.color.setHex(this.originalBodyColor); // Reset body color
                        this.headMaterial.color.setHex(this.originalBodyColor); // Reset head color
                        return;
                    }
                    
                    // Improved player hit detection - use a wider range while charging
                    const chargeAttackRange = this.attackRange * 1.2; // Much wider detection range while charging
                    
                    // Create a vector to the expected next position
                    const nextPosition = this.mesh.position.clone().add(moveDirection.clone().multiplyScalar(speed));
                    const nextDistanceToPlayer = nextPosition.distanceTo(this.game.camera.position);
                    
                    // Check if either current position or next position is close enough to player
                    if ((distanceToPlayer <= chargeAttackRange || nextDistanceToPlayer <= chargeAttackRange) && 
                        !this.game.state.powerups.invincibility.active) {
                        // Handle player damage and knockback
                        this.isCharging = false;
                        this.isStunned = false; // Don't stun charger when hitting player
                        this.bodyMaterial.color.setHex(this.originalBodyColor); // Reset body color
                        this.headMaterial.color.setHex(this.originalBodyColor); // Reset head color
                        
                        // Move charger to the point of impact with the player
                        // Calculate the exact impact point (slightly in front of the player)
                        const impactPoint = this.game.camera.position.clone();
                        impactPoint.y = this.mesh.position.y; // Keep the same height
                        
                        // Move slightly back from player to avoid clipping
                        const offsetFromPlayer = directionToPlayer.clone().multiplyScalar(-0.5);
                        impactPoint.add(offsetFromPlayer);
                        
                        // Only move if there's no collision
                        if (!this.game.checkCollision(impactPoint, true, false, this.collisionRadius)) {
                            this.mesh.position.copy(impactPoint);
                        }
                        
                        // Apply knockback to player - simplified and stronger
                        const knockbackDirection = directionToPlayer.clone().normalize();
                        const knockbackForce = 5.0; // Much stronger knockback
                        
                        // Instead of teleporting the player, create knockback velocity
                        // that will be applied gradually over time
                        if (!this.game.playerKnockback) {
                            this.game.playerKnockback = new THREE.Vector3();
                        }
                        
                        // Set knockback velocity
                        this.game.playerKnockback.x = knockbackDirection.x * knockbackForce;
                        this.game.playerKnockback.z = knockbackDirection.z * knockbackForce;
                        this.game.playerKnockbackTime = Date.now();
                        this.game.playerKnockbackDuration = 300; // Duration in ms
                        
                        // Apply damage
                        const currentTime = Date.now();
                        if (currentTime - this.lastAttackTime >= this.attackCooldown) {
                            this.game.state.health -= this.damage;
                            this.lastAttackTime = currentTime;
                            
                            // Visual feedback
                            document.body.style.backgroundColor = 'rgba(255,0,0,0.7)';
                            setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                            
                            const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                            if (screenBloodOverlay) {
                                screenBloodOverlay.style.opacity = '0.9';
                                setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                            }
                            
                            this.game.playSound(100, 0.1, 'square', 0.3);
                            this.game.playSound(50, 0.3, 'sawtooth', 0.3);
                            this.game.updateHUD();
                            this.game.updateHealthBar();
                            
                            if (this.game.state.health <= 0) {
                                this.game.gameOver();
                            }
                        }
                        
                        return;
                    }
                } else if (this.isPreparingCharge) {
                    // Handle charge preparation
                    const currentTime = Date.now();
                    const elapsedTime = currentTime - this.chargeStartTime;
                    
                    // Check line of sight to player during preparation
                    const hasLineOfSight = !this.game.checkCollision(
                        new THREE.Vector3(
                            this.mesh.position.x + directionToPlayer.x * distanceToPlayer * 0.5,
                            this.mesh.position.y,
                            this.mesh.position.z + directionToPlayer.z * distanceToPlayer * 0.5
                        ),
                        true,
                        false, 
                        this.collisionRadius
                    );
                    
                    // Track how long line of sight has been blocked
                    if (!hasLineOfSight) {
                        this.lineOfSightBlockedTime += 1/60; // Assuming 60fps, add 1/60th of a second
                        
                        // If blocked for more than 1 second, cancel charge
                        if (this.lineOfSightBlockedTime >= 1.0) {
                            this.isPreparingCharge = false;
                            this.lineOfSightBlockedTime = 0;
                            this.bodyMaterial.color.setHex(this.originalBodyColor);
                            this.headMaterial.color.setHex(this.originalBodyColor);
                            return;
                        }
                    } else {
                        // Reset counter if line of sight is restored
                        this.lineOfSightBlockedTime = 0;
                    }
                    
                    if (elapsedTime >= this.chargeDuration) {
                        // Preparation complete, start charging
                        this.isPreparingCharge = false;
                        this.isCharging = true;
                        this.chargeDirection.copy(directionToPlayer);
                        // Set to full red color for both body and head
                        this.bodyMaterial.color.setHex(this.chargeBodyColor);
                        this.headMaterial.color.setHex(this.chargeBodyColor);
                    } else {
                        // Gradually turn red during preparation
                        const progress = elapsedTime / this.chargeDuration; // 0 to 1
                        const lerpedColor = new THREE.Color().lerpColors(
                            new THREE.Color(this.originalBodyColor),
                            new THREE.Color(this.chargeBodyColor),
                            progress
                        );
                        this.bodyMaterial.color.copy(lerpedColor);
                        this.headMaterial.color.copy(lerpedColor);
                        
                        // Face the player during preparation
                        moveDirection.copy(directionToPlayer);
                        speed = 0; // Don't move while preparing to charge
                    }
                } else if (isChasing) {
                    // Align with player
                    moveDirection.copy(directionToPlayer);
                    
                    // Check if player is in attack range
                    if (distanceToPlayer <= this.attackRange && !this.game.state.powerups.invincibility.active) {
                        // Auto attack when in range
                        const currentTime = Date.now();
                        if (currentTime - this.lastAttackTime >= this.attackCooldown) {
                            this.game.state.health -= this.meleeAttackDamage;
                            this.lastAttackTime = currentTime;
                            
                            // Apply knockback to player
                            const knockbackDirection = directionToPlayer.clone().normalize();
                            const knockbackForce = 3.0;
                            
                            if (!this.game.playerKnockback) {
                                this.game.playerKnockback = new THREE.Vector3();
                            }
                            
                            // Set knockback velocity
                            this.game.playerKnockback.x = knockbackDirection.x * knockbackForce;
                            this.game.playerKnockback.z = knockbackDirection.z * knockbackForce;
                            this.game.playerKnockbackTime = Date.now();
                            this.game.playerKnockbackDuration = 300; // Duration in ms
                            
                            // Visual feedback
                            document.body.style.backgroundColor = 'rgba(255,0,0,0.7)';
                            setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                            
                            const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                            if (screenBloodOverlay) {
                                screenBloodOverlay.style.opacity = '0.9';
                                setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                            }
                            
                            this.game.playSound(120, 0.15, 'square', 0.4);
                            this.game.playSound(60, 0.35, 'sawtooth', 0.4);
                            this.game.updateHUD();
                            this.game.updateHealthBar();
                            
                            if (this.game.state.health <= 0) {
                                this.game.gameOver();
                            }
                        }
                    }
                    // Charge only when player is at a distance greater than 6
                    else if (distanceToPlayer > 6) {
                        // Check if aligned for charge
                        const alignment = directionToPlayer.dot(this.mesh.getWorldDirection(new THREE.Vector3()));
                        if (alignment > 0.95) { // Almost perfectly aligned
                            // Add line of sight check before preparing to charge
                            const hasLineOfSight = !this.game.checkCollision(
                                new THREE.Vector3(
                                    this.mesh.position.x + directionToPlayer.x * distanceToPlayer * 0.5,
                                    this.mesh.position.y,
                                    this.mesh.position.z + directionToPlayer.z * distanceToPlayer * 0.5
                                ),
                                true,
                                false, 
                                this.collisionRadius
                            );
                            
                            if (hasLineOfSight) {
                                this.chargeAlignmentTime++;
                                if (this.chargeAlignmentTime >= 30) { // About 0.5 seconds at 60fps
                                    // Start preparing to charge
                                    this.isPreparingCharge = true;
                                    this.chargeStartTime = Date.now();
                                    this.chargeAlignmentTime = 0;
                                }
                            } else {
                                this.chargeAlignmentTime = 0;
                            }
                        } else {
                            this.chargeAlignmentTime = 0;
                        }
                    }
                } else {
                    // Patrol logic
                    if (!this.patrolDirection || this.patrolTimeRemaining <= 0) {
                        this.patrolDirection = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            0,
                            Math.random() * 2 - 1
                        ).normalize();
                        this.patrolTimeRemaining = 60;
                    }
                    moveDirection.copy(this.patrolDirection);
                    this.patrolTimeRemaining--;
                }
                
                // Movement and collision
                if (moveDirection.lengthSq() > 0) {
                    const currentPos = this.mesh.position.clone();
                    const moveAttempt = moveDirection.clone().multiplyScalar(speed);
                    
                    // Try X movement
                    const newPosX = currentPos.clone();
                    newPosX.x += moveAttempt.x;
                    if (!this.game.checkCollision(newPosX, true, false, this.collisionRadius)) {
                        this.mesh.position.x = newPosX.x;
                    }
                    
                    // Try Z movement
                    const newPosZ = currentPos.clone();
                    newPosZ.z += moveAttempt.z;
                    if (!this.game.checkCollision(newPosZ, true, false, this.collisionRadius)) {
                        this.mesh.position.z = newPosZ.z;
                    }
                }
                
                // Update orientation
                if (moveDirection.lengthSq() > 0) {
                    const facePos = this.mesh.position.clone().add(moveDirection);
                    this.mesh.lookAt(facePos);
                }
                
                // Animation
                this.animationTime += this.animationSpeed;
                const walkCycle = Math.sin(this.animationTime);
                const swingAmount = this.isCharging ? 0.4 : 0.2;
                
                // Animate limbs
                if (moveDirection.lengthSq() > 0) {
                    // Animate rhino legs in diagonal pairs (front-left with back-right, front-right with back-left)
                    this.parts.frontLeftLeg.position.z = this.parts.originalPositions.frontLeftLeg.z + walkCycle * swingAmount;
                    this.parts.backRightLeg.position.z = this.parts.originalPositions.backRightLeg.z + walkCycle * swingAmount;
                    this.parts.frontRightLeg.position.z = this.parts.originalPositions.frontRightLeg.z - walkCycle * swingAmount;
                    this.parts.backLeftLeg.position.z = this.parts.originalPositions.backLeftLeg.z - walkCycle * swingAmount;
                    

                    // Body bounce
                    const bounceHeight = this.isCharging ? 0.1 : 0.05;
                    const bounceOffset = Math.abs(Math.sin(this.animationTime * 2)) * bounceHeight;
                    this.parts.bodyGroup.position.y = this.parts.originalPositions.bodyGroup.y + bounceOffset;
                }
                
                // Animate head elements
                const headBob = this.isCharging ? 0.15 : 0.05;
                this.parts.headGroup.position.y = this.parts.originalPositions.headGroup.y + Math.abs(Math.sin(this.animationTime * 2)) * headBob;
                this.parts.leftEye.position.y = this.parts.originalPositions.leftEye.y + Math.abs(Math.sin(this.animationTime * 2)) * headBob;
                this.parts.rightEye.position.y = this.parts.originalPositions.rightEye.y + Math.abs(Math.sin(this.animationTime * 2)) * headBob;
                this.parts.mouthGroup.position.y = this.parts.originalPositions.mouthGroup.y + Math.abs(Math.sin(this.animationTime * 2)) * headBob;
            }

            checkHit(projectilePosition) {
                // Get relative position from monster to projectile
                const relativePos = new THREE.Vector3().subVectors(projectilePosition, this.mesh.position);
                
                // Transform relative position to account for monster's rotation
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(-this.mesh.rotation.y);
                relativePos.applyMatrix4(rotationMatrix);

                // Define hit regions with their bounds and damage multipliers
                const hitRegions = {
                    front: {
                        bounds: {
                            x: [-0.6, 0.6],
                            y: [0.0, 1.5],
                            z: [0.0, 1.5]
                        },
                        multiplier: 0.7 // Reduced damage from front
                    },
                    back: {
                        bounds: {
                            x: [-0.8, 0.8],
                            y: [0.0, 1.5],
                            z: [-1.5, -0.0]
                        },
                        multiplier: 1.5 // Increased damage from back
                    }
                };

                // Check each hit region
                for (const [region, data] of Object.entries(hitRegions)) {
                    if (this.isPointInBounds(relativePos, data.bounds)) {
                        return {
                            hit: true,
                            region: region,
                            multiplier: data.multiplier
                        };
                    }
                }

                return { hit: false };
            }

            isPointInBounds(point, bounds) {
                return point.x >= bounds.x[0] && point.x <= bounds.x[1] &&
                       point.y >= bounds.y[0] && point.y <= bounds.y[1] &&
                       point.z >= bounds.z[0] && point.z <= bounds.z[1];
            }
        }

        class GroundMonster extends Monster {
            constructor(game) {
                super(game);
                this.collisionRadius = 0.4; // Based on body size
                this.createMesh();
                this.findValidPosition();
            }

            createMesh() {
                // Create a zombie-like monster with decaying features
                
                // 1. Head - make it more zombie-like with pale skin and sunken features
                const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xc1d5c0, // Pale greenish skin
                    roughness: 0.9,
                    metalness: 0.1,
                    emissive: 0x003300,
                    emissiveIntensity: 0.2
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.8;
                
                // Add sunken glowing eyes
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff3300,
                    emissive: 0xff0000,
                    emissiveIntensity: 1
                });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.15, 0.05, 0.2);
                rightEye.position.set(0.15, 0.05, 0.2);
                leftEye.scale.y = 0.5; // Make eyes more sunken
                rightEye.scale.y = 0.5;
                head.add(leftEye);
                head.add(rightEye);
                
                // Add eye glow lights
                const leftLight = new THREE.PointLight(0xff0000, 1, 0.5);
                const rightLight = new THREE.PointLight(0xff0000, 1, 0.5);
                leftEye.add(leftLight);
                rightEye.add(rightLight);
                
                // Add decaying teeth
                const teethGeometry = new THREE.ConeGeometry(0.05, 0.15, 3); // More jagged teeth
                const teethMaterial = new THREE.MeshStandardMaterial({
                    color: 0xd6c48f, // Yellowed teeth
                    roughness: 0.8
                });
                
                for (let i = 0; i < 6; i++) {
                    const tooth = new THREE.Mesh(teethGeometry, teethMaterial);
                    tooth.position.set(
                        (i - 2.5) * 0.08,
                        -0.15,
                        0.2
                    );
                    tooth.rotation.x = 0.3 + Math.random() * 0.2; // Random rotation for broken look
                    tooth.rotation.z = Math.random() * 0.2 - 0.1;
                    head.add(tooth);
                }
                
                // 2. Torso - tattered and decaying
                const torsoGeometry = new THREE.BoxGeometry(0.6, 1.0, 0.6);
                const torsoMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x556677, // Dirty, tattered shirt
                    roughness: 1.0,
                    metalness: 0.0,
                    emissive: 0x000000,
                    emissiveIntensity: 0.1
                });
                const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
                torso.position.y = 1.1;
                
                // Add torn flesh effects
                const woundGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.1);
                const woundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x660000,
                    roughness: 0.7,
                    metalness: 0.3,
                    emissive: 0x330000,
                    emissiveIntensity: 0.2
                });
                
                for (let i = 0; i < 3; i++) {
                    const wound = new THREE.Mesh(woundGeometry, woundMaterial);
                    wound.position.set(
                        Math.random() * 0.4 - 0.2,
                        Math.random() * 0.8 - 0.4,
                        0.31
                    );
                    wound.rotation.z = Math.random() * Math.PI / 4;
                    torso.add(wound);
                }
                
                // 3. Arms - decaying with exposed bones
                const armGeometry = new THREE.CylinderGeometry(0.12, 0.08, 0.8, 8);
                const armMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xc1d5c0, // Matching skin tone
                    roughness: 0.9,
                    metalness: 0.1,
                    emissive: 0x003300,
                    emissiveIntensity: 0.2
                });
                
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                
                // Update arm positions and rotations for zombie pose
                // Position arms at shoulder height and move them forward
                leftArm.position.set(-0.2, 1.2, 0.3); // Moved forward (z positive)
                rightArm.position.set(0.2, 1.2, 0.3);
                
                // Rotate arms to point forward
                leftArm.rotation.x = -Math.PI / 2.5;  // Angle forward
                rightArm.rotation.x = -Math.PI / 2.5;

                
                // Store original rotations for animation
                leftArm.userData = { originalRotation: leftArm.rotation.clone() };
                rightArm.userData = { originalRotation: rightArm.rotation.clone() };
                
                // Add bone protrusions
                const boneGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.15, 4);
                const boneMaterial = new THREE.MeshStandardMaterial({
                    color: 0xf0f0e0,
                    roughness: 0.5,
                    metalness: 0.2
                });
                
                for (let arm of [leftArm, rightArm]) {
                    const bone = new THREE.Mesh(boneGeometry, boneMaterial);
                    bone.position.set(0, -0.2, 0.1);
                    bone.rotation.x = Math.PI / 6;
                    arm.add(bone);
                }
                
                // Add zombie claws - adjust claw positions for new arm orientation
                const clawGeometry = new THREE.ConeGeometry(0.05, 0.25, 4);
                const clawMaterial = new THREE.MeshStandardMaterial({
                    color: 0x222222,
                    metalness: 0.4,
                    roughness: 0.9
                });
                
                for (let arm of [leftArm, rightArm]) {
                    for (let i = 0; i < 3; i++) {
                        const claw = new THREE.Mesh(clawGeometry, clawMaterial);
                        claw.position.set(
                            (i - 1) * 0.06,
                            -0.4,
                            0
                        );
                        claw.rotation.x = Math.PI / 6; // Adjust claw angle for new arm position
                        arm.add(claw);
                    }
                }
                
                // 4. Legs - torn pants and decaying flesh
                const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 1.0, 8);
                const legMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333366, // Dark torn pants
                    roughness: 1.0,
                    metalness: 0.0
                });
                
                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                
                leftLeg.position.set(-0.15, 0.5, 0);
                rightLeg.position.set(0.15, 0.5, 0);
                
                // Add torn pants effect
                const tearGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.02);
                const tearMaterial = new THREE.MeshStandardMaterial({
                    color: 0xc1d5c0, // Exposed flesh
                    roughness: 0.9,
                    metalness: 0.1
                });
                
                for (let leg of [leftLeg, rightLeg]) {
                    for (let i = 0; i < 2; i++) {
                        const tear = new THREE.Mesh(tearGeometry, tearMaterial);
                        tear.position.set(
                            0,
                            Math.random() * 0.6 - 0.3,
                            0.11
                        );
                        tear.rotation.z = Math.random() * Math.PI / 4;
                        leg.add(tear);
                    }
                }
                
                // Add all parts to the monster mesh
                this.mesh.add(head);
                this.mesh.add(torso);
                this.mesh.add(leftArm);
                this.mesh.add(rightArm);
                this.mesh.add(leftLeg);
                this.mesh.add(rightLeg);
                
                // Store references for animation
                this.parts = {
                    head, torso, leftArm, rightArm, leftLeg, rightLeg,
                    originalPositions: {
                        head: head.position.clone(),
                        torso: torso.position.clone(),
                        leftArm: leftArm.position.clone(),
                        rightArm: rightArm.position.clone(),
                        leftLeg: leftLeg.position.clone(),
                        rightLeg: rightLeg.position.clone()
                    }
                };
            }

            update() {
                // Force ground level
                this.mesh.position.y = this.baseHeight;

                // Direction to player
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, this.mesh.position)
                    .normalize();
                directionToPlayer.y = 0;

                const distanceToPlayer = this.mesh.position.distanceTo(this.game.camera.position);
                const isChasing = distanceToPlayer <= this.detectionRadius;
                this.state = isChasing ? "chasing" : "patrolling";
                
                let speed = this.speed;
                let moveDirection = new THREE.Vector3();
                
                if (isChasing) {
                    speed *= 1.5;
                    moveDirection.copy(directionToPlayer);
                    
                    // Attack if close enough
                    if (distanceToPlayer <= this.attackRange && !this.game.state.powerups.invincibility.active) {
                        const currentTime = Date.now();
                        if (currentTime - this.lastAttackTime >= this.attackCooldown) {
                            // Apply melee damage
                            this.game.state.health -= this.damage;
                            this.lastAttackTime = currentTime;
                            
                            // Visual feedback
                            document.body.style.backgroundColor = 'rgba(255,0,0,0.7)';
                            setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                            
                            const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                            if (screenBloodOverlay) {
                                screenBloodOverlay.style.opacity = '0.9';
                                setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                            }
                            
                            this.game.playSound(100, 0.1, 'square', 0.3);
                            this.game.playSound(50, 0.3, 'sawtooth', 0.3);
                            this.game.updateHUD();
                            this.game.updateHealthBar();
                            
                            if (this.game.state.health <= 0) {
                                this.game.gameOver();
                            }
                        }
                    }
                } else {
                    // Patrol logic
                    if (!this.patrolDirection || this.patrolTimeRemaining <= 0) {
                        this.patrolDirection = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            0,
                            Math.random() * 2 - 1
                        ).normalize();
                        this.patrolTimeRemaining = 60;
                    }
                    moveDirection.copy(this.patrolDirection);
                    this.patrolTimeRemaining--;
                }
                
                // Movement and collision
                if (moveDirection.lengthSq() > 0) {
                    const currentPos = this.mesh.position.clone();
                    const moveAttempt = moveDirection.clone().multiplyScalar(speed);
                    
                    // Try X movement
                    const newPosX = currentPos.clone();
                    newPosX.x += moveAttempt.x;
                    if (!this.game.checkCollision(newPosX, true, false, this.collisionRadius)) {
                        this.mesh.position.x = newPosX.x;
                    }
                    
                    // Try Z movement
                    const newPosZ = currentPos.clone();
                    newPosZ.z += moveAttempt.z;
                    if (!this.game.checkCollision(newPosZ, true, false, this.collisionRadius)) {
                        this.mesh.position.z = newPosZ.z;
                    }
                }
                
                // Update orientation
                if (moveDirection.lengthSq() > 0) {
                    const facePos = this.mesh.position.clone().add(moveDirection);
                    this.mesh.lookAt(facePos);
                }
                
                // Animation
                this.animationTime += this.animationSpeed;
                const walkCycle = Math.sin(this.animationTime);
                const swingAmount = isChasing ? 0.3 : 0.2;
                
                // Animate limbs
                if (moveDirection.lengthSq() > 0) {
                    this.parts.leftArm.position.z = this.parts.originalPositions.leftArm.z + walkCycle * swingAmount;
                    this.parts.rightArm.position.z = this.parts.originalPositions.rightArm.z - walkCycle * swingAmount;
                    this.parts.leftLeg.position.z = this.parts.originalPositions.leftLeg.z - walkCycle * swingAmount;
                    this.parts.rightLeg.position.z = this.parts.originalPositions.rightLeg.z + walkCycle * swingAmount;
                    
                    const bounceHeight = isChasing ? 0.05 : 0.03;
                    const bounceOffset = Math.abs(Math.sin(this.animationTime * 2)) * bounceHeight;
                    this.parts.torso.position.y = this.parts.originalPositions.torso.y + bounceOffset;
                    this.parts.head.position.y = this.parts.originalPositions.head.y + bounceOffset;
                }
            }

            checkHit(projectilePosition) {
                // Get relative position from monster to projectile
                const relativePos = new THREE.Vector3().subVectors(projectilePosition, this.mesh.position);
                
                // Transform relative position to account for monster's rotation
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(-this.mesh.rotation.y);
                relativePos.applyMatrix4(rotationMatrix);

                // Define simplified hit regions with their bounds and damage multipliers
                // Made hit boxes more generous and added overlap between regions
                const hitRegions = {
                    head: {
                        bounds: {
                            x: [-0.5, 0.5],    // Wider head hitbox
                            y: [1.6, 2.2],     // Lower starting point for head
                            z: [-0.5, 0.5]     // Deeper head hitbox
                        },
                        multiplier: 2.0  // Headshots do double damage
                    },
                    body: {
                        bounds: {
                            x: [-0.5, 0.5],    // Wider body hitbox
                            y: [0, 1.6],       // Overlaps slightly with head
                            z: [-0.5, 0.5]     // Deeper body hitbox
                        },
                        multiplier: 1.0  // Normal damage for body shots
                    }
                };

                // Debug hit detection
                //console.log(`Hit check at relative position: (${relativePos.x.toFixed(2)}, ${relativePos.y.toFixed(2)}, ${relativePos.z.toFixed(2)})`);

                // Check each hit region
                for (const [region, data] of Object.entries(hitRegions)) {
                    if (this.isPointInBounds(relativePos, data.bounds)) {
                        //console.log(`Hit registered in ${region} region!`);
                        return {
                            hit: true,
                            region: region,
                            multiplier: data.multiplier
                        };
                    }
                }

                // If no hit registered, log the miss
                //console.log('No hit registered - projectile outside all hit regions');
                return { hit: false };
            }

            isPointInBounds(point, bounds) {
                const inBounds = point.x >= bounds.x[0] && point.x <= bounds.x[1] &&
                       point.y >= bounds.y[0] && point.y <= bounds.y[1] &&
                       point.z >= bounds.z[0] && point.z <= bounds.z[1];
                
                // Debug bounds check
                // if (!inBounds) {
                //     const failedAxis = [];
                //   if (point.x < bounds.x[0] || point.x > bounds.x[1]) failedAxis.push('X');
                //   if (point.y < bounds.y[0] || point.y > bounds.y[1]) failedAxis.push('Y');
                //  if (point.z < bounds.z[0] || point.z > bounds.z[1]) failedAxis.push('Z');
                //  console.log(`Bounds check failed on axes: ${failedAxis.join(', ')}`);
                //  }
                
                return inBounds;
            }
        }

        class FlyingMonster extends Monster {
            constructor(game) {
                super(game);
                this.baseHeight = 3.0;
                this.health = 70;
                this.speed = game.config.monsterSpeed * 1.2;
                this.verticalSpeed = 0.05;  // Removed testing mode check
                this.verticalRange = 1.0;
                this.verticalPosition = 0;
                this.wingAnimationEnabled = true;  // Removed testing mode check
                this.collisionRadius = 0.5; // Based on body and wing size
                this.createMesh();
                this.findValidPosition();
            }

            createMesh() {
                // Body
                const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: 0x000088,
                    emissive: 0x000033,
                    emissiveIntensity: 0.5,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.mesh.add(body);

                // Wings
                const wingGeometry = new THREE.BoxGeometry(2, 0.1, 0.8);
                const wingMaterial = new THREE.MeshStandardMaterial({
                    color: 0x0000aa,
                    emissive: 0x000066,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.8
                });
                
                const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                leftWing.position.set(-0.8, 0, 0);
                this.mesh.add(leftWing);
                
                const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                rightWing.position.set(0.8, 0, 0);
                this.mesh.add(rightWing);

                // Eyes
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.2, 0, 0.4);
                this.mesh.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.2, 0, 0.4);
                this.mesh.add(rightEye);

                // Add point light for glow effect
                const light = new THREE.PointLight(0x0000ff, 1, 2);
                this.mesh.add(light);

                // Store parts for animation
                this.parts = {
                    body,
                    leftWing,
                    rightWing,
                    originalPositions: {
                        leftWing: leftWing.position.clone(),
                        rightWing: rightWing.position.clone()
                    }
                };
            }

            update() {
                // Direction to player
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, this.mesh.position)
                    .normalize();
                directionToPlayer.y = 0;

                const distanceToPlayer = this.mesh.position.distanceTo(this.game.camera.position);
                const isChasing = distanceToPlayer <= this.detectionRadius;
                this.state = isChasing ? "chasing" : "patrolling";
                
                let speed = this.speed;
                let moveDirection = new THREE.Vector3();
                
                if (isChasing) {
                    speed *= 1.5;
                    moveDirection.copy(directionToPlayer);
                    moveDirection.y = 0; // Keep vertical movement separate
                } else {
                    if (!this.patrolDirection || this.patrolTimeRemaining <= 0) {
                        this.patrolDirection = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            0,
                            Math.random() * 2 - 1
                        ).normalize();
                        this.patrolTimeRemaining = 60;
                    }
                    moveDirection.copy(this.patrolDirection);
                    this.patrolTimeRemaining--;
                }
                
                // Movement and collision
                if (moveDirection.lengthSq() > 0) {
                    const currentPos = this.mesh.position.clone();
                    const moveAttempt = moveDirection.clone().multiplyScalar(speed);
                    
                    // Try X movement
                    const newPosX = currentPos.clone();
                    newPosX.x += moveAttempt.x;
                    if (!this.game.checkCollision(newPosX, true, false, this.collisionRadius)) {
                        this.mesh.position.x = newPosX.x;
                    }
                    
                    // Try Z movement
                    const newPosZ = currentPos.clone();
                    newPosZ.z += moveAttempt.z;
                    if (!this.game.checkCollision(newPosZ, true, false, this.collisionRadius)) {
                        this.mesh.position.z = newPosZ.z;
                    }
                }
                
                // Update orientation
                if (moveDirection.lengthSq() > 0) {
                    const facePos = this.mesh.position.clone().add(moveDirection);
                    this.mesh.lookAt(facePos);
                }
                
                // Only update vertical position and wing animation if not in testing mode

                // Vertical movement
                this.verticalPosition += this.verticalSpeed;
                if (Math.abs(this.verticalPosition) > this.verticalRange) {
                    this.verticalSpeed = -this.verticalSpeed;
                }
                this.mesh.position.y = this.baseHeight + this.verticalPosition;

                // Wing animation
                this.animationTime += this.animationSpeed * 2;
                const wingFlap = Math.sin(this.animationTime) * 0.5;
                // Find wing meshes by their position (they're positioned at x: 0.8)
                this.mesh.children.forEach(child => {
                    if (child.position.x < -0.5) {  // Left wing
                        child.rotation.z = wingFlap;
                    } else if (child.position.x > 0.5) {  // Right wing
                        child.rotation.z = -wingFlap;
                    }
                });
                
                
                // Attack logic
                if (distanceToPlayer < this.attackRange && !this.game.state.powerups.invincibility.active) {
                    const currentTime = Date.now();
                    if (currentTime - this.lastAttackTime >= this.attackCooldown) {
                        this.game.state.health -= this.damage;
                        this.lastAttackTime = currentTime;
                        
                        // Visual feedback
                        document.body.style.backgroundColor = 'rgba(0,0,255,0.7)';
                        setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                        
                        const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                        if (screenBloodOverlay) {
                            screenBloodOverlay.style.opacity = '0.9';
                            setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                        }
                        
                        this.game.playSound(200, 0.1, 'sine', 0.3);
                        this.game.updateHUD();
                        this.game.updateHealthBar();
                        
                        if (this.game.state.health <= 0) {
                            this.game.gameOver();
                        }
                    }
                }
            }

            checkHit(projectilePosition) {
                // Get relative position from monster to projectile
                const relativePos = new THREE.Vector3().subVectors(projectilePosition, this.mesh.position);
                
                // Transform relative position to account for monster's rotation
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(-this.mesh.rotation.y);
                relativePos.applyMatrix4(rotationMatrix);

                // Define hit regions with their bounds and damage multipliers
                const hitRegions = {
                    body: {
                        bounds: {
                            x: [-0.5, 0.5],
                            y: [-0.5, 0.5],
                            z: [-0.5, 0.5]
                        },
                        multiplier: 1.0  // Normal damage for body shots
                    },
                    wings: {
                        bounds: [
                            {  // Left wing
                                x: [-1.8, -0.5],
                                y: [-0.25, 0.25],
                                z: [-0.5, 0.5]
                            },
                            {  // Right wing
                                x: [0.5, 1.8],
                                y: [-0.25, 0.25],
                                z: [-0.5, 0.5]
                            }
                        ],
                        multiplier: 0.5  // Wings are more vulnerable
                    }
                };

                // Check each hit region
                for (const [region, data] of Object.entries(hitRegions)) {
                    if (Array.isArray(data.bounds)) {
                        // For regions with multiple parts (like wings)
                        for (const partBounds of data.bounds) {
                            if (this.isPointInBounds(relativePos, partBounds)) {
                                return {
                                    hit: true,
                                    region: region,
                                    multiplier: data.multiplier
                                };
                            }
                        }
                    } else {
                        // For single regions (like body)
                        if (this.isPointInBounds(relativePos, data.bounds)) {
                            return {
                                hit: true,
                                region: region,
                                multiplier: data.multiplier
                            };
                        }
                    }
                }

                return { hit: false };
            }

            isPointInBounds(point, bounds) {
                return point.x >= bounds.x[0] && point.x <= bounds.x[1] &&
                       point.y >= bounds.y[0] && point.y <= bounds.y[1] &&
                       point.z >= bounds.z[0] && point.z <= bounds.z[1];
            }
        }

        class ArcherMonster extends Monster {
            constructor(game) {
                super(game);
                this.baseHeight = 0;
                this.health = 70;
                this.speed = game.config.monsterSpeed * 0.8; // Slightly slower than ground monster
                this.damage = game.config.monsterDamage * 0.7; // Less damage for close combat
                this.detectionRadius = 20; // Longer detection range
                this.attackRange = 15.0; // Much longer attack range for arrows
                this.attackCooldown = 2000; // Longer cooldown for bow attacks
                this.arrowSpeed = 0.3;
                this.arrowDamage = game.config.monsterDamage * 1.2; // More damage for arrows
                this.collisionRadius = 0.4; // Based on body size
                this.createMesh();
                this.findValidPosition();
            }

            createMesh() {
                // Create a zombie-like archer with decaying features
                const archerGroup = new THREE.Group();
                
                // 1. Head - zombie-like with pale skin and sunken features
                const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xc1d5c0, // Pale greenish skin
                    roughness: 0.9,
                    metalness: 0.1,
                    emissive: 0x003300,
                    emissiveIntensity: 0.2
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.8;
                
                // Add sunken glowing eyes
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff3300,
                    emissive: 0xff0000,
                    emissiveIntensity: 1
                });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.15, 0.05, 0.2);
                rightEye.position.set(0.15, 0.05, 0.2);
                leftEye.scale.y = 0.5;
                rightEye.scale.y = 0.5;
                head.add(leftEye);
                head.add(rightEye);
                
                // Add eye glow
                const leftLight = new THREE.PointLight(0xff0000, 1, 0.5);
                const rightLight = new THREE.PointLight(0xff0000, 1, 0.5);
                leftEye.add(leftLight);
                rightEye.add(rightLight);
                
                // 2. Torso - tattered and decaying
                const torsoGeometry = new THREE.BoxGeometry(0.6, 1.0, 0.6);
                const torsoMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x556677,
                    roughness: 1.0,
                    metalness: 0.0
                });
                const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
                torso.position.y = 1.1;
                
                // Add torn flesh effects
                const woundGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.1);
                const woundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x660000,
                    roughness: 0.7,
                    metalness: 0.3,
                    emissive: 0x330000,
                    emissiveIntensity: 0.2
                });
                
                for (let i = 0; i < 3; i++) {
                    const wound = new THREE.Mesh(woundGeometry, woundMaterial);
                    wound.position.set(
                        Math.random() * 0.4 - 0.2,
                        Math.random() * 0.8 - 0.4,
                        0.31
                    );
                    wound.rotation.z = Math.random() * Math.PI / 4;
                    torso.add(wound);
                }
                
                // 3. Arms - decaying with exposed bones
                const armGeometry = new THREE.CylinderGeometry(0.12, 0.08, 0.8, 8);
                const armMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xc1d5c0,
                    roughness: 0.9,
                    metalness: 0.1
                });
                
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                
                // Position arms for bow holding pose
                leftArm.position.set(-0.4, 1.4, 0);
                rightArm.position.set(0.4, 1.4, 0);
                
                // Rotate arms for bow holding pose
                leftArm.rotation.z = Math.PI / 4;
                rightArm.rotation.z = -Math.PI / 4;
                
                // 4. Bow
                const bowGroup = new THREE.Group();
                
                // Main bow curve
                const bowGeometry = new THREE.TorusGeometry(0.5, 0.05, 8, 16, Math.PI);
                const bowMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    roughness: 0.7,
                    metalness: 0.3
                });
                const bow = new THREE.Mesh(bowGeometry, bowMaterial);
                
                // Bowstring
                const stringGeometry = new THREE.CylinderGeometry(0.01, 0.01, 1, 4);
                const stringMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc });
                const bowstring = new THREE.Mesh(stringGeometry, stringMaterial);
                
                bowGroup.add(bow);
                bowGroup.add(bowstring);
                bowGroup.position.set(0.4, 1.4, 0.3);
                bowGroup.rotation.y = Math.PI / 2;
                
                // 5. Legs
                const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 1.0, 8);
                const legMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333366
                });
                
                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                
                leftLeg.position.set(-0.2, 0.5, 0);
                rightLeg.position.set(0.2, 0.5, 0);
                
                // Add all parts to the archer mesh
                archerGroup.add(head);
                archerGroup.add(torso);
                archerGroup.add(leftArm);
                archerGroup.add(rightArm);
                archerGroup.add(leftLeg);
                archerGroup.add(rightLeg);
                archerGroup.add(bowGroup);
                
                this.mesh = archerGroup;
                
                // Store references for animation
                this.parts = {
                    head, torso, leftArm, rightArm, leftLeg, rightLeg, bow: bowGroup,
                    originalPositions: {
                        head: head.position.clone(),
                        torso: torso.position.clone(),
                        leftArm: leftArm.position.clone(),
                        rightArm: rightArm.position.clone(),
                        leftLeg: leftLeg.position.clone(),
                        rightLeg: rightLeg.position.clone(),
                        bow: bowGroup.position.clone()
                    }
                };
            }

            update() {
                // Force ground level and prevent falling
                this.mesh.position.y = this.baseHeight;

                // Direction to player
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, this.mesh.position)
                    .normalize();
                directionToPlayer.y = 0;

                const distanceToPlayer = this.mesh.position.distanceTo(this.game.camera.position);
                const isChasing = distanceToPlayer <= this.detectionRadius;
                this.state = isChasing ? "chasing" : "patrolling";
                
                let speed = this.speed;
                let moveDirection = new THREE.Vector3();
                
                if (isChasing) {
                    // Always face the player
                    const lookAtPos = new THREE.Vector3(
                        this.game.camera.position.x,
                        this.mesh.position.y,  // Keep y-level consistent
                        this.game.camera.position.z
                    );
                    this.mesh.lookAt(lookAtPos);
                    
                    // If too close to player, back away
                    const optimalRange = this.attackRange * 0.7; // Try to stay at 70% of max attack range
                    if (distanceToPlayer < optimalRange) {
                        // Move away from player
                        moveDirection.copy(directionToPlayer).negate();
                        speed *= 1.5; // Move away faster
                    } else if (distanceToPlayer > this.attackRange) {
                        // Move closer to player
                        moveDirection.copy(directionToPlayer);
                        speed *= 1.2;
                    } else {
                        // At good range, strafe sideways
                        const right = new THREE.Vector3().crossVectors(directionToPlayer, new THREE.Vector3(0, 1, 0));
                        moveDirection.copy(right).multiplyScalar(Math.sin(this.animationTime));
                        speed *= 0.8; // Slower when strafing
                    }
                    
                    // Check if we can shoot at the player
                    const currentTime = Date.now();
                    const canShoot = currentTime - this.lastAttackTime >= this.attackCooldown;
                    const inRange = distanceToPlayer <= this.attackRange;
                    const hasLineOfSight = !this.game.checkCollision(
                        new THREE.Vector3(
                            this.mesh.position.x + directionToPlayer.x * distanceToPlayer * 0.5,
                            this.mesh.position.y,
                            this.mesh.position.z + directionToPlayer.z * distanceToPlayer * 0.5
                        ),
                        false,
                        true
                    );

                    // Attack with bow if conditions are met
                    if (inRange && canShoot && hasLineOfSight && !this.game.state.powerups.invincibility.active) {
                        this.shootArrow();
                        this.lastAttackTime = currentTime;
                    }
                } else {
                    // Patrol logic
                    if (!this.patrolDirection || this.patrolTimeRemaining <= 0) {
                        this.patrolDirection = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            0,
                            Math.random() * 2 - 1
                        ).normalize();
                        this.patrolTimeRemaining = 60;
                    }
                    moveDirection.copy(this.patrolDirection);
                    this.patrolTimeRemaining--;
                    
                    // Update orientation for patrol
                    const facePos = this.mesh.position.clone().add(moveDirection);
                    facePos.y = this.mesh.position.y;  // Keep y-level consistent
                    this.mesh.lookAt(facePos);
                }
                
                // Movement and collision
                if (moveDirection.lengthSq() > 0) {
                    const currentPos = this.mesh.position.clone();
                    const moveAttempt = moveDirection.clone().multiplyScalar(speed);
                    
                    // Try X movement
                    const newPosX = currentPos.clone();
                    newPosX.x += moveAttempt.x;
                    if (!this.game.checkCollision(newPosX, true, false, this.collisionRadius)) {
                        this.mesh.position.x = newPosX.x;
                    }
                    
                    // Try Z movement
                    const newPosZ = currentPos.clone();
                    newPosZ.z += moveAttempt.z;
                    if (!this.game.checkCollision(newPosZ, true, false, this.collisionRadius)) {
                        this.mesh.position.z = newPosZ.z;
                    }
                }
                
                // Animation
                this.animationTime += this.animationSpeed;
                const walkCycle = Math.sin(this.animationTime);
                const swingAmount = isChasing ? 0.2 : 0.15;
                
                // Animate limbs
                if (moveDirection.lengthSq() > 0) {
                    this.parts.leftLeg.position.z = this.parts.originalPositions.leftLeg.z - walkCycle * swingAmount;
                    this.parts.rightLeg.position.z = this.parts.originalPositions.rightLeg.z + walkCycle * swingAmount;
                    
                    const bounceHeight = isChasing ? 0.03 : 0.02;
                    const bounceOffset = Math.abs(Math.sin(this.animationTime * 2)) * bounceHeight;
                    this.parts.torso.position.y = this.parts.originalPositions.torso.y + bounceOffset;
                    this.parts.head.position.y = this.parts.originalPositions.head.y + bounceOffset;
                }
            }

            shootArrow() {
                // Create arrow
                const arrowGroup = new THREE.Group();
                
                // Arrow shaft - made larger for visibility
                const shaftGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.6, 8);
                const shaftMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    metalness: 0.3,
                    roughness: 0.7,
                    emissive: 0x3a1707,
                    emissiveIntensity: 0.3
                });
                const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
                
                // Arrow head - made larger
                const headGeometry = new THREE.ConeGeometry(0.08, 0.2, 8);
                const headMaterial = new THREE.MeshStandardMaterial({
                    color: 0x666666,
                    metalness: 0.8,
                    roughness: 0.2,
                    emissive: 0x333333,
                    emissiveIntensity: 0.3
                });
                const arrowHead = new THREE.Mesh(headGeometry, headMaterial);
                arrowHead.position.y = 0.4;
                
                // Arrow fletching - made larger and more visible
                const fletchingGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.02);
                const fletchingMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff0000,
                    metalness: 0.1,
                    roughness: 0.9,
                    emissive: 0x660000,
                    emissiveIntensity: 0.5
                });
                
                const fletching1 = new THREE.Mesh(fletchingGeometry, fletchingMaterial);
                const fletching2 = new THREE.Mesh(fletchingGeometry, fletchingMaterial);
                fletching1.position.y = -0.25;
                fletching2.position.y = -0.25;
                fletching1.rotation.y = Math.PI / 4;
                fletching2.rotation.y = -Math.PI / 4;
                
                arrowGroup.add(shaft);
                arrowGroup.add(arrowHead);
                //arrowGroup.add(fletching1);
                //arrowGroup.add(fletching2);
                
                // Add a point light to make arrow more visible
                //const arrowLight = new THREE.PointLight(0xff6600, 0.5, 2);
                //arrowLight.position.set(0, 0, 0);
                //arrowGroup.add(arrowLight);
                
                // Position and orient arrow - adjusted spawn position
                arrowGroup.position.copy(this.mesh.position);
                arrowGroup.position.y += 1.4; // Shoot from bow height
                arrowGroup.position.z += this.mesh.rotation.y; // Offset based on archer's rotation
                
                // Calculate direction to player with slight randomness
                const spread = 0.1;
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, arrowGroup.position)
                    .normalize();
                
                // Add slight spread
                directionToPlayer.x += (Math.random() - 0.5) * spread;
                directionToPlayer.z += (Math.random() - 0.5) * spread;
                directionToPlayer.normalize();
                
                // Orient arrow
                arrowGroup.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), directionToPlayer);
                
                // Add arrow properties
                arrowGroup.userData = {
                    velocity: directionToPlayer.multiplyScalar(this.arrowSpeed),
                    damage: this.arrowDamage,
                    distance: 0,
                    maxDistance: 30,
                    isArrow: true,
                    isMonsterProjectile: true,  // Add this flag to identify monster projectiles
                    prevPosition: arrowGroup.position.clone(),
                    shooterId: this.mesh.uuid
                };
                
                // Add to game projectiles
                this.game.projectiles.push(arrowGroup);
                this.game.scene.add(arrowGroup);
                
                // Play sound effect
                this.game.playSound(440, 0.1, 'sine', 0.2);
            }

            checkHit(projectilePosition, projectile) {
                // Skip hit detection if the projectile was shot by this archer
                if (projectile && projectile.userData.shooterId === this.mesh.uuid) {
                    return { hit: false };
                }

                // Get relative position from monster to projectile
                const relativePos = new THREE.Vector3().subVectors(projectilePosition, this.mesh.position);
                
                // Transform relative position to account for monster's rotation
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(-this.mesh.rotation.y);
                relativePos.applyMatrix4(rotationMatrix);

                // Define hit regions with generous bounds
                const hitRegions = {
                    head: {
                        bounds: {
                            x: [-0.5, 0.5],    // Wide head hitbox
                            y: [1.6, 2.2],     // Head height range
                            z: [-0.5, 0.5]     // Deep head hitbox
                        },
                        multiplier: 2.0  // Headshots do double damage
                    },
                    body: {
                        bounds: {
                            x: [-0.5, 0.5],    // Wide body hitbox
                            y: [0, 1.6],       // Body height range
                            z: [-0.5, 0.5]     // Deep body hitbox
                        },
                        multiplier: 1.0  // Normal damage for body shots
                    },
                };

                // Check each hit region
                for (const [region, data] of Object.entries(hitRegions)) {
                    if (this.isPointInBounds(relativePos, data.bounds)) {
                        return {
                            hit: true,
                            region: region,
                            multiplier: data.multiplier
                        };
                    }
                }

                return { hit: false };
            }

            isPointInBounds(point, bounds) {
                return point.x >= bounds.x[0] && point.x <= bounds.x[1] &&
                       point.y >= bounds.y[0] && point.y <= bounds.y[1] &&
                       point.z >= bounds.z[0] && point.z <= bounds.z[1];
            }
        }

        class SpiderMonster extends Monster {
            constructor(game) {
                super(game);
                this.baseHeight = 0;
                this.health = 50;  // Low health
                this.speed = game.config.monsterSpeed * 2.0; // Twice as fast as normal monsters
                this.damage = game.config.monsterDamage * 0.5; // Half damage
                this.detectionRadius = 12;
                this.attackRange = 1.0;
                this.attackCooldown = 500; // Fast attacks
                this.jumpCooldown = 2000; // Time between jumps
                this.lastJumpTime = 0;
                this.jumpHeight = 2.0;
                this.jumpSpeed = 0.15;
                this.isJumping = false;
                this.jumpVelocity = 0;
                this.isOnWall = false;
                this.wallNormal = new THREE.Vector3();
                this.wallCrawlTime = 0;
                this.isAttacking = false;
                this.attackJumpTarget = null;
                this.collisionRadius = 0.4; // Based on body and legs
                this.createMesh();
                this.findValidPosition();
            }

            createMesh() {
                // Create spider body
                const bodyGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: 0x222222,
                    roughness: 0.7,
                    metalness: 0.3
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.2;

                // Create eyes (red and glowing)
                const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 1
                });

                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.08, 0.05, 0.15);
                rightEye.position.set(0.08, 0.05, 0.15);
                body.add(leftEye);
                body.add(rightEye);

                // Add eye glow
                const leftLight = new THREE.PointLight(0xff0000, 0.5, 0.5);
                const rightLight = new THREE.PointLight(0xff0000, 0.5, 0.5);
                leftEye.add(leftLight);
                rightEye.add(rightLight);

                // Create legs
                const legGeometry = new THREE.CylinderGeometry(0.02, 0.01, 0.3, 4);
                const legMaterial = new THREE.MeshStandardMaterial({
                    color: 0x111111,
                    roughness: 0.9,
                    metalness: 0.1
                });

                // Create 8 legs
                const legs = [];
                for (let i = 0; i < 8; i++) {
                    const leg = new THREE.Group();
                    
                    // Upper leg segment
                    const upperLeg = new THREE.Mesh(legGeometry, legMaterial);
                    upperLeg.position.y = -0.15;
                    
                    // Lower leg segment
                    const lowerLeg = new THREE.Mesh(legGeometry, legMaterial);
                    lowerLeg.position.y = -0.15;
                    
                    leg.add(upperLeg);
                    upperLeg.add(lowerLeg);
                    
                    // Position legs around body
                    const angle = (i * Math.PI / 4) + (Math.PI / 8);
                    leg.position.set(
                        Math.cos(angle) * 0.2,
                        0.2,
                        Math.sin(angle) * 0.2
                    );
                    
                    // Rotate legs outward
                    leg.rotation.z = -Math.PI / 4;
                    leg.rotation.y = angle;
                    
                    legs.push(leg);
                    this.mesh.add(leg);
                }

                this.mesh.add(body);
                
                // Store references for animation
                this.parts = {
                    body,
                    legs,
                    originalPositions: {
                        body: body.position.clone(),
                        legs: legs.map(leg => ({
                            position: leg.position.clone(),
                            rotation: leg.rotation.clone()
                        }))
                    }
                };
            }

            update() {
                // Direction to player
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, this.mesh.position)
                    .normalize();
                const distanceToPlayer = this.mesh.position.distanceTo(this.game.camera.position);
                const isChasing = distanceToPlayer <= this.detectionRadius;
                this.state = isChasing ? "chasing" : "patrolling";
                
                // Handle wall crawling
                if (!this.isJumping && !this.isAttacking) {
                    const nearestWallDir = this.game.findNearestWallDirection(this.mesh.position);
                    if (nearestWallDir) {
                        const wallDistance = nearestWallDir.length();
                        if (wallDistance < 0.5) {
                            this.isOnWall = true;
                            this.wallNormal = nearestWallDir.normalize();
                        } else {
                            this.isOnWall = false;
                        }
                    }
                }

                let speed = this.speed;
                let moveDirection = new THREE.Vector3();
                
                if (isChasing) {
                    speed *= 1.5;
                    
                    // Decide whether to attack jump
                    const currentTime = Date.now();
                    if (!this.isJumping && !this.isAttacking && 
                        currentTime - this.lastJumpTime >= this.jumpCooldown &&
                        distanceToPlayer <= this.detectionRadius && 
                        distanceToPlayer > this.attackRange) {
                        
                        // Higher chance to jump when closer to player
                        const jumpChance = Math.min(0.8, 1 - (distanceToPlayer / this.detectionRadius));
                        if (Math.random() < jumpChance) {
                            this.startAttackJump(this.game.camera.position.clone());
                        }
                    }

                    if (this.isAttacking) {
                        // Move towards attack target
                        if (this.attackJumpTarget) {
                            moveDirection.copy(this.attackJumpTarget)
                                .sub(this.mesh.position)
                                .normalize();
                            speed *= 2; // Faster during attack jump
                        }
                    } else if (!this.isJumping) {
                        moveDirection.copy(directionToPlayer);
                    }
                    
                    // Attack if close enough
                    if (distanceToPlayer <= this.attackRange && !this.game.state.powerups.invincibility.active) {
                        const currentTime = Date.now();
                        if (currentTime - this.lastAttackTime >= this.attackCooldown) {
                            this.game.state.health -= this.damage;
                            this.lastAttackTime = currentTime;
                            
                            // Visual feedback
                            document.body.style.backgroundColor = 'rgba(255,0,0,0.7)';
                            setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                            
                            const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                            if (screenBloodOverlay) {
                                screenBloodOverlay.style.opacity = '0.9';
                                setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                            }
                            
                            // Play bite sound
                            this.game.playSound(150, 0.1, 'square', 0.2);
                            this.game.updateHUD();
                            this.game.updateHealthBar();
                            
                            if (this.game.state.health <= 0) {
                                this.game.gameOver();
                            }
                        }
                    }
                } else {
                    // Patrol logic
                    if (!this.patrolDirection || this.patrolTimeRemaining <= 0) {
                        this.patrolDirection = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            0,
                            Math.random() * 2 - 1
                        ).normalize();
                        this.patrolTimeRemaining = 60;
                    }
                    moveDirection.copy(this.patrolDirection);
                    this.patrolTimeRemaining--;
                }
                
                // Apply wall crawling movement
                if (this.isOnWall && !this.isJumping && !this.isAttacking) {
                    this.wallCrawlTime += 0.1;
                    const wallOffset = Math.sin(this.wallCrawlTime) * 0.1;
                    this.mesh.position.y = 0.5 + wallOffset;
                    
                    // Rotate to face along wall
                    const wallTangent = new THREE.Vector3().crossVectors(this.wallNormal, new THREE.Vector3(0, 1, 0));
                    moveDirection.projectOnPlane(this.wallNormal);
                }

                // Movement and collision
                if (moveDirection.lengthSq() > 0) {
                    const currentPos = this.mesh.position.clone();
                    const moveAttempt = moveDirection.clone().multiplyScalar(speed);
                    
                    // Try X movement
                    const newPosX = currentPos.clone();
                    newPosX.x += moveAttempt.x;
                    if (!this.game.checkCollision(newPosX, true, false, this.collisionRadius)) {
                        this.mesh.position.x = newPosX.x;
                    }
                    
                    // Try Z movement
                    const newPosZ = currentPos.clone();
                    newPosZ.z += moveAttempt.z;
                    if (!this.game.checkCollision(newPosZ, true, false, this.collisionRadius)) {
                        this.mesh.position.z = newPosZ.z;
                    }
                }
                
                // Update orientation
                if (moveDirection.lengthSq() > 0) {
                    const facePos = this.mesh.position.clone().add(moveDirection);
                    this.mesh.lookAt(facePos);
                }
                
                // Handle jumping physics
                if (this.isJumping) {
                    this.jumpVelocity -= 0.015; // Gravity
                    this.mesh.position.y += this.jumpVelocity;
                    
                    // Check for landing
                    if (this.mesh.position.y <= this.baseHeight) {
                        this.mesh.position.y = this.baseHeight;
                        this.isJumping = false;
                        this.isAttacking = false;
                        this.jumpVelocity = 0;
                        this.attackJumpTarget = null;
                    }
                }
                
                // Animate legs
                this.animationTime += this.animationSpeed * 2;
                const walkCycle = Math.sin(this.animationTime);
                const legPhases = [0, Math.PI, Math.PI/2, Math.PI*1.5, 0, Math.PI, Math.PI/2, Math.PI*1.5];
                
                this.parts.legs.forEach((leg, index) => {
                    const phase = legPhases[index];
                    const lift = Math.sin(this.animationTime + phase) * 0.1;
                    leg.position.y = this.parts.originalPositions.legs[index].position.y + lift;
                    
                    leg.rotation.z = this.parts.originalPositions.legs[index].rotation.z + 
                                   (Math.sin(this.animationTime + phase) * 0.2);
                });
            }

            startAttackJump(targetPos) {
                if (!this.isJumping && !this.isAttacking) {
                    this.isJumping = true;
                    this.isAttacking = true;
                    this.jumpVelocity = this.jumpSpeed * 1.5;
                    this.lastJumpTime = Date.now();
                    this.attackJumpTarget = targetPos;
                    
                    // Play jump sound
                    this.game.playSound(200, 0.1, 'sine', 0.2);
                }
            }

            checkHit(projectilePosition) {
                // Get relative position from monster to projectile
                const relativePos = new THREE.Vector3().subVectors(projectilePosition, this.mesh.position);
                
                // Transform relative position to account for monster's rotation
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(-this.mesh.rotation.y);
                relativePos.applyMatrix4(rotationMatrix);

                // Define hit regions with their bounds and damage multipliers
                const hitRegions = {
                    body: {
                        bounds: {
                            x: [-0.5, 0.5],
                            y: [-0.5, 0.5],
                            z: [-0.5, 0.5]
                        },
                        multiplier: 1.0  // Critical hits due to small size
                    },
                };

                // Check each hit region
                for (const [region, data] of Object.entries(hitRegions)) {
                    if (this.isPointInBounds(relativePos, data.bounds)) {
                        return {
                            hit: true,
                            region: region,
                            multiplier: data.multiplier
                        };
                    }
                }

                return { hit: false };
            }

            isPointInBounds(point, bounds) {
                return point.x >= bounds.x[0] && point.x <= bounds.x[1] &&
                       point.y >= bounds.y[0] && point.y <= bounds.y[1] &&
                       point.z >= bounds.z[0] && point.z <= bounds.z[1];
            }
        }

        class GiantMonster extends Monster {
            constructor(game) {
                super(game);
                this.baseHeight = 0;
                this.health = 200;  // High HP
                this.speed = game.config.monsterSpeed * 0.6; // 40% slower than normal
                this.damage = game.config.monsterDamage * 2.5; // 2.5x normal damage
                this.detectionRadius = 20;
                this.attackRange = 3.0; // Melee range with club
                this.attackCooldown = 2000; // Slow attacks
                this.chaseStartTime = 0;
                this.hasClub = true;
                this.clubThrowSpeed = 0.4;
                this.clubThrowDamage = this.damage * 0.8;
                this.clubReturnDistance = 1.5;
                this.collisionRadius = 0.5; // Larger due to giant size
                this.createMesh();
                this.findValidPosition();

                // Initialize arm positions
                if (this.parts && this.parts.rightArm && this.parts.leftArm) {
                    // Set initial arm rotations
                    this.parts.rightArm.rotation.set(0, 0, Math.PI / 3);
                    this.parts.leftArm.rotation.set(0, 0, -Math.PI / 5);
                }
            }

            createMesh() {
                const giantGroup = new THREE.Group();
                
                // Create fat torso using multiple merged geometries
                const torsoGroup = new THREE.Group();
                
                // Main belly (larger sphere for fat appearance)
                const bellyGeometry = new THREE.SphereGeometry(1.0, 16, 16);
                const torsoMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x666666,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const belly = new THREE.Mesh(bellyGeometry, torsoMaterial);
                belly.position.y = 1.8;
                belly.scale.set(1.2, 1.0, 0.8);
                
                // Upper torso (slightly smaller)
                const upperTorsoGeometry = new THREE.SphereGeometry(0.8, 16, 16);
                const upperTorso = new THREE.Mesh(upperTorsoGeometry, torsoMaterial);
                upperTorso.position.y = 2.6;
                upperTorso.scale.set(1.0, 0.8, 0.7);
                
                torsoGroup.add(belly);
                torsoGroup.add(upperTorso);
                
                // Create thick legs using merged geometries
                const legGroup = new THREE.Group();
                
                // Function to create a thick leg
                const createThickLeg = (isLeft) => {
                    const legGroup = new THREE.Group();
                    
                    // Upper thigh (fat part)
                    const thighGeometry = new THREE.SphereGeometry(0.4, 12, 12);
                    const thigh = new THREE.Mesh(thighGeometry, torsoMaterial);
                    thigh.scale.set(1, 1.2, 1);
                    thigh.position.y = 1.4;
                    
                    // Calf (slightly thinner)
                    const calfGeometry = new THREE.SphereGeometry(0.3, 12, 12);
                    const calf = new THREE.Mesh(calfGeometry, torsoMaterial);
                    calf.scale.set(1, 1.5, 1);
                    calf.position.y = 0.7;
                    
                    // Foot
                    const footGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.6);
                    const foot = new THREE.Mesh(footGeometry, torsoMaterial);
                    foot.position.y = 0.1;
                    foot.position.z = 0.1;
                    
                    legGroup.add(thigh);
                    legGroup.add(calf);
                    legGroup.add(foot);
                    
                    // Position the leg
                    legGroup.position.x = isLeft ? -0.4 : 0.4;
                    return legGroup;
                };
                
                const leftLeg = createThickLeg(true);
                const rightLeg = createThickLeg(false);
                
                legGroup.add(leftLeg);
                legGroup.add(rightLeg);
                
                // Create two heads with detailed faces
                const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x777777,
                    roughness: 0.7,
                    metalness: 0.3
                });
                
                const leftHead = new THREE.Mesh(headGeometry, headMaterial);
                leftHead.position.set(-0.4, 3.3, 0);
                const rightHead = new THREE.Mesh(headGeometry, headMaterial);
                rightHead.position.set(0.4, 3.3, 0);
                
                // Create eyeballs and pupils for each head
                const createEye = () => {
                    const eyeGroup = new THREE.Group();
                    
                    // White eyeball
                    const eyeballGeometry = new THREE.SphereGeometry(0.15, 12, 12);
                    const eyeballMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        roughness: 0.2,
                        metalness: 0.1
                    });
                    const eyeball = new THREE.Mesh(eyeballGeometry, eyeballMaterial);
                    
                    // Black pupil
                    const pupilGeometry = new THREE.SphereGeometry(0.07, 8, 8);
                    const pupilMaterial = new THREE.MeshStandardMaterial({
                        color: 0x000000,
                        roughness: 0.1,
                        metalness: 0.1
                    });
                    const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                    pupil.position.z = 0.08;
                    
                    eyeGroup.add(eyeball);
                    eyeGroup.add(pupil);
                    
                    // Store references for blinking animation
                    eyeGroup.userData = {
                        eyeball,
                        pupil,
                        originalScale: eyeball.scale.clone(),
                        blinkTime: Math.random() * 1000,
                        nextBlinkTime: Date.now() + Math.random() * 5000
                    };
                    
                    return eyeGroup;
                };
                
                const leftEye = createEye();
                leftEye.position.set(0, 0, 0.3);
                const rightEye = createEye();
                rightEye.position.set(0, 0, 0.3);
                
                // Create mouths with sharp teeth
                const createMouth = () => {
                    const mouthGroup = new THREE.Group();
                    
                    // Create jaw
                    const jawGeometry = new THREE.BoxGeometry(0.3, 0.15, 0.2);
                    const jawMaterial = new THREE.MeshStandardMaterial({
                        color: 0x550000,
                        roughness: 0.8,
                        metalness: 0.2
                    });
                    const jaw = new THREE.Mesh(jawGeometry, jawMaterial);
                    jaw.position.z = 0.3;
                    jaw.position.y = -0.2;
                    
                    // Create teeth
                    const teethGroup = new THREE.Group();
                    const teethMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffcc,
                        roughness: 0.3,
                        metalness: 0.4
                    });
                    
                    // Create multiple sharp teeth
                    for (let i = 0; i < 6; i++) {
                        const toothGeometry = new THREE.ConeGeometry(0.03, 0.08, 4);
                        const tooth = new THREE.Mesh(toothGeometry, teethMaterial);
                        tooth.position.x = (i - 2.5) * 0.05;
                        tooth.position.y = -0.15;
                        tooth.position.z = 0.35;
                        tooth.rotation.x = -Math.PI / 6;
                        teethGroup.add(tooth);
                        
                        // Add bottom teeth
                        const bottomTooth = new THREE.Mesh(toothGeometry, teethMaterial);
                        bottomTooth.position.x = (i - 2.5) * 0.05;
                        bottomTooth.position.y = -0.25;
                        bottomTooth.position.z = 0.35;
                        bottomTooth.rotation.x = Math.PI / 6;
                        teethGroup.add(bottomTooth);
                    }
                    
                    mouthGroup.add(jaw);
                    mouthGroup.add(teethGroup);
                    return mouthGroup;
                };
                
                const leftMouth = createMouth();
                const rightMouth = createMouth();
                
                leftHead.add(leftEye);
                leftHead.add(leftMouth);
                rightHead.add(rightEye);
                rightHead.add(rightMouth);
                
                // Create thick arms
                const createArm = (isLeft) => {
                    const armGroup = new THREE.Group();
                    
                    // Upper arm (thick)
                    const upperArmGeometry = new THREE.SphereGeometry(0.25, 12, 12);
                    const upperArm = new THREE.Mesh(upperArmGeometry, torsoMaterial);
                    upperArm.scale.set(1, 1.8, 1);
                    upperArm.position.y = -0.4;
                    
                    // Forearm (slightly thinner)
                    const forearmGeometry = new THREE.SphereGeometry(0.2, 12, 12);
                    const forearm = new THREE.Mesh(forearmGeometry, torsoMaterial);
                    forearm.scale.set(1, 1.5, 1);
                    forearm.position.y = -1.0;
                    
                    armGroup.add(upperArm);
                    armGroup.add(forearm);
                    
                    // Position the arm
                    armGroup.position.set(isLeft ? -0.7 : 0.7, 2.8, 0);
                    return armGroup;
                };
                
                const leftArm = createArm(true);
                const rightArm = createArm(false);
                
                // Create club with pivot point at handle end
                const clubGroup = new THREE.Group();
                
                const clubHandleGeometry = new THREE.CylinderGeometry(0.1, 0.08, 1.5, 8);
                const clubHeadGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const clubMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    roughness: 0.8,
                    metalness: 0.2
                });
                
                const clubHandle = new THREE.Mesh(clubHandleGeometry, clubMaterial);
                clubHandle.position.y = 0.75; // Move handle up so pivot is at bottom
                
                const clubHead = new THREE.Mesh(clubHeadGeometry, clubMaterial);
                clubHead.position.y = 1.5; // Position relative to handle
                clubHead.scale.set(1.2, 1, 1.2);
                
                clubGroup.add(clubHandle);
                clubGroup.add(clubHead);
                
                // Position club at right hand
                clubGroup.position.set(1.5, 2.5, 0);
                clubGroup.rotation.z = -Math.PI / 6;
                
                // Store club reference
                this.club = clubGroup;
                
                // Add all parts to the giant mesh
                giantGroup.add(torsoGroup);
                giantGroup.add(legGroup);
                giantGroup.add(leftHead);
                giantGroup.add(rightHead);
                giantGroup.add(leftArm);
                giantGroup.add(rightArm);
                giantGroup.add(clubGroup);
                
                this.mesh = giantGroup;
                
                // Store references for animation
                this.parts = {
                    torso: torsoGroup,
                    leftHead,
                    rightHead,
                    leftArm,
                    rightArm,
                    leftLeg,
                    rightLeg,
                    club: clubGroup,
                    leftEye,
                    rightEye,
                    originalPositions: {
                        leftHead: leftHead.position.clone(),
                        rightHead: rightHead.position.clone(),
                        leftArm: leftArm.position.clone(),
                        rightArm: rightArm.position.clone(),
                        leftLeg: leftLeg.position.clone(),
                        rightLeg: rightLeg.position.clone(),
                        club: clubGroup.position.clone()
                    }
                };

                // After creating arms, set their initial positions and rotations
                if (leftArm && rightArm) {
                    leftArm.rotation.set(0, 0, -Math.PI / 5);  // Slight outward angle
                    rightArm.rotation.set(0, 0, Math.PI / 3);  // Club holding position
                }
            }

            update() {
                // Force ground level
                this.mesh.position.y = this.baseHeight;

                // Direction to player
                const directionToPlayer = new THREE.Vector3()
                    .subVectors(this.game.camera.position, this.mesh.position)
                    .normalize();
                directionToPlayer.y = 0;

                const distanceToPlayer = this.mesh.position.distanceTo(this.game.camera.position);
                const isChasing = distanceToPlayer <= this.detectionRadius;
                this.state = isChasing ? "chasing" : "patrolling";
                
                let speed = this.speed;
                let moveDirection = new THREE.Vector3();
                
                // If we don't have the club, move towards it
                if (!this.hasClub && this.thrownClub) {
                    const dirToClub = new THREE.Vector3()
                        .subVectors(this.thrownClub.position, this.mesh.position);
                    dirToClub.y = 0;
                    const distanceToClub = dirToClub.length();
                    dirToClub.normalize();
                    
                    if (distanceToClub <= this.clubReturnDistance) {
                        this.retrieveClub();
                    } else {
                        moveDirection.copy(dirToClub);
                        speed *= 1.5;
                        
                        // Only rotate around Y axis to face the club
                        const targetAngle = Math.atan2(dirToClub.x, dirToClub.z);
                        this.mesh.rotation.y = targetAngle;
                    }
                } else if (isChasing) {
                    if (this.chaseStartTime === 0) {
                        this.chaseStartTime = Date.now();
                    }
                    
                    speed *= 1.2;
                    moveDirection.copy(directionToPlayer);
                    
                    // Only rotate around Y axis to face the player
                    const targetAngle = Math.atan2(directionToPlayer.x, directionToPlayer.z);
                    this.mesh.rotation.y = targetAngle;
                    
                    const chaseTime = Date.now() - this.chaseStartTime;
                    const canThrowClub = chaseTime > 2500 && this.hasClub && distanceToPlayer > 7;
                    
                    if (canThrowClub) {
                        const hasLineOfSight = !this.game.checkCollision(
                            new THREE.Vector3(
                                this.mesh.position.x + directionToPlayer.x * distanceToPlayer * 0.5,
                                this.mesh.position.y,
                                this.mesh.position.z + directionToPlayer.z * distanceToPlayer * 0.5
                            ),
                            false,
                            true
                        );
                        
                        if (hasLineOfSight) {
                            this.throwClub();
                        }
                    }
                    
                    if (distanceToPlayer <= this.attackRange && this.hasClub && !this.game.state.powerups.invincibility.active) {
                        const currentTime = Date.now();
                        if (currentTime - this.lastAttackTime >= this.attackCooldown) {
                            // Apply damage
                            this.game.state.health -= this.damage;
                            this.lastAttackTime = currentTime;
                            
                            // Visual feedback
                            document.body.style.backgroundColor = 'rgba(255,0,0,0.7)';
                            setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                            
                            const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                            if (screenBloodOverlay) {
                                screenBloodOverlay.style.display = 'block';
                                screenBloodOverlay.style.opacity = '0.9';
                                setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                            }
                            
                            // Play heavy hit sound
                            this.game.playSound(80, 0.2, 'square', 0.4);
                            this.game.playSound(40, 0.3, 'sawtooth', 0.3);
                            
                            // Add screen shake
                            this.game.addScreenShake(0.2, 200);
                            
                            this.game.updateHUD();
                            this.game.updateHealthBar();
                            
                            if (this.game.state.health <= 0) {
                                this.game.gameOver();
                            }
                            
                            // Animate club swing and arms together
                            const swingDuration = 200;
                            const startRotation = this.parts.club.rotation.z;
                            const endRotation = startRotation - Math.PI; // Full swing
                            const startTime = Date.now();
                            
                            const animateSwing = () => {
                                const elapsed = Date.now() - startTime;
                                const progress = Math.min(1, elapsed / swingDuration);
                                
                                // Use easing for smoother swing
                                const easeProgress = Math.sin(progress * Math.PI / 2);
                                
                                // Swing club and arms together
                                const currentRotation = startRotation + (endRotation - startRotation) * easeProgress;
                                this.parts.club.rotation.z = currentRotation;
                                this.parts.rightArm.rotation.z = currentRotation * 0.7;
                                this.parts.leftArm.rotation.z = currentRotation * 0.5;
                                
                                if (progress < 1) {
                                    requestAnimationFrame(animateSwing);
                                } else {
                                    // Reset to original position with a smooth return
                                    const returnDuration = 100;
                                    const returnStartTime = Date.now();
                                    
                                    const returnToIdle = () => {
                                        const returnElapsed = Date.now() - returnStartTime;
                                        const returnProgress = Math.min(1, returnElapsed / returnDuration);
                                        
                                        // Use easing for smooth return
                                        const returnEase = 1 - Math.pow(1 - returnProgress, 2);
                                        
                                        // Return to original positions
                                        this.parts.club.rotation.z = endRotation + (startRotation - endRotation) * returnEase;
                                        this.parts.rightArm.rotation.z = Math.PI / 3;
                                        this.parts.leftArm.rotation.z = -Math.PI / 5;
                                        
                                        if (returnProgress < 1) {
                                            requestAnimationFrame(returnToIdle);
                                        }
                                    };
                                    
                                    returnToIdle();
                                }
                            };
                            
                            animateSwing();
                        }
                    }
                } else {
                    this.chaseStartTime = 0;
                    
                    if (!this.patrolDirection || this.patrolTimeRemaining <= 0) {
                        this.patrolDirection = new THREE.Vector3(
                            Math.random() * 2 - 1,
                            0,
                            Math.random() * 2 - 1
                        ).normalize();
                        this.patrolTimeRemaining = 60;
                    }
                    moveDirection.copy(this.patrolDirection);
                    this.patrolTimeRemaining--;
                    
                    // Only rotate around Y axis during patrol
                    if (moveDirection.lengthSq() > 0) {
                        const targetAngle = Math.atan2(moveDirection.x, moveDirection.z);
                        this.mesh.rotation.y = targetAngle;
                    }
                }
                
                // Movement and collision
                if (moveDirection.lengthSq() > 0) {
                    const currentPos = this.mesh.position.clone();
                    const moveAttempt = moveDirection.clone().multiplyScalar(speed);
                    
                    // For Giant Monster, we use a more thorough collision check
                    // Check multiple points around the monster's perimeter due to its size
                    const checkCollisionAtOffset = (basePos, xOffset, zOffset) => {
                        const checkPos = basePos.clone();
                        checkPos.x += xOffset;
                        checkPos.z += zOffset;
                        return this.game.checkCollision(checkPos, true, false, this.collisionRadius);
                    };
                    
                    // Try X movement with multi-point collision detection
                    const newPosX = currentPos.clone();
                    newPosX.x += moveAttempt.x;
                    
                    // Check collision at center and perimeter points
                    const willCollideX = 
                        checkCollisionAtOffset(newPosX, 0, 0) ||    // Center
                        checkCollisionAtOffset(newPosX, 0, 0.4) ||  // Front
                        checkCollisionAtOffset(newPosX, 0, -0.4) || // Back
                        checkCollisionAtOffset(newPosX, 0.4, 0) ||  // Right
                        checkCollisionAtOffset(newPosX, -0.4, 0);   // Left
                    
                    if (!willCollideX) {
                        this.mesh.position.x = newPosX.x;
                    }
                    
                    // Try Z movement with multi-point collision detection
                    const newPosZ = currentPos.clone();
                    newPosZ.z += moveAttempt.z;
                    
                    // Check collision at center and perimeter points
                    const willCollideZ = 
                        checkCollisionAtOffset(newPosZ, 0, 0) ||    // Center
                        checkCollisionAtOffset(newPosZ, 0, 0.4) ||  // Front
                        checkCollisionAtOffset(newPosZ, 0, -0.4) || // Back
                        checkCollisionAtOffset(newPosZ, 0.4, 0) ||  // Right
                        checkCollisionAtOffset(newPosZ, -0.4, 0);   // Left
                    
                    if (!willCollideZ) {
                        this.mesh.position.z = newPosZ.z;
                    }
                }
                
                // Force upright position
                this.mesh.rotation.x = 0;
                this.mesh.rotation.z = 0;
                this.mesh.position.y = this.baseHeight;
                
                // Animation
                this.animationTime += this.animationSpeed;
                const walkCycle = Math.sin(this.animationTime);
                const swingAmount = isChasing ? 0.2 : 0.15;
                
                // Animate legs and body
                if (moveDirection.lengthSq() > 0) {
                    this.parts.leftLeg.position.z = this.parts.originalPositions.leftLeg.z + walkCycle * swingAmount;
                    this.parts.rightLeg.position.z = this.parts.originalPositions.rightLeg.z - walkCycle * swingAmount;
                    
                    // Animate heads bobbing
                    const headBob = Math.abs(Math.sin(this.animationTime * 2)) * 0.1;
                    this.parts.leftHead.position.y = this.parts.originalPositions.leftHead.y + headBob;
                    this.parts.rightHead.position.y = this.parts.originalPositions.rightHead.y + headBob;
                    
                    // Animate arms and club together during walk
                    if (this.hasClub) {
                        const armSwing = walkCycle * 0.2;
                        this.parts.rightArm.rotation.x = armSwing;
                        this.parts.leftArm.rotation.x = -armSwing;
                        this.parts.club.rotation.x = armSwing;
                    } else {
                        // Both arms swing opposite to legs when not holding club
                        this.parts.rightArm.rotation.x = -walkCycle * 0.4;
                        this.parts.leftArm.rotation.x = walkCycle * 0.4;
                    }
                }
                
                // Update thrown club if it exists
                if (this.thrownClub) {
                    this.updateThrownClub();
                }
            }

            throwClub() {
                if (!this.hasClub) return;
                
                this.hasClub = false;
                this.chaseStartTime = 0; // Reset chase timer
                
                // Create thrown club mesh
                const clubGroup = new THREE.Group();
                
                // Copy club geometry
                this.parts.club.traverse(child => {
                    if (child.isMesh) {
                        const clonedMesh = child.clone();
                        clubGroup.add(clonedMesh);
                    }
                });
                
                // Position at giant's hand
                clubGroup.position.copy(this.mesh.position);
                clubGroup.position.y += 2.5;
                clubGroup.position.x += Math.cos(this.mesh.rotation.y) * 1.5;
                clubGroup.position.z += Math.sin(this.mesh.rotation.y) * 1.5;
                
                // Calculate throw direction
                const throwDirection = new THREE.Vector3()
                    .subVectors(this.game.camera.position, clubGroup.position)
                    .normalize();
                
                // Add club properties
                clubGroup.userData = {
                    velocity: throwDirection.multiplyScalar(this.clubThrowSpeed),
                    rotationSpeed: new THREE.Vector3(
                        Math.random() * 0.2 - 0.1,
                        Math.random() * 0.2 - 0.1,
                        Math.random() * 0.2 - 0.1
                    ),
                    damage: this.clubThrowDamage
                };
                
                this.thrownClub = clubGroup;
                this.game.scene.add(clubGroup);
                
                // Hide held club
                this.parts.club.visible = false;
                
                // Play throw sound
                this.game.playSound(200, 0.1, 'sine', 0.3);
            }

            updateThrownClub() {
                if (!this.thrownClub) return;
                
                // Store previous position for collision check
                const prevPosition = this.thrownClub.position.clone();
                
                // Update position
                this.thrownClub.position.add(this.thrownClub.userData.velocity);
                
                // Add rotation only if the club is moving
                if (this.thrownClub.userData.velocity.lengthSq() > 0.001) {
                    this.thrownClub.rotation.x += this.thrownClub.userData.rotationSpeed.x;
                    this.thrownClub.rotation.y += this.thrownClub.userData.rotationSpeed.y;
                    this.thrownClub.rotation.z += this.thrownClub.userData.rotationSpeed.z;
                }
                
                // Check wall collision
                if (this.game.checkCollision(this.thrownClub.position, false, true)) {
                    this.thrownClub.position.copy(prevPosition);
                    this.thrownClub.userData.velocity.set(0, 0, 0);
                    // Stop rotation when hitting wall
                    this.thrownClub.userData.rotationSpeed.set(0, 0, 0);
                    return;
                }
                
                // Check player collision
                if (!this.game.state.powerups.invincibility.active) {
                    const distanceToPlayer = this.thrownClub.position.distanceTo(this.game.camera.position);
                    if (distanceToPlayer < 1.0) {
                        // Apply damage
                        this.game.state.health -= this.thrownClub.userData.damage;
                        
                        // Visual feedback
                        document.body.style.backgroundColor = 'rgba(255,0,0,0.7)';
                        setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                        
                        const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                        if (screenBloodOverlay) {
                            screenBloodOverlay.style.display = 'block';
                            screenBloodOverlay.style.opacity = '0.9';
                            setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                        }
                        
                        // Play hit sound
                        this.game.playSound(100, 0.1, 'square', 0.3);
                        this.game.playSound(50, 0.3, 'sawtooth', 0.3);
                        
                        // Add screen shake
                        this.game.addScreenShake(0.15, 150);
                        
                        // Update UI
                        this.game.updateHUD();
                        this.game.updateHealthBar();
                        
                        if (this.game.state.health <= 0) {
                            this.game.gameOver();
                        }
                        
                        // Stop club movement
                        this.thrownClub.userData.velocity.set(0, 0, 0);
                    }
                }
            }

            retrieveClub() {
                if (!this.thrownClub) return;
                
                // Store current position and orientation
                const currentPos = this.mesh.position.clone();
                const currentRotY = this.mesh.rotation.y;
                
                // Remove thrown club from scene
                this.game.scene.remove(this.thrownClub);
                this.thrownClub = null;
                
                // Make held club visible and reset its position/rotation
                this.parts.club.visible = true;
                this.parts.club.position.copy(this.parts.originalPositions.club);
                this.parts.club.rotation.set(0, 0, -Math.PI / 6);
                
                // Reset arm positions
                this.parts.rightArm.rotation.set(0, 0, Math.PI / 3);
                this.parts.leftArm.rotation.set(0, 0, -Math.PI / 5);
                
                // Force upright position while maintaining horizontal orientation
                this.mesh.position.copy(currentPos);
                this.mesh.position.y = this.baseHeight;
                this.mesh.rotation.set(0, currentRotY, 0);
                
                // Reset all velocities
                if (this.velocity) {
                    this.velocity.set(0, 0, 0);
                }
                
                this.hasClub = true;
                
                // Play pickup sound
                this.game.playSound(440, 0.1, 'sine', 0.2);
            }

            checkHit(projectilePosition) {
                // Get relative position from monster to projectile
                const relativePos = new THREE.Vector3().subVectors(projectilePosition, this.mesh.position);
                
                // Transform relative position to account for monster's rotation
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(-this.mesh.rotation.y);
                relativePos.applyMatrix4(rotationMatrix);

                // Define hit regions with their bounds and damage multipliers
                const hitRegions = {
                    heads: {
                        bounds: [
                            {  // Left head
                                x: [-0.8, -0.1],
                                y: [3.0, 3.7],
                                z: [-0.5, 0.5]
                            },
                            {  // Right head
                                x: [0.1, 0.8],
                                y: [3.0, 3.7],
                                z: [-0.5, 0.5]
                            }
                        ],
                        multiplier: 1.5  // Headshots do more damage
                    },
                    upperBody: {
                        bounds: {
                            x: [-0.8, 0.8],
                            y: [2.2, 3.0],
                            z: [-0.5, 0.5]
                        },
                        multiplier: 0.1  // Upper body is normal damage
                    },
                    belly: {
                        bounds: {
                            x: [-1.2, 1.2],
                            y: [1.4, 2.2],
                            z: [-0.8, 0.8]
                        },
                        multiplier: 1.0  // Belly is normal damage
                    },
                    arms: {
                        bounds: [
                            {  // Left arm
                                x: [-1.4, -0.8],
                                y: [1.4, 2.8],
                                z: [-0.5, 0.5]
                            },
                            {  // Right arm
                                x: [0.8, 1.4],
                                y: [1.4, 2.8],
                                z: [-0.5, 0.5]
                            }
                        ],
                        multiplier: 0.5  // Reduced damage for arms
                    },
                    legs: {
                        bounds: [
                            {  // Left leg
                                x: [-0.6, -0.2],
                                y: [0.1, 1.4],
                                z: [-0.5, 0.5]
                            },
                            {  // Right leg
                                x: [0.2, 0.6],
                                y: [0.1, 1.4],
                                z: [-0.5, 0.5]
                            }
                        ],
                        multiplier: 0.5  // Reduced damage for legs
                    },
                    club: {
                        bounds: {
                            x: [0.8, 1.8],
                            y: [1.8, 3.0],
                            z: [-0.3, 0.3]
                        },
                        multiplier: 0  // Club can't be damaged
                    }
                };

                // Check each hit region
                for (const [region, data] of Object.entries(hitRegions)) {
                    if (Array.isArray(data.bounds)) {
                        // For regions with multiple parts (like heads)
                        for (const partBounds of data.bounds) {
                            if (this.isPointInBounds(relativePos, partBounds)) {
                                return {
                                    hit: true,
                                    region: region,
                                    multiplier: data.multiplier
                                };
                            }
                        }
                    } else {
                        // For single regions (like body)
                        if (this.isPointInBounds(relativePos, data.bounds)) {
                            return {
                                hit: true,
                                region: region,
                                multiplier: data.multiplier
                            };
                        }
                    }
                }

                return { hit: false };
            }

            isPointInBounds(point, bounds) {
                return point.x >= bounds.x[0] && point.x <= bounds.x[1] &&
                       point.y >= bounds.y[0] && point.y <= bounds.y[1] &&
                       point.z >= bounds.z[0] && point.z <= bounds.z[1];
            }
        }

        class Game {
            constructor(gameMode = 'normal') {
                this.gameMode = gameMode;
                this.config = {
                    playerSpeed: 0.15,      // Reduced from 0.2
                    playerHeight: 1.7,      // Restored player height
                    playerJumpForce: 0.3,   // Consolidated jump force value
                    gravity: 0.015,         // Consolidated gravity value
                    mouseSensitivity: 0.002,
                    monsterSpeed: 0.05,      // Set very low speed so movement is recognizable
                    monsterDamage: 15,      // Increased from 10 for more danger
                    startingAmmo: 30,
                    mazeSize: 15,          // Initial maze size
                    bulletDamage: 25,
                    shootingCooldown: 250,
                    reloadTime: 2000,
                    cellSize: 2,
                    // Add level configurations
                    levels: [
                        { mazeSize: 15, enemies: 5 },    // Level 1
                        { mazeSize: 16, enemies: 7 },    // Level 2
                        { mazeSize: 17, enemies: 9 },    // Level 3
                        { mazeSize: 18, enemies: 11 },   // Level 4
                        { mazeSize: 19, enemies: 13 },   // Level 5
                        { mazeSize: 20, enemies: 15 },   // Level 6
                        { mazeSize: 21, enemies: 17 },   // Level 7
                        { mazeSize: 22, enemies: 19 },   // Level 8
                        { mazeSize: 23, enemies: 21 },   // Level 9
                        { mazeSize: 24, enemies: 23 },   // Level 10 (Final Level)
                    ],
                    weapons: {
                        grapplingHook: {
                            cooldown: 100,
                            ammo: Infinity,
                            maxAmmo: Infinity,
                            speed: 0.5,
                            recoil: 0.1,
                            hookRange: 50,
                            pullSpeed: 0.3
                        },
                        pistol: { 
                            damage: 20, 
                            cooldown: 500, 
                            ammo: 50, 
                            maxAmmo: 100, 
                            speed: 1,
                            recoil: 0.15  // Add recoil values for each weapon
                        },
                        shotgun: { 
                            damage: 10, 
                            cooldown: 2000, 
                            ammo: 20, 
                            maxAmmo: 40, 
                            pellets: 24, 
                            spread: 0.2, 
                            speed: 1,
                            recoil: 0.5  // Stronger recoil for shotgun
                        },
                        machinegun: { 
                            damage: 15, 
                            cooldown: 100, 
                            ammo: 100, 
                            maxAmmo: 200, 
                            speed: 1,
                            recoil: 0.2  // Small but rapid recoil
                        },
                        rocketLauncher: { 
                            damage: 40, 
                            explosionDamage: 80, 
                            explosionRadius: 5, 
                            selfDamage: 20,
                            cooldown: 1000, 
                            ammo: 20, 
                            maxAmmo: 60, 
                            speed: 0.7,
                            recoil: 0.4  // Strong recoil for rocket launcher
                        },
                        railgun: {
                            damage: 100,
                            cooldown: 1500,
                            ammo: 20,
                            maxAmmo: 60,
                            beamColor: 0x00ffff,
                            beamDuration: 500,
                            piercing: true,
                            recoil: 0.9  // Medium recoil for railgun
                        }
                    },
                    powerupSpawnTime: 15000, // 15 seconds between powerup spawns
                    powerupDuration: 15000,   // 15 seconds for temporary powerups
                };

                // Initialize game based on mode
                if (this.gameMode === 'testing') {
                    // Override config for testing mode
                    this.config.mazeSize = 10;
                }

                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
                document.body.appendChild(this.renderer.domElement);

                // Create and add the weapon container to the camera AFTER camera is created
                this.weaponContainer = new THREE.Group();
                this.camera.add(this.weaponContainer);
                this.scene.add(this.camera);

                // Set weapon container and its children to always render last
                this.weaponContainer.renderOrder = 999;
                this.weaponContainer.children.forEach(child => {
                    child.renderOrder = 999;
                });

                this.weaponModels = {};
                this.weaponScene = new THREE.Scene();
                this.weaponCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 2);

                this.state = {
                    health: 100,
                    ammo: this.config.startingAmmo,
                    isGrounded: true,
                    velocity: new THREE.Vector3(0, 0, 0),
                    lastShootTime: 0,
                    isReloading: false,
                    level: 1,
                    isPaused: false,
                    isMouseDown: false,
                    isGameOver: false,
                    currentWeapon: 'pistol',
                    lastUsedWeapon: null,  // Add this line to track last used weapon
                    weapons: {
                        grapplingHook: { owned: true, ammo: Infinity, lastShotTime: 0 },
                        pistol: { owned: true, ammo: Infinity, lastShotTime: 0 },
                        shotgun: { owned: false, ammo: 0, lastShotTime: 0 },
                        machinegun: { owned: false, ammo: 0, lastShotTime: 0 },
                        rocketLauncher: { owned: false, ammo: 0, lastShotTime: 0 },
                        railgun: { owned: false, ammo: 0, lastShotTime: 0 }
                    },
                    grappling: {
                        isHooked: false,
                        hookPoint: null,
                        hook: null,
                        swingVelocity: new THREE.Vector3(0, 0, 0),
                        lastPullDirection: new THREE.Vector3(0, 0, 0)
                    },
                    powerups: {
                        speed: { active: false, endTime: 0 },
                        invincibility: { active: false, endTime: 0 }
                    },
                    lastShotTime: 0,
                    isZoomed: false,
                    normalFOV: 75,
                    zoomFOV: 20,
                    mouseMovement: { x: 0, y: 0 },
                    isRecoiling: false,
                    recoil: {
                        current: 0,
                        recovery: 0.1,  // How fast recoil recovers
                        recoveryDelay: 50,  // Slight delay before recovery starts
                        lastShootTime: 0
                    },
                    weaponBob: {
                        offset: new THREE.Vector3(0, 0, 0),
                        time: 0,
                        intensity: 0.03
                    }
                };

                this.walls = [];

                this.monsters = [];
                this.powerups = [];
                this.projectiles = [];
                this.jumpVelocity = 0;
                this.isJumping = false;
                this.setupScene();
                this.setupLighting();
                this.createLevel();
                this.setupControls();
                this.setupAudio();
                this.setupMinimap();
                this.spawnInitialMonsters();
                this.setupWeapons();
                this.setupPowerupSpawner();
                this.setupMouseControls();
                this.setupWeaponPanel();
                this.animate();
                this.spawnInitialWeapons();
                this.setupSoldierFace();
            }

            setupScene() {
                // Remove these lines since we already created them in constructor
                // this.scene = new THREE.Scene();
                // this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                
                this.renderer.setClearColor(0x000000);
                document.getElementById('game-container').appendChild(this.renderer.domElement);
            }

            setupLighting() {
                // Ambient light for general illumination
                const ambient = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambient);

                // Main directional light (like sun)
                const directional = new THREE.DirectionalLight(0xffffff, 0.8);
                directional.position.set(5, 10, 5);
                this.scene.add(directional);

                // Player point light
                const pointLight = new THREE.PointLight(0xffffff, 0.8, 10);
                this.camera.add(pointLight);
                this.scene.add(this.camera);

                // Disable shadow mapping
                this.renderer.shadowMap.enabled = false;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
            }

            generateMaze() {
                if (this.gameMode === 'testing') {
                    // Create empty map for testing mode
                    const maze = Array(this.config.mazeSize).fill().map(() => Array(this.config.mazeSize).fill(0));
                    
                    // Add border walls only
                    for (let i = 0; i < this.config.mazeSize; i++) {
                        maze[0][i] = 1;
                        maze[this.config.mazeSize-1][i] = 1;
                        maze[i][0] = 1;
                        maze[i][this.config.mazeSize-1] = 1;
                    }
                    return maze;
                } else {
                    const maze = Array(this.config.mazeSize).fill().map(() => Array(this.config.mazeSize).fill(1));
                    
                    function primMaze(maze) {
                        const frontiers = [];
                        const startX = Math.floor(maze.length / 2);
                        const startZ = Math.floor(maze[0].length / 2);
                        
                        maze[startX][startZ] = 0;
                        
                        // Modified to create larger corridors
                        function addFrontiers(x, z) {
                            const dirs = [[0, 3], [3, 0], [0, -3], [-3, 0]]; // Increased step size
                            dirs.forEach(([dx, dz]) => {
                                const nx = x + dx;
                                const nz = z + dz;
                                if (nx >= 0 && nx < maze.length && nz >= 0 && nz < maze[0].length && maze[nx][nz] === 1) {
                                    frontiers.push([nx, nz]);
                                }
                            });
                        }
                        
                        addFrontiers(startX, startZ);
                        
                        while (frontiers.length > 0) {
                            const randIndex = Math.floor(Math.random() * frontiers.length);
                            const [fx, fz] = frontiers[randIndex];
                            frontiers.splice(randIndex, 1);
                            
                            const neighbors = [];
                            const dirs = [[0, 3], [3, 0], [0, -3], [-3, 0]]; // Increased step size
                            dirs.forEach(([dx, dz]) => {
                                const nx = fx + dx;
                                const nz = fz + dz;
                                if (nx >= 0 && nx < maze.length && nz >= 0 && nz < maze[0].length && maze[nx][nz] === 0) {
                                    neighbors.push([nx, nz]);
                                }
                            });
                            
                            if (neighbors.length > 0) {
                                const [nx, nz] = neighbors[Math.floor(Math.random() * neighbors.length)];
                                // Clear path between points
                                const dx = (fx - nx) / 3;
                                const dz = (fz - nz) / 3;
                                for (let i = 0; i <= 3; i++) {
                                    const x = nx + dx * i;
                                    const z = nz + dz * i;
                                    maze[Math.floor(x)][Math.floor(z)] = 0;
                                }
                                addFrontiers(fx, fz);
                            }
                        }
                        
                        // Create more open spaces by strategically removing walls
                        for (let x = 1; x < maze.length - 1; x++) {
                            for (let z = 1; z < maze[0].length - 1; z++) {
                                if (maze[x][z] === 1) {
                                    // Count adjacent empty spaces
                                    let emptyNeighbors = 0;
                                    for (let dx = -1; dx <= 1; dx++) {
                                        for (let dz = -1; dz <= 1; dz++) {
                                            if (dx === 0 && dz === 0) continue;
                                            if (maze[x + dx]?.[z + dz] === 0) emptyNeighbors++;
                                        }
                                    }
                                    
                                    // Remove walls that would create nice open areas
                                    if (emptyNeighbors >= 5) { // If most neighbors are empty
                                        maze[x][z] = 0;
                                    }
                                    // Keep walls that form continuous lines
                                    else if (
                                        (maze[x-1]?.[z] === 1 && maze[x+1]?.[z] === 1) || // Horizontal wall
                                        (maze[x]?.[z-1] === 1 && maze[x]?.[z+1] === 1)    // Vertical wall
                                    ) {
                                        // 80% chance to keep continuous walls
                                        if (Math.random() > 0.2) maze[x][z] = 1;
                                    }
                                    // Remove isolated walls
                                    else if (emptyNeighbors >= 7) {
                                        maze[x][z] = 0;
                                    }
                                }
                            }
                        }
                        
                        // Ensure starting area is clear with a larger radius
                        for (let dx = -2; dx <= 2; dx++) {
                            for (let dz = -2; dz <= 2; dz++) {
                                const x = startX + dx;
                                const z = startZ + dz;
                                if (x >= 0 && x < maze.length && z >= 0 && z < maze[0].length) {
                                    maze[x][z] = 0;
                                }
                            }
                        }
                    }
                    
                    primMaze(maze);
                    
                    // Ensure border walls remain
                    for (let i = 0; i < this.config.mazeSize; i++) {
                        maze[0][i] = 1;
                        maze[this.config.mazeSize-1][i] = 1;
                        maze[i][0] = 1;
                        maze[i][this.config.mazeSize-1] = 1;
                    }
                    
                    return maze;
                }
            }

            createLevel() {
                this.maze = this.generateMaze();
                
                // Clear existing level geometry
                this.walls = [];
                this.scene.children = this.scene.children.filter(child => {
                    if (child.userData && child.userData.isWall) {
                        return false;
                    }
                    return true;
                });

                // Load textures
                const textureLoader = new THREE.TextureLoader();
                
                // Floor textures
                const floorColorTexture = textureLoader.load('textures/floor/Tiles090_1K-JPG_Color.jpg');
                const floorNormalTexture = textureLoader.load('textures/floor/Tiles090_1K-JPG_NormalGL.jpg');
                const floorRoughnessTexture = textureLoader.load('textures/floor/Tiles090_1K-JPG_Roughness.jpg');
                const floorAoTexture = textureLoader.load('textures/floor/Tiles090_1K-JPG_AmbientOcclusion.jpg');
                
                // Wall textures
                const wallColorTexture = textureLoader.load('textures/wall/Tiles115_1K-JPG_Color.jpg');
                const wallNormalTexture = textureLoader.load('textures/wall/Tiles115_1K-JPG_NormalGL.jpg');
                const wallRoughnessTexture = textureLoader.load('textures/wall/Tiles115_1K-JPG_Roughness.jpg');
                const wallAoTexture = textureLoader.load('textures/wall/Tiles115_1K-JPG_AmbientOcclusion.jpg');
                
                // Configure texture repeat based on maze size
                const repeatFactor = this.config.mazeSize / 2;
                [floorColorTexture, floorNormalTexture, floorRoughnessTexture, floorAoTexture].forEach(texture => {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(repeatFactor, repeatFactor);
                });
                
                [wallColorTexture, wallNormalTexture, wallRoughnessTexture, wallAoTexture].forEach(texture => {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(1, 1);
                });

                // Create floor with textured material
                const floorGeometry = new THREE.PlaneGeometry(
                    this.config.mazeSize * this.config.cellSize, 
                    this.config.mazeSize * this.config.cellSize
                );
                const floorMaterial = new THREE.MeshStandardMaterial({ 
                    map: floorColorTexture,
                    normalMap: floorNormalTexture,
                    roughnessMap: floorRoughnessTexture,
                    aoMap: floorAoTexture,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = false;
                // Set UV2 for aoMap
                floor.geometry.setAttribute('uv2', floor.geometry.attributes.uv);
                this.scene.add(floor);

                // Create wall geometry and textured material
                const wallGeometry = new THREE.BoxGeometry(
                    this.config.cellSize, 
                    4, 
                    this.config.cellSize
                );
                const wallMaterial = new THREE.MeshStandardMaterial({ 
                    map: wallColorTexture,
                    normalMap: wallNormalTexture,
                    roughnessMap: wallRoughnessTexture,
                    aoMap: wallAoTexture,
                    roughness: 0.7,
                    metalness: 0.3
                });
                
                // Set geometry UVs for proper texture mapping
                wallGeometry.setAttribute('uv2', wallGeometry.attributes.uv);

                // Create walls
                for (let x = 0; x < this.config.mazeSize; x++) {
                    for (let z = 0; z < this.config.mazeSize; z++) {
                        if (this.maze[x][z] === 1) {
                            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                            wall.position.set(
                                (x - this.config.mazeSize/2) * this.config.cellSize,
                                2,
                                (z - this.config.mazeSize/2) * this.config.cellSize
                            );
                            wall.castShadow = false;
                            wall.receiveShadow = false;
                            wall.userData.isWall = true;
                            wall.userData.gridX = x;
                            wall.userData.gridZ = z;
                            this.walls.push(wall);
                            this.scene.add(wall);
                        }
                    }
                }

                // Create boundary walls with same textured material
                const totalSize = this.config.mazeSize * this.config.cellSize;
                const halfSize = totalSize / 2;
                
                // North wall
                const northWall = new THREE.Mesh(
                    new THREE.BoxGeometry(totalSize + this.config.cellSize, 4, this.config.cellSize),
                    wallMaterial
                );
                northWall.position.set(0, 2, -halfSize - this.config.cellSize/2);
                northWall.userData.isWall = true;
                northWall.castShadow = false;
                northWall.receiveShadow = false;
                this.scene.add(northWall);
                this.walls.push(northWall);

                // South wall
                const southWall = new THREE.Mesh(
                    new THREE.BoxGeometry(totalSize + this.config.cellSize, 4, this.config.cellSize),
                    wallMaterial
                );
                southWall.position.set(0, 2, halfSize + this.config.cellSize/2);
                southWall.userData.isWall = true;
                southWall.castShadow = false;
                southWall.receiveShadow = false;
                this.scene.add(southWall);
                this.walls.push(southWall);

                // East wall
                const eastWall = new THREE.Mesh(
                    new THREE.BoxGeometry(this.config.cellSize, 4, totalSize + this.config.cellSize),
                    wallMaterial
                );
                eastWall.position.set(halfSize + this.config.cellSize/2, 2, 0);
                eastWall.userData.isWall = true;
                eastWall.castShadow = false;
                eastWall.receiveShadow = false;
                this.scene.add(eastWall);
                this.walls.push(eastWall);

                // West wall
                const westWall = new THREE.Mesh(
                    new THREE.BoxGeometry(this.config.cellSize, 4, totalSize + this.config.cellSize),
                    wallMaterial
                );
                westWall.position.set(-halfSize - this.config.cellSize/2, 2, 0);
                westWall.userData.isWall = true;
                westWall.castShadow = false;
                westWall.receiveShadow = false;
                this.scene.add(westWall);
                this.walls.push(westWall);

                this.findStartPosition();
            }

            findStartPosition() {
                const center = Math.floor(this.config.mazeSize / 2);
                const spawnX = (center - this.config.mazeSize/2) * this.config.cellSize;
                const spawnZ = (center - this.config.mazeSize/2) * this.config.cellSize;
                
                this.camera.position.set(spawnX, this.config.playerHeight, spawnZ);
            }

            setupControls() {
                this.keys = {};
                this.rotationX = 0;
                this.rotationY = 0;

                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    
                    if (e.code === 'Space' && !this.isJumping && !this.state.grappling.isHooked) {
                        this.jumpVelocity = 0.3;
                        this.isJumping = true;
                    }

                    if (e.key === 'Escape') {
                        // Set a flag to indicate manual pause
                        this.state.manuallyPausing = true;
                        this.togglePause();
                        // Clear the flag after a short delay
                        setTimeout(() => {
                            this.state.manuallyPausing = false;
                        }, 100);
                    }

                    // Add Q key handler for weapon switching
                    if (e.key.toLowerCase() === 'q') {
                        if (this.state.lastUsedWeapon && this.state.weapons[this.state.lastUsedWeapon].owned) {
                            // Swap current and last used weapons
                            const temp = this.state.currentWeapon;
                            this.state.currentWeapon = this.state.lastUsedWeapon;
                            this.state.lastUsedWeapon = temp;
                            this.state.lastShotTime = 0;
                            
                            // Update HUD and weapon display
                            const crosshair = document.getElementById('crosshair');
                            if (crosshair) {
                                crosshair.style.display = 'block';
                            }
                            
                            this.updateHUD();
                            this.updateWeaponPanel();
                            
                            // Play weapon switch sound
                            this.playSound(440, 0.1, 'sine', 0.2);
                        }
                    }

                    if (e.key >= '1' && e.key <= '6') {
                        const weaponIndex = parseInt(e.key) - 1;
                        const weapons = ['grapplingHook', 'pistol', 'shotgun', 'machinegun', 'rocketLauncher', 'railgun'];
                        const selectedWeapon = weapons[weaponIndex];
                        
                        // Check if weapon is owned AND either it's pistol/grapplingHook (infinite ammo) or it has ammo
                        if (this.state.weapons[selectedWeapon] && 
                            this.state.weapons[selectedWeapon].owned && 
                            (selectedWeapon === 'pistol' || selectedWeapon === 'grapplingHook' || this.state.weapons[selectedWeapon].ammo > 0)) {
                            // Update last used weapon before switching
                            if (selectedWeapon !== this.state.currentWeapon) {
                                this.state.lastUsedWeapon = this.state.currentWeapon;
                            }
                            this.state.currentWeapon = selectedWeapon;
                            this.state.lastShotTime = 0;
                            console.log(`Switched to ${selectedWeapon}, ammo: ${this.state.weapons[selectedWeapon].ammo}`);
                            
                            const crosshair = document.getElementById('crosshair');
                            if (crosshair) {
                                crosshair.style.display = 'block';
                            }
                            
                            this.updateHUD();
                            this.updateWeaponPanel();
                            
                            // Play weapon switch sound
                            this.playSound(440, 0.1, 'sine', 0.2);
                        } else if (this.state.weapons[selectedWeapon] && 
                                  this.state.weapons[selectedWeapon].owned && 
                                  this.state.weapons[selectedWeapon].ammo <= 0) {
                            // Play empty click sound if trying to select a weapon with no ammo
                            this.playSound(110, 0.1, 'square', 0.05);
                        }
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });

                document.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        this.state.isMouseDown = true;
                        this.shoot();
                    }
                });

                document.addEventListener('mouseup', (e) => {
                    if (e.button === 0) {
                        this.state.isMouseDown = false;
                    }
                });

                // Handle pointer lock
                const gameContainer = document.getElementById('game-container');
                gameContainer.addEventListener('click', () => {
                    if (!document.pointerLockElement && !this.state.isPaused) {
                        gameContainer.requestPointerLock().catch(err => {
                            console.warn("Pointer lock request failed:", err);
                        });
                    }
                });

                // Handle pointer lock change
                document.addEventListener('pointerlockchange', () => {
                    const gameContainer = document.getElementById('game-container');
                    if (document.pointerLockElement === gameContainer) {
                        console.log('Pointer lock active');
                    } else {
                        console.log('Pointer lock inactive');
                        // Only auto-pause if we're not already paused and not manually pausing
                        if (!this.state.isPaused && !this.state.manuallyPausing) {
                            this.togglePause();
                        }
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === gameContainer) {
                        // Update rotation values
                        this.rotationY -= e.movementX * 0.002;
                        this.rotationX -= e.movementY * 0.002;
                        
                        // Limit vertical rotation (up/down)
                        this.rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotationX));
                        
                        // Apply rotations separately
                        this.camera.rotation.order = 'YXZ'; // Important! Set rotation order
                        this.camera.rotation.x = this.rotationX;
                        this.camera.rotation.y = this.rotationY;
                        this.camera.rotation.z = 0; // Keep z-rotation at 0
                    }
                });
            }

            setupMouseControls() {
                document.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        this.state.isMouseDown = true;
                        this.shoot();
                    }
                });

                // Add mouseup event listener
                document.addEventListener('mouseup', (e) => {
                    if (e.button === 0) {
                        this.state.isMouseDown = false;
                    }
                });

                document.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
            }

            toggleZoom() {
                this.state.isZoomed = !this.state.isZoomed;
                
                // Handle scope overlay
                let scopeOverlay = document.getElementById('scope-overlay');
                if (this.state.isZoomed) {
                    this.camera.fov = this.state.zoomFOV;
                    
                    // Create scope overlay if it doesn't exist
                    if (!scopeOverlay) {
                        scopeOverlay = document.createElement('div');
                        scopeOverlay.id = 'scope-overlay';
                        scopeOverlay.style.cssText = `
                            position: fixed;
                            top: 0;
                            left: 0;
                            width: 100%;
                            height: 100%;
                            pointer-events: none;
                            z-index: 1000;
                            background: radial-gradient(
                                circle at center,
                                transparent 35%,
                                rgba(0, 0, 0, 0.95) 36%
                            );
                        `;
                        
                        // Add crosshair lines
                        const centerLine = document.createElement('div');
                        centerLine.style.cssText = `
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            width: 2px;
                            height: 40px;
                            background: black;
                        `;
                        
                        const horizontalLine = document.createElement('div');
                        horizontalLine.style.cssText = `
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            width: 40px;
                            height: 2px;
                            background: black;
                        `;
                        
                        scopeOverlay.appendChild(centerLine);
                        scopeOverlay.appendChild(horizontalLine);
                        document.body.appendChild(scopeOverlay);
                    }
                    scopeOverlay.style.display = 'block';
                    
                    // Hide regular crosshair
                    const crosshair = document.getElementById('crosshair');
                    if (crosshair) {
                        crosshair.style.display = 'none';
                    }
                } else {
                    this.camera.fov = this.state.normalFOV;
                    if (scopeOverlay) {
                        scopeOverlay.style.display = 'none';
                    }
                    
                    // Show regular crosshair only if not using railgun
                    const crosshair = document.getElementById('crosshair');
                    if (crosshair) {
                        crosshair.style.display = this.state.currentWeapon !== 'railgun' ? 'block' : 'none';
                    }
                }
                this.camera.updateProjectionMatrix();
            }

            checkCollision(position, isMonster = false, isProjectile = false, customRadius = null) {
                // For monsters, use their specific collision radius
                const radius = customRadius ?? 
                    (isProjectile ? 0.1 : 0.3);
                
                // Check collision with each wall
                for (const wall of this.walls) {
                    // Get wall boundaries
                    const wallHalfSize = this.config.cellSize / 2;
                    const wallMinX = wall.position.x - wallHalfSize;
                    const wallMaxX = wall.position.x + wallHalfSize;
                    const wallMinZ = wall.position.z - wallHalfSize;
                    const wallMaxZ = wall.position.z + wallHalfSize;
                    
                    // Find closest point on wall to position
                    const closestX = Math.max(wallMinX, Math.min(position.x, wallMaxX));
                    const closestZ = Math.max(wallMinZ, Math.min(position.z, wallMaxZ));
                    
                    // Calculate distance from closest point
                    const dx = position.x - closestX;
                    const dz = position.z - closestZ;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    // Check if distance is less than collision radius
                    if (distance < radius) {
                        return true;
                    }
                }

                // Monster-player collision check
                if (isMonster) {
                    const dx = position.x - this.camera.position.x;
                    const dz = position.z - this.camera.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    const monsterRadius = position.userData && position.userData.instance ? 
                        position.userData.instance.collisionRadius : 0.2;
                    if (distance < monsterRadius + 0.3) return true;
                } else {
                    // Check monster collisions for player
                    for (const monster of this.monsters) {
                        const dx = position.x - monster.position.x;
                        const dz = position.z - monster.position.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        if (distance < radius + 0.2) return true;
                    }
                }
                
                return false;
            }

            updatePlayer() {
                if (this.state.isPaused) return;

                // Handle player knockback
                if (this.playerKnockback && this.playerKnockbackTime) {
                    const elapsedTime = Date.now() - this.playerKnockbackTime;
                    const progress = Math.min(elapsedTime / this.playerKnockbackDuration, 1.0);
                    
                    if (progress < 1.0) {
                        // Calculate knockback strength based on time (starts strong, diminishes)
                        const strength = (1.0 - progress) * 0.2;
                        
                        // Test X position first
                        const testPosX = this.camera.position.clone();
                        testPosX.x += this.playerKnockback.x * strength;
                        
                        // Only apply if no collision
                        if (!this.checkCollision(testPosX)) {
                            this.camera.position.x = testPosX.x;
                        }
                        
                        // Test Z position next
                        const testPosZ = this.camera.position.clone();
                        testPosZ.z += this.playerKnockback.z * strength;
                        
                        // Only apply if no collision
                        if (!this.checkCollision(testPosZ)) {
                            this.camera.position.z = testPosZ.z;
                        }
                    } else {
                        // Clear knockback after duration
                        this.playerKnockback = null;
                        this.playerKnockbackTime = null;
                    }
                }

                // Handle jumping and grappling-related movement
                if (this.isJumping) {
                    this.jumpVelocity -= 0.015;  // Apply gravity
                    this.camera.position.y += this.jumpVelocity;

                    // Check if we've hit the ground
                    if (this.camera.position.y <= this.config.playerHeight) {
                        this.camera.position.y = this.config.playerHeight;
                        this.jumpVelocity = 0;
                        this.isJumping = false;
                        
                        // Clear swing velocity when landing
                        this.state.grappling.swingVelocity.set(0, 0, 0);
                    }
                }

                // Apply swing velocity if we have it (applies to both hooked and non-hooked states)
                if (this.state.grappling.swingVelocity.lengthSq() > 0) {
                    const newPosition = this.camera.position.clone();
                    newPosition.x += this.state.grappling.swingVelocity.x;
                    newPosition.z += this.state.grappling.swingVelocity.z;
                    
                    // Only apply if no collision
                    if (!this.checkCollision(newPosition)) {
                        this.camera.position.x = newPosition.x;
                        this.camera.position.z = newPosition.z;
                    } else {
                        // Reset swing velocity on collision
                        this.state.grappling.swingVelocity.set(0, 0, 0);
                    }
                    
                    // Gradually reduce swing velocity
                    this.state.grappling.swingVelocity.multiplyScalar(0.98);
                }


                // Only allow normal movement when not hooked
                if (!this.state.grappling.isHooked) {
                    const moveSpeed = this.state.powerups.speed.active ? 
                        this.config.playerSpeed * 2 : 
                        this.config.playerSpeed;

                    const direction = new THREE.Vector3(0, 0, -1);
                    direction.applyQuaternion(this.camera.quaternion);
                    direction.y = 0;
                    direction.normalize();

                    const right = new THREE.Vector3(1, 0, 0);
                    right.applyQuaternion(this.camera.quaternion);
                    right.normalize();

                    const currentPos = this.camera.position.clone();
                    const newPosition = currentPos.clone();
                    let moved = false;

                    // Calculate movement vector
                    const movement = new THREE.Vector3(0, 0, 0);
                    if (this.keys.w) movement.add(direction.clone().multiplyScalar(moveSpeed));
                    if (this.keys.s) movement.sub(direction.clone().multiplyScalar(moveSpeed));
                    if (this.keys.a) movement.sub(right.clone().multiplyScalar(moveSpeed));
                    if (this.keys.d) movement.add(right.clone().multiplyScalar(moveSpeed));

                    // Try movement along X axis
                    if (movement.x !== 0) {
                        newPosition.x = currentPos.x + movement.x;
                        if (!this.checkCollision(newPosition)) {
                            this.camera.position.x = newPosition.x;
                            moved = true;
                        }
                        newPosition.x = currentPos.x; // Reset for Z movement check
                    }

                    // Try movement along Z axis
                    if (movement.z !== 0) {
                        newPosition.z = currentPos.z + movement.z;
                        if (!this.checkCollision(newPosition)) {
                            this.camera.position.z = newPosition.z;
                            moved = true;
                        }
                    }

                    // If we hit a wall, try sliding along it
                    if (!moved && movement.length() > 0) {
                        const slideDirections = [
                            new THREE.Vector3(1, 0, 0),
                            new THREE.Vector3(-1, 0, 0),
                            new THREE.Vector3(0, 0, 1),
                            new THREE.Vector3(0, 0, -1)
                        ];

                        for (const slideDir of slideDirections) {
                            const slidePos = currentPos.clone().add(slideDir.multiplyScalar(moveSpeed));
                            if (!this.checkCollision(slidePos)) {
                                this.camera.position.copy(slidePos);
                                break;
                            }
                        }
                    }
                }
            }

            createMonster(type = 'ground') {
                let monster;
                switch(type) {
                    case 'flying':
                        monster = new FlyingMonster(this);
                        break;
                    case 'archer':
                        monster = new ArcherMonster(this);
                        break;
                    case 'spider':
                        monster = new SpiderMonster(this);
                        break;
                    case 'giant':
                        monster = new GiantMonster(this);
                        break;
                    case 'charger':
                        monster = new ChargerMonster(this);
                        break;
                    default:
                        monster = new GroundMonster(this);
                        break;
                }
                monster.mesh.userData.instance = monster;
                return monster.mesh;
            }

            updateMonsters() {
                if (this.state.isPaused) return;
                
                if (!this.monsters || this.monsters.length === 0) {
                    console.log('%cNO MONSTERS TO UPDATE!', 'background: red; color: white; font-weight: bold');
                    return;
                }
                
            this.monsters.forEach((monsterMesh, index) => {
                if (!monsterMesh) return;
                
                // Find the monster instance that owns this mesh
                const monster = monsterMesh.userData.instance;
                if (!monster) return;
                
                // Update the monster
                monster.update();
                
                // Monster-monster collision avoidance
                this.monsters.forEach((otherMonsterMesh, otherIndex) => {
                    if (index === otherIndex) return;
                    const distance = monsterMesh.position.distanceTo(otherMonsterMesh.position);
                    if (distance < 0.5) { // 0.5 = 2 * radius
                        const pushDirection = monsterMesh.position.clone()
                            .sub(otherMonsterMesh.position)
                            .normalize()
                            .multiplyScalar(this.config.monsterSpeed * 0.5);
                        const pushTestPos = monsterMesh.position.clone().add(pushDirection);
                        if (!this.checkCollision(new THREE.Vector3(pushTestPos.x, monsterMesh.position.y, monsterMesh.position.z), true)) {
                            monsterMesh.position.x = pushTestPos.x;
                        }
                        if (!this.checkCollision(new THREE.Vector3(monsterMesh.position.x, monsterMesh.position.y, pushTestPos.z), true)) {
                            monsterMesh.position.z = pushTestPos.z;
                        }
                    }
                });
                            });
            }

            shoot() {
                if (this.state.isPaused) return;
                
                const currentTime = Date.now();
                const currentWeapon = this.state.currentWeapon;
                const weaponConfig = this.config.weapons[currentWeapon];
                const weaponState = this.state.weapons[currentWeapon];
                
                // Check if current weapon is out of ammo (skip check for pistol)
                if (currentWeapon !== 'pistol' && weaponState.ammo <= 0) {
                    // Find the previous weapon that has ammo
                    const weaponOrder = ['railgun', 'rocketLauncher', 'machinegun', 'shotgun', 'pistol'];
                    const currentIndex = weaponOrder.indexOf(currentWeapon);
                    
                    let newWeapon = null;
                    for (let i = currentIndex + 1; i < weaponOrder.length; i++) {
                        const weapon = weaponOrder[i];
                        if (this.state.weapons[weapon].owned && (weapon === 'pistol' || this.state.weapons[weapon].ammo > 0)) {
                            newWeapon = weapon;
                            break;
                        }
                    }
                    
                    // If we found a weapon with ammo, switch to it
                    if (newWeapon) {
                        if (newWeapon !== this.state.currentWeapon) {
                            this.state.lastUsedWeapon = this.state.currentWeapon;
                        }
                        this.state.currentWeapon = newWeapon;
                        this.updateWeaponPanel();
                        // Play weapon switch sound
                        this.playSound(440, 0.1, 'sine', 0.2);
                        return;
                    }
                    
                    // If no weapon has ammo, play empty click sound
                    this.playSound(110, 0.1, 'square', 0.05);
                    return;
                }
                
                // Check weapon-specific cooldown
                if (currentTime - weaponState.lastShotTime < weaponConfig.cooldown) {
                    return;
                }
                
                // Apply recoil
                this.state.recoil.current += weaponConfig.recoil;
                this.state.recoil.lastShootTime = currentTime;
                
                // Update weapon-specific last shot time
                weaponState.lastShotTime = currentTime;

                // Only decrease ammo for non-pistol weapons
                if (currentWeapon !== 'pistol') {
                    weaponState.ammo--;
                }
                this.updateHUD();
                
                switch (currentWeapon) {
                    case 'railgun':
                        this.fireRailgun();
                        break;
                    case 'shotgun':
                        this.fireShotgun();
                        break;
                    case 'machinegun':
                        this.fireMachinegun();
                        break;
                    case 'rocketLauncher':
                        this.fireRocket();
                        break;
                    case 'grapplingHook':
                        this.fireGrapplingHook();
                        break;
                    default:
                        this.fireBullet();
                        break;
                }
            }

            fireBullet() {
                const weaponConfig = this.config.weapons.pistol;
                
                    // Get exact direction where camera/crosshair is pointing
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                
                const bulletGroup = new THREE.Group();
                
                // Changed bullet geometry to be oriented along Z-axis
                const bulletPoints = [
                    new THREE.Vector2(0, 0),
                    new THREE.Vector2(0.05, 0),
                    new THREE.Vector2(0.05, 0.3),
                    new THREE.Vector2(0, 0.3)
                ];
                const bulletGeometry = new THREE.LatheGeometry(bulletPoints, 8);
                const bulletMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 1,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                // Rotate bullet to align with direction
                bullet.rotation.x = Math.PI / 2;
                bulletGroup.add(bullet);
            
            // Add a point light to the bullet for better visibility
                const bulletLight = new THREE.PointLight(0xffff00, 1, 3);
                bulletLight.intensity = 0.8;
                bulletGroup.add(bulletLight);
                
                // Update trail to match new bullet orientation
                const trail = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.02, 0.02, 2, 8),
                    new THREE.MeshBasicMaterial({
                        color: 0xffff00,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                trail.position.z = -1; // Position trail behind bullet
                trail.rotation.x = Math.PI / 2;
                bulletGroup.add(trail);
                
            // Position bullet at camera/gun position
                bulletGroup.position.copy(this.camera.position);
            
            // Offset from camera (moved closer to weapon position)
                bulletGroup.position.add(direction.clone().multiplyScalar(-1));
                bulletGroup.position.y -= 0.05; // Lower the spawn point to align with weapon
            

        
                // Set bullet orientation to match shooting direction
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction);
                bulletGroup.quaternion.copy(quaternion);
                
            // Store bullet data
                bulletGroup.userData = {
                    velocity: direction.clone().multiplyScalar(weaponConfig.speed),
                    distance: 0,
                    maxDistance: 100,
                    damage: weaponConfig.damage,
                    type: 'pistol',
                    prevPosition: bulletGroup.position.clone()
                };
                
                this.projectiles.push(bulletGroup);
                this.scene.add(bulletGroup);
                
            // Ensure proper rendering order
                bulletGroup.renderOrder = 0;
                bulletGroup.traverse(child => {
                    if (child.isMesh) {
                        child.renderOrder = 0;
                        child.material.depthTest = true;
                        child.material.depthWrite = true;
                    }
                });
            
            // Return the bullet for additional effects
            return bulletGroup;
            }
            fireMachinegun() {
                const weaponConfig = this.config.weapons.machinegun;
                
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                const bulletGroup = new THREE.Group();
                
                // Changed bullet geometry to be oriented along Z-axis
                const bulletGeometry = new THREE.LatheGeometry([
                    new THREE.Vector2(0, 0),
                    new THREE.Vector2(0.03, 0),
                    new THREE.Vector2(0.03, 0.4),
                    new THREE.Vector2(0, 0.4)
                ], 8);
                const bulletMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff4400,
                    emissive: 0xff4400,
                    emissiveIntensity: 1,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                // Rotate bullet to align with direction
                bullet.rotation.x = Math.PI / 2;
                bulletGroup.add(bullet);
                
                // Update trail to match new bullet orientation
                const trail = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.015, 0.015, 2, 8),
                    new THREE.MeshBasicMaterial({
                        color: 0xff4400,
                        transparent: true,
                        opacity: 0.9
                    })
                );
                trail.position.z = -1; // Position trail behind bullet
                trail.rotation.x = Math.PI / 2;
                bulletGroup.add(trail);
                
                bulletGroup.position.copy(this.camera.position);
                // Move spawn point back by 1 unit from camera
                bulletGroup.position.add(direction.clone().multiplyScalar(-1));
                bulletGroup.position.y -= 0.05; // Lower the spawn point slightly
                
                // Set bullet orientation to match shooting direction
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction);
                bulletGroup.quaternion.copy(quaternion);
                
                bulletGroup.userData = {
                    velocity: direction.clone().multiplyScalar(weaponConfig.speed),
                    distance: 0,
                    maxDistance: 100,
                    damage: weaponConfig.damage,
                    type: 'machinegun',
                    prevPosition: bulletGroup.position.clone()
                };
                
                this.projectiles.push(bulletGroup);
                this.scene.add(bulletGroup);
                
                // Rest of the collision check code remains the same
                // ... existing collision check code ...
                
                this.playSound(220, 0.05, 'square', 0.2);
            }
            fireShotgun() {
                const weaponConfig = this.config.weapons.shotgun;
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                const numPellets = weaponConfig.pellets;
                const baseSpeed = 0.4;
                const spreadAngle = Math.PI / 6; // 30 degrees cone spread
                
                // Set spawn point at camera position
                const spawnPoint = this.camera.position.clone();
                
                // Create and reuse a single geometry and material for all pellets
                const pelletGeometry = new THREE.SphereGeometry(0.05, 4, 4);
                const pelletMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.8
                });

                // Play shotgun sound
                this.playSound(80, 0.2, 'square', 0.3);
                this.playSound(40, 0.3, 'sawtooth', 0.2);
                
                // Create a muzzle flash
                const muzzleFlash = new THREE.PointLight(0xff6600, 3, 5);
                muzzleFlash.position.copy(spawnPoint);
                this.scene.add(muzzleFlash);
                setTimeout(() => this.scene.remove(muzzleFlash), 100);
                
                // Define the base direction and perpendicular vectors for the cone
                const forward = direction.clone().normalize();
                const up = new THREE.Vector3(0, 1, 0);
                const right = new THREE.Vector3().crossVectors(forward, up).normalize();
                const coneUp = new THREE.Vector3().crossVectors(right, forward).normalize();
                
                // Create pellets in a cone pattern
                for (let i = 0; i < numPellets; i++) {
                    const pellet = new THREE.Mesh(pelletGeometry, pelletMaterial);
                    
                    // Position all pellets at the same starting point
                    pellet.position.copy(spawnPoint);
                    
                    // Calculate a random direction within the cone
                    // Random angle around the cone
                    const angleAround = Math.random() * Math.PI * 2;
                    // Random spread angle (smaller near center for denser pattern in middle)
                    const spreadMagnitude = Math.pow(Math.random(), 0.5) * spreadAngle;
                    
                    // Create the pellet direction vector using cone angles
                    const pelletDirection = forward.clone();
                    
                    // Add spread in both perpendicular directions
                    pelletDirection.add(
                        right.clone().multiplyScalar(Math.sin(spreadMagnitude) * Math.cos(angleAround))
                    );
                    pelletDirection.add(
                        coneUp.clone().multiplyScalar(Math.sin(spreadMagnitude) * Math.sin(angleAround))
                    );
                    
                    // Normalize to get the final direction
                    pelletDirection.normalize();
                    
                    // Slightly vary the speed of each pellet
                    //const pelletSpeed = baseSpeed * (0.9 + Math.random() * 0.2);
                    
                    // Set up pellet properties
                    pellet.userData = {
                        velocity: pelletDirection.multiplyScalar(weaponConfig.speed),
                        distance: 0,
                        maxDistance: 30,
                        damage: weaponConfig.damage,
                        type: 'shotgun',
                        prevPosition: pellet.position.clone(),
                        spawnTime: Date.now()
                    };
                    
                    this.projectiles.push(pellet);
                    this.scene.add(pellet);
                }

                // Add screen shake for shotgun recoil
                this.addScreenShake(0.15, 150);
                
                // Apply stronger kickback for shotgun
                this.state.recoil.current += this.config.weapons.shotgun.recoil * 1.2;
            }

            fireRocket() {
                const weaponConfig = this.config.weapons.rocketLauncher;
                
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                const rocketGroup = new THREE.Group();
                
                const bodyGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x444444,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                
                const noseGeometry = new THREE.ConeGeometry(0.1, 0.2, 8);
                const noseMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x666666,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const nose = new THREE.Mesh(noseGeometry, noseMaterial);
                nose.position.y = 0.5;
                
                const finGeometry = new THREE.BoxGeometry(0.3, 0.02, 0.15);
                const finMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                
                for (let i = 0; i < 4; i++) {
                    const fin = new THREE.Mesh(finGeometry, finMaterial);
                    fin.position.set(0.15 * Math.cos(i * Math.PI/2), -0.4, 0.15 * Math.sin(i * Math.PI/2));
                    fin.rotation.z = i * Math.PI/2;
                    rocketGroup.add(fin);
                }
                
                rocketGroup.add(body);
                rocketGroup.add(nose);
                
                const engineGlow = new THREE.PointLight(0xff6600, 2, 2);
                engineGlow.position.y = -0.4;
                rocketGroup.add(engineGlow);
                
                // Move spawn point forward by 2 units from camera instead of backward
                rocketGroup.position.copy(this.camera.position);
                rocketGroup.position.add(direction.clone().multiplyScalar(0));
                rocketGroup.position.y -= 0.2; // Lower the spawn point slightly
                
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
                rocketGroup.quaternion.copy(quaternion);
                
                // Add a small delay before the rocket becomes "armed" and can explode
                rocketGroup.userData = {
                    velocity: direction.clone().multiplyScalar(weaponConfig.speed),
                    distance: 0,
                    maxDistance: 50,
                    damage: weaponConfig.damage,
                    type: 'rocketLauncher',
                    isRocket: true,
                    prevPosition: rocketGroup.position.clone()
                };
                
                this.projectiles.push(rocketGroup);
                this.scene.add(rocketGroup);
                
                // In the fireRocket method, add these lines after creating the rocketGroup:
                rocketGroup.renderOrder = 0;
                rocketGroup.traverse(child => {
                    if (child.isMesh) {
                        child.renderOrder = 0;
                        child.material.depthTest = true;
                        child.material.depthWrite = true;
                    }
                });
            }

            createExplosion(position) {
                const weaponConfig = this.config.weapons.rocketLauncher;
                
                // Visual explosion
                const explosionGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const explosionMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.8
                });
                const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                explosion.position.copy(position);
                this.scene.add(explosion);
                
                // Add point light
                const light = new THREE.PointLight(0xff6600, 5, weaponConfig.explosionRadius);
                light.position.copy(position);
                this.scene.add(light);
                
                // Animate expansion and fade out
                let scale = 1;
                const expandInterval = setInterval(() => {
                    scale += 0.5;
                    explosion.scale.set(scale, scale, scale);
                    explosionMaterial.opacity -= 0.1;
                    
                    if (scale >= 5) {
                        clearInterval(expandInterval);
                        this.scene.remove(explosion);
                        this.scene.remove(light);
                    }
                }, 50);
                
                // Damage monsters in radius
                this.monsters.forEach(monster => {
                    const distance = monster.position.distanceTo(position);
                    if (distance < weaponConfig.explosionRadius) {
                        // Calculate damage falloff based on distance
                        const damageFactor = 1 - (distance / weaponConfig.explosionRadius);
                        const damage = Math.floor(weaponConfig.explosionDamage * damageFactor);
                        this.damageMonster(monster, damage);
                    }
                });
                
                // Self damage if player is close
                const distanceToPlayer = this.camera.position.distanceTo(position);
                if (distanceToPlayer < weaponConfig.explosionRadius * 0.7 && !this.state.powerups.invincibility.active) {
                    const damageFactor = 1 - (distanceToPlayer / (weaponConfig.explosionRadius * 0.7));
                    const damage = Math.floor(weaponConfig.selfDamage * damageFactor);
                    this.state.health -= damage;
                    
                    // Visual feedback for self damage
                    document.body.style.backgroundColor = 'rgba(255,0,0,0.3)';
                    setTimeout(() => {
                        document.body.style.backgroundColor = 'transparent';
                    }, 100);
                    
                    // Add these lines to update the health display
                    this.updateHUD();
                    this.updateHealthBar();
                    this.updateSoldierFace();
                    
                    if (this.state.health <= 0) {
                        this.gameOver();
                    }
                }
            }

            damageMonster(monsterMesh, damage, distance) {
                // Get the monster instance
                const monster = monsterMesh.userData.instance;
                if (!monster) return;

                // Apply damage
                const isDead = monster.takeDamage(damage);
                
                // Store original colors if not already stored
                if (!monsterMesh.userData.originalColors) {
                    monsterMesh.userData.originalColors = new Map();
                    monsterMesh.traverse(child => {
                        if (child.isMesh && child.material && child.material.color) {
                            monsterMesh.userData.originalColors.set(child.uuid, {
                                color: child.material.color.clone(),
                                emissiveIntensity: child.material.emissiveIntensity || 0
                            });
                        }
                    });
                }
                
                // Visual feedback - flash red
                monsterMesh.traverse(child => {
                    if (child.isMesh && child.material) {
                        child.material.color.setHex(0xff0000);
                        child.material.emissiveIntensity = 1.0;
                        child.material.needsUpdate = true;
                    }
                });
                
                // Create hit impact effect
                const impactGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const impactMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.8
                });
                const impact = new THREE.Mesh(impactGeometry, impactMaterial);
                
                // Position impact at hit point
                impact.position.copy(monsterMesh.position);
                impact.position.y = monsterMesh instanceof FlyingMonster ? monster.baseHeight : 1.2;
                this.scene.add(impact);
                
                // Create blood particles
                const particleCount = Math.min(10, Math.ceil(damage / 5));
                for (let i = 0; i < particleCount; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05, 4, 4),
                        new THREE.MeshBasicMaterial({
                            color: monster instanceof FlyingMonster ? 0x0000ff : 0x990000,
                            transparent: true,
                            opacity: 0.9
                        })
                    );
                
                    particle.position.copy(impact.position);
                    particle.position.x += (Math.random() - 0.5) * 0.2;
                    particle.position.y += (Math.random() - 0.5) * 0.2;
                    particle.position.z += (Math.random() - 0.5) * 0.2;
                    
                    particle.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.1,
                            Math.random() * 0.1,
                            (Math.random() - 0.5) * 0.1
                        ),
                        life: 20 + Math.random() * 20
                    };
                
                    this.scene.add(particle);
                    if (!this.bloodParticles) this.bloodParticles = [];
                    this.bloodParticles.push(particle);
                }
                
                // Play hit sound effect
                this.playSound(300 + Math.random() * 100, 0.1, 'sawtooth', 0.2);
                
                // Reset visual effects after short delay
                setTimeout(() => {
                    monsterMesh.traverse(child => {
                        if (child.isMesh && child.material) {
                            const originalData = monsterMesh.userData.originalColors.get(child.uuid);
                            if (originalData) {
                                child.material.color.copy(originalData.color);
                                child.material.emissiveIntensity = originalData.emissiveIntensity;
                                child.material.needsUpdate = true;
                            }
                        }
                    });
                    
                    this.scene.remove(impact);
                }, 150);
                
                // Handle monster death
                if (isDead) {
                    // Store the position and type before removing the monster
                    const deathPosition = monsterMesh.position.clone();
                    let monsterType = 'ground';  // default type
                    
                    // Determine monster type
                    if (monster instanceof FlyingMonster) {
                        monsterType = 'flying';
                    } else if (monster instanceof SpiderMonster) {
                        monsterType = 'spider';
                    } else if (monster instanceof ChargerMonster) {
                        monsterType = 'charger';
                    } else if (monster instanceof ArcherMonster) {
                        monsterType = 'ground';  // Archer uses ground death effect
                    }
                    
                    this.createMonsterDeathEffect(deathPosition, monsterType);
                    this.scene.remove(monsterMesh);
                    const index = this.monsters.indexOf(monsterMesh);
                    if (index > -1) {
                        this.monsters.splice(index, 1);
                        console.log(`${monsterType} monster killed!`);
                    }
                    
                    this.sounds.enemyDeath.play();
                    
                    // Spawn a new monster from the queue if available
                    if (this.monsterQueue && this.monsterQueue.length > 0) {
                        const newMonsterType = this.monsterQueue.shift();
                        const newMonster = this.createMonster(newMonsterType);
                        this.monsters.push(newMonster);
                        this.scene.add(newMonster);
                        console.log(`Spawned new ${newMonsterType} monster from queue. Remaining in queue: ${this.monsterQueue.length}`);
                    }
                    
                    // Update the total remaining count (active + queued)
                    this.state.enemiesRemaining = (this.monsterQueue ? this.monsterQueue.length : 0) + this.monsters.length;
                    document.getElementById('enemies').textContent = this.state.enemiesRemaining;
                    
                    if (this.monsters.length === 0 && this.gameMode !== 'testing') {
                        // Only progress to next level in normal mode
                        console.log("Level complete!");
                        this.nextLevel();
                    }
                }
                
                this.updateSoldierFace();
            }

            createMonsterDeathEffect(position, monsterType = 'ground') {
                // Create death blood splatter with type-specific color
                const deathColors = {
                    ground: 0x990000,    // Red blood for ground monsters
                    flying: 0x0000ff,    // Blue for flying monsters
                    spider: 0x00ff00,    // Green for spiders
                    charger: 0x882222    // Dark red for charger (rhino-like creature)
                };

                const deathColor = deathColors[monsterType] || deathColors.ground;
                
                const deathGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                const deathMaterial = new THREE.MeshBasicMaterial({
                    color: deathColor,
                    transparent: true,
                    opacity: 0.9
                });
                const deathEffect = new THREE.Mesh(deathGeometry, deathMaterial);
                deathEffect.position.copy(position);
                deathEffect.position.y += 1.0;
                this.scene.add(deathEffect);
                
                // Define corpse configurations for different monster types
                const monsterConfigs = {
                    ground: {
                        parts: [
                            {
                                name: 'head',
                                geometry: new THREE.BoxGeometry(0.4, 0.4, 0.4),
                                position: new THREE.Vector3(0, 2.1, 0),
                                material: {
                                    color: 0xaa0000,
                                    emissive: 0x330000,
                                    emissiveIntensity: 0.5
                                }
                            },
                            {
                                name: 'torso',
                                geometry: new THREE.BoxGeometry(0.6, 0.8, 0.3),
                                position: new THREE.Vector3(0, 1.5, 0),
                                material: {
                                    color: 0x880000,
                                    emissive: 0x330000,
                                    emissiveIntensity: 0.5
                                }
                            },
                            {
                                name: 'leftArm',
                                geometry: new THREE.BoxGeometry(0.2, 0.6, 0.2),
                                position: new THREE.Vector3(-0.4, 1.5, 0),
                                material: {
                                    color: 0x990000,
                                    emissive: 0x330000,
                                    emissiveIntensity: 0.4
                                }
                            },
                            {
                                name: 'rightArm',
                                geometry: new THREE.BoxGeometry(0.2, 0.6, 0.2),
                                position: new THREE.Vector3(0.4, 1.5, 0),
                                material: {
                                    color: 0x990000,
                                    emissive: 0x330000,
                                    emissiveIntensity: 0.4
                                }
                            },
                            {
                                name: 'leftLeg',
                                geometry: new THREE.BoxGeometry(0.25, 0.7, 0.25),
                                position: new THREE.Vector3(-0.2, 0.85, 0),
                                material: {
                                    color: 0x770000,
                                    emissive: 0x330000,
                                    emissiveIntensity: 0.3
                                }
                            },
                            {
                                name: 'rightLeg',
                                geometry: new THREE.BoxGeometry(0.25, 0.7, 0.25),
                                position: new THREE.Vector3(0.2, 0.85, 0),
                                material: {
                                    color: 0x770000,
                                    emissive: 0x330000,
                                    emissiveIntensity: 0.3
                                }
                            }
                        ],
                        deathSound: { frequency: 80, duration: 0.3, type: 'sawtooth' }
                    },
                    flying: {
                        parts: [
                            {
                                name: 'body',
                                geometry: new THREE.SphereGeometry(0.5, 16, 16),
                                position: new THREE.Vector3(0, 0, 0),
                                material: {
                                    color: 0x000088,
                                    emissive: 0x000033,
                                    emissiveIntensity: 0.5,
                                    metalness: 0.8,
                                    roughness: 0.2
                                }
                            },
                            {
                                name: 'leftWing',
                                geometry: new THREE.BoxGeometry(2, 0.1, 0.8),
                                position: new THREE.Vector3(-0.8, 0, 0),
                                material: {
                                    color: 0x0000aa,
                                    emissive: 0x000066,
                                    emissiveIntensity: 0.3,
                                    transparent: true,
                                    opacity: 0.8
                                }
                            },
                            {
                                name: 'rightWing',
                                geometry: new THREE.BoxGeometry(2, 0.1, 0.8),
                                position: new THREE.Vector3(0.8, 0, 0),
                                material: {
                                    color: 0x0000aa,
                                    emissive: 0x000066,
                                    emissiveIntensity: 0.3,
                                    transparent: true,
                                    opacity: 0.8
                                }
                            }
                        ],
                        deathSound: { frequency: 200, duration: 0.2, type: 'sine' }
                    },
                    spider: {
                        parts: [
                            {
                                name: 'body',
                                geometry: new THREE.SphereGeometry(0.2, 16, 16),
                                position: new THREE.Vector3(0, 0.2, 0),
                                material: {
                                    color: 0x222222,
                                    roughness: 0.7,
                                    metalness: 0.3
                                }
                            }
                        ],
                        deathSound: { frequency: 300, duration: 0.2, type: 'square' },
                        particleCount: 20,
                        particleSize: 0.05,
                        particleColor: 0x00ff00,
                        particleSpeed: 0.08
                    },
                    charger: {
                        parts: [
                            {
                                name: 'body',
                                geometry: new THREE.SphereGeometry(0.9, 16, 12),
                                position: new THREE.Vector3(0, 0.7, 0),
                                material: {
                                    color: 0x403030,  // Dark brownish rhino skin
                                    roughness: 0.9,
                                    metalness: 0.2
                                }
                            },
                            {
                                name: 'head',
                                geometry: new THREE.SphereGeometry(0.5, 12, 10),
                                position: new THREE.Vector3(0, 1.3, 0.7),
                                material: {
                                    color: 0x403030,
                                    roughness: 0.9,
                                    metalness: 0.2
                                }
                            },
                            {
                                name: 'horn',
                                geometry: new THREE.ConeGeometry(0.18, 0.9, 8),
                                position: new THREE.Vector3(0, 1.5, 1.2),
                                rotation: new THREE.Vector3(Math.PI/2, 0, 0),
                                material: {
                                    color: 0x8a7a6d,  // Bone-like horn color
                                    roughness: 0.5,
                                    metalness: 0.4
                                }
                            },
                            {
                                name: 'leftEye',
                                geometry: new THREE.SphereGeometry(0.08, 8, 8),
                                position: new THREE.Vector3(-0.25, 1.45, 1.2),
                                material: {
                                    color: 0xff0000,
                                    emissive: 0xff0000,
                                    emissiveIntensity: 0.3
                                }
                            },
                            {
                                name: 'rightEye',
                                geometry: new THREE.SphereGeometry(0.08, 8, 8),
                                position: new THREE.Vector3(0.25, 1.45, 1.2),
                                material: {
                                    color: 0xff0000,
                                    emissive: 0xff0000,
                                    emissiveIntensity: 0.3
                                }
                            }
                        ],
                        deathSound: { frequency: 60, duration: 0.4, type: 'sawtooth' },
                        particleCount: 25,
                        particleSize: 0.08,
                        particleColor: 0x882222,
                        particleSpeed: 0.07
                    }
                };
                
                const config = monsterConfigs[monsterType] || monsterConfigs.ground;
                
                // Create and add each body part to the corpse
                const corpse = new THREE.Group();
                config.parts.forEach(part => {
                    const mesh = new THREE.Mesh(
                        part.geometry,
                        new THREE.MeshStandardMaterial(part.material)
                    );
                    mesh.position.copy(part.position);
                    
                    // Apply slight distortion to show damage
                    mesh.rotation.set(
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3
                    );
                    
                    corpse.add(mesh);
                });
                
                // Position the corpse at the monster location
                corpse.position.copy(position);
                
                // Set up death animation data
                corpse.userData = {
                    fallTime: 0,
                    fallSpeed: 0.03,
                    rotationSpeed: 0.05,
                    onGround: false,
                    fadeTime: 100 // Frames before starting to fade
                };
                
                this.scene.add(corpse);
                
                // Add to a list to track for animation
                if (!this.corpses) this.corpses = [];
                this.corpses.push(corpse);
                
                // Create blood/particle effects
                const particleCount = config.particleCount || 15;
                for (let i = 0; i < particleCount; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(config.particleSize || 0.08, 4, 4),
                        new THREE.MeshBasicMaterial({
                            color: config.particleColor || deathColor,
                            transparent: true,
                            opacity: 0.9
                        })
                    );
                    
                    // Position around the monster
                    particle.position.copy(position);
                    particle.position.y += 1.0 + (Math.random() - 0.5) * 0.5;
                    particle.position.x += (Math.random() - 0.5) * 0.5;
                    particle.position.z += (Math.random() - 0.5) * 0.5;
                    
                    // Random velocity - but mostly outward and downward
                    const direction = new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        Math.random() * 0.5,
                        (Math.random() - 0.5) * 2
                    ).normalize();
                    
                    particle.userData = {
                        velocity: direction.multiplyScalar(config.particleSpeed || 0.05),
                        life: 30 + Math.random() * 30
                    };
                    
                    this.scene.add(particle);
                    if (!this.bloodParticles) this.bloodParticles = [];
                    this.bloodParticles.push(particle);
                }
                
                // Play death sound
                const sound = config.deathSound;
                this.playSound(sound.frequency, sound.duration, sound.type, 0.5);
                
                // Animate death effect
                let scale = 1;
                const expandInterval = setInterval(() => {
                    scale += 0.2;
                    deathEffect.scale.set(scale, scale, scale);
                    deathMaterial.opacity -= 0.1;
                    
                    if (scale >= 3) {
                        clearInterval(expandInterval);
                        this.scene.remove(deathEffect);
                    }
                }, 50);
            }

                updateProjectiles() {
                    for (let i = this.projectiles.length - 1; i >= 0; i--) {
                        const projectile = this.projectiles[i];

                        // Store current position before moving
                        projectile.userData.prevPosition.copy(projectile.position);
                        projectile.position.add(projectile.userData.velocity);
                        projectile.userData.distance += projectile.userData.velocity.length();

                        // Check for collisions
                        let collisionOccurred = false;
                        let explosionPosition = null;

                        // Check wall collisions
                        if ((this.checkCollision(projectile.position, false, true) && 
                                projectile.userData.type !== 'railgun') || 
                            (projectile.userData.isRocket && projectile.position.y <= 0.1)) {
                            collisionOccurred = true;
                            explosionPosition = projectile.position.clone();
                        }

                        // Check for player collision if it's a monster projectile
                        if (projectile.userData.isMonsterProjectile && !this.state.powerups.invincibility.active) {
                            // Skip if this projectile has already hit something
                            if (projectile.userData.hasHit) continue;
                            
                            const distanceToPlayer = projectile.position.distanceTo(this.camera.position);
                            if (distanceToPlayer < 0.5) { // Player hit radius
                                // Mark projectile as having hit
                                projectile.userData.hasHit = true;
                                
                                // Apply damage to player
                                this.state.health -= projectile.userData.damage;
                                
                                // Visual feedback
                                document.body.style.backgroundColor = 'rgba(255,0,0,0.7)';
                                setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);
                                
                                const screenBloodOverlay = document.getElementById('screen-blood-overlay');
                                if (screenBloodOverlay) {
                                    screenBloodOverlay.style.display = 'block';
                                    screenBloodOverlay.style.opacity = '0.9';
                                    setTimeout(() => screenBloodOverlay.style.opacity = '0', 200);
                                }
                                
                                // Play hit sound
                                this.playSound(100, 0.1, 'square', 0.3);
                                this.playSound(50, 0.3, 'sawtooth', 0.3);
                                
                                // Update UI
                                this.updateHUD();
                                this.updateHealthBar();
                                this.updateSoldierFace();
                                
                                if (this.state.health <= 0) {
                                    this.gameOver();
                                }
                                
                                collisionOccurred = true;
                                continue;
                            }
                        }

                        // Check monster collisions for player projectiles
                        if (!projectile.userData.isMonsterProjectile) {
                            for (const monster of this.monsters) {
                                // Skip if this monster has already been hit by this railgun projectile
                                if (projectile.userData.type === 'railgun' && 
                                    projectile.userData.hitMonsters && 
                                    projectile.userData.hitMonsters.has(monster.uuid)) {
                                    continue;
                                }

                                // Use the monster's checkHit method to determine hit region and damage multiplier
                                const hitResult = monster.userData.instance.checkHit(projectile.position, projectile);
                                
                                if (hitResult.hit) {
                                    console.log(`HIT! Region: ${hitResult.region}, multiplier: ${hitResult.multiplier}`);
                                    
                                    // Calculate damage using the hit region's multiplier
                                    const damage = Math.ceil(projectile.userData.damage * hitResult.multiplier);
                                    
                                    if (projectile.userData.isRocket) {
                                        collisionOccurred = true;
                                        explosionPosition = projectile.position.clone();
                                        break;
                                    } else if (projectile.userData.type === 'railgun') {
                                        // Apply damage to monster
                                        this.damageMonster(monster, damage, 0);
                                        
                                        // Mark this monster as hit by this projectile to prevent multiple hits
                                        if (!projectile.userData.hitMonsters) {
                                            projectile.userData.hitMonsters = new Set();
                                        }
                                        projectile.userData.hitMonsters.add(monster.uuid);
                                        
                                        // Create hit effect for railgun
                                        const hitEffect = new THREE.Mesh(
                                            new THREE.SphereGeometry(0.1, 8, 8),
                                            new THREE.MeshBasicMaterial({
                                                color: 0x00ffff,
                                                transparent: true,
                                                opacity: 0.8
                                            })
                                        );
                                        hitEffect.position.copy(projectile.position);
                                        this.scene.add(hitEffect);
                                        setTimeout(() => this.scene.remove(hitEffect), 100);
                                        
                                        console.log(`Railgun hit monster in ${hitResult.region}, damage: ${damage}`);
                                    } else {
                                        // Apply damage to monster for regular weapons
                                        this.damageMonster(monster, damage, 0);
                                        
                                        // Create hit effect for regular weapons
                                        const hitEffect = new THREE.Mesh(
                                            new THREE.SphereGeometry(0.1, 8, 8),
                                            new THREE.MeshBasicMaterial({
                                                color: 0xff0000,
                                                transparent: true,
                                                opacity: 0.8
                                            })
                                        );
                                        hitEffect.position.copy(projectile.position);
                                        this.scene.add(hitEffect);
                                        setTimeout(() => this.scene.remove(hitEffect), 100);

                                        // Set collision for regular projectiles
                                        collisionOccurred = true;
                                        break;
                                    }
                                }
                            }
                        }

                        // Handle collision aftermath
                        if (collisionOccurred) {
                            if (projectile.userData.isRocket && explosionPosition) {
                                this.createExplosion(explosionPosition);
                            }
                            this.scene.remove(projectile);
                            this.projectiles.splice(i, 1);
                            continue;
                        }

                        // Remove projectiles that exceed max distance
                        if (projectile.userData.distance > projectile.userData.maxDistance) {
                            this.scene.remove(projectile);
                            this.projectiles.splice(i, 1);
                        }
                    }
                }

                spawnInitialMonsters() {
                    console.log('%c=== SPAWNING INITIAL MONSTERS ===', 'background: green; color: white; font-size: 14px; font-weight: bold;');
                    
                    // Clear existing monsters
                    this.monsters.forEach(monster => this.scene.remove(monster));
                    this.monsters = [];

                    if (this.gameMode === 'testing') {
                        console.log(`%cTest mode active - use spawn panel to create monsters`, 'color: lime; font-weight: bold');
                        return;
                    }

                    // Calculate total monsters for this level
                    const totalMonsters = 3 + (this.state.level - 1) * 2;
                    
                    // Initialize monster queue
                    this.monsterQueue = [];
                    
                    // Fill queue with monster types
                    for (let i = 0; i < totalMonsters; i++) {
                        let type;
                        const rand = Math.random();
                        
                        if (this.state.level < 5) {
                            // Early levels: no giants, more basic monsters
                            if (rand < 0.35) type = 'ground';
                            else if (rand < 0.6) type = 'flying';
                            else if (rand < 0.75) type = 'archer';
                            else if (rand < 0.9) type = 'spider';
                            else type = 'charger';
                        } else if (this.state.level < 10) {
                            // Mid levels: introduce giants
                            if (rand < 0.25) type = 'ground';
                            else if (rand < 0.45) type = 'flying';
                            else if (rand < 0.65) type = 'archer';
                            else if (rand < 0.8) type = 'spider';
                            else if (rand < 0.9) type = 'giant';
                            else type = 'charger';
                        } else {
                            // Later levels: more challenging monsters
                            if (rand < 0.15) type = 'ground';
                            else if (rand < 0.35) type = 'flying';
                            else if (rand < 0.55) type = 'archer';
                            else if (rand < 0.7) type = 'spider';
                            else if (rand < 0.85) type = 'giant';
                            else type = 'charger';
                        }
                        this.monsterQueue.push(type);
                    }

                    // Spawn initial wave (maximum 6 monsters)
                    const initialSpawnCount = Math.min(10, totalMonsters);
                    console.log(`%cSpawning initial wave of ${initialSpawnCount} monsters`, 'color: yellow; font-weight: bold');
                    
                    for (let i = 0; i < initialSpawnCount; i++) {
                        const type = this.monsterQueue.shift();
                        const monster = this.createMonster(type);
                        this.monsters.push(monster);
                        this.scene.add(monster);
                        console.log(`%cSpawned ${type} monster (${i + 1}/${initialSpawnCount})`, 'color: green');
                    }

                    // Update enemy count display (active + queued)
                    this.state.enemiesRemaining = this.monsterQueue.length + this.monsters.length;
                    document.getElementById('enemies').textContent = this.state.enemiesRemaining;
                    
                    console.log(`%cTotal monsters for level ${this.state.level}: ${totalMonsters} (${this.monsters.length} active, ${this.monsterQueue.length} in queue)`, 'color: lime; font-weight: bold');
                }

                animate() {
                    requestAnimationFrame(() => this.animate());
                    
                    if (!this.state.isPaused) {
                        if (this.state.isMouseDown) {
                            this.shoot();
                        }
                        
                        this.updatePlayer();
                        this.updateMonsters();
                        this.updateProjectiles();
                        this.updatePowerups();
                        this.updateMinimap();
                        this.updateWeaponPanel();
                        this.updateWeaponPosition();
                        this.updateGrapplingHook(); // Add this line
                    
                    // Update blood particles
                    if (this.bloodParticles && this.bloodParticles.length > 0) {
                        for (let i = this.bloodParticles.length - 1; i >= 0; i--) {
                            const particle = this.bloodParticles[i];
                            
                            // Apply gravity and update position
                            particle.userData.velocity.y -= 0.005;
                            particle.position.add(particle.userData.velocity);
                            
                            // Check floor collision
                            if (particle.position.y <= 0.05) {
                                particle.position.y = 0.05;
                                particle.userData.velocity.set(0, 0, 0);
                                
                                // Fade out particles on the ground
                                if (particle.material.opacity > 0.05) {
                                    particle.material.opacity -= 0.02;
                                } else {
                                    this.scene.remove(particle);
                                    this.bloodParticles.splice(i, 1);
                                }
                            } else {
                                // Reduce life counter
                                particle.userData.life--;
                                
                                // Fade out particles in air
                                if (particle.userData.life <= 10) {
                                    particle.material.opacity -= 0.1;
                                }
                                
                                // Remove dead particles
                                if (particle.userData.life <= 0) {
                                    this.scene.remove(particle);
                                    this.bloodParticles.splice(i, 1);
                                }
                            }
                        }
                    }
                    
                    // Update monster corpses
                    if (this.corpses && this.corpses.length > 0) {
                        for (let i = this.corpses.length - 1; i >= 0; i--) {
                            const corpse = this.corpses[i];
                            
                            // Increment fall time
                            corpse.userData.fallTime++;
                            
                            if (!corpse.userData.onGround) {
                                // Apply falling rotation (tipping over)
                                corpse.rotation.x += corpse.userData.rotationSpeed;
                                
                                // Apply gravity 
                                const fallDistance = corpse.userData.fallSpeed;
                                corpse.position.y -= fallDistance;
                                
                                // Check if corpse hit the ground
                                if (corpse.position.y <= 0.1 || corpse.rotation.x >= Math.PI/2) {
                                    corpse.position.y = 0.1;
                                    corpse.rotation.x = Math.PI/2; // Flat on ground
                                    corpse.userData.onGround = true;
                                    
                                    // Add small impact blood
                                    for (let j = 0; j < 5; j++) {
                                        const bloodSplat = new THREE.Mesh(
                                            new THREE.CircleGeometry(0.1 + Math.random() * 0.2, 8),
                                            new THREE.MeshBasicMaterial({
                                                color: 0x990000,
                                                transparent: true,
                                                opacity: 0.7,
                                                side: THREE.DoubleSide
                                            })
                                        );
                                        
                                        // Position on ground under corpse
                                        bloodSplat.position.copy(corpse.position);
                                        bloodSplat.position.y = 0.01; // Just above ground
                                        bloodSplat.position.x += (Math.random() - 0.5) * 0.5;
                                        bloodSplat.position.z += (Math.random() - 0.5) * 0.5;
                                        
                                        // Rotate to lie flat on ground
                                        bloodSplat.rotation.x = -Math.PI/2;
                                        
                                        // Add to scene and track
                                        this.scene.add(bloodSplat);
                                        if (!this.bloodSplats) this.bloodSplats = [];
                                        this.bloodSplats.push(bloodSplat);
                                    }
                                }
                            }
                            
                            // Fade out corpse after it's been on the ground for a while
                            if (corpse.userData.onGround && corpse.userData.fallTime > corpse.userData.fadeTime) {
                                let fadingDone = true;
                                
                                // Fade out all child meshes
                                corpse.traverse(child => {
                                    if (child.isMesh && child.material) {
                                        if (child.material.opacity > 0.05) {
                                            child.material.opacity -= 0.01;
                                            child.material.transparent = true;
                                            fadingDone = false;
                                        }
                                    }
                                });
                                
                                // Remove corpse when fully faded
                                if (fadingDone) {
                                    this.scene.remove(corpse);
                                    this.corpses.splice(i, 1);
                                }
                            }
                        }
                    }
                    
                    // Update blood splats on ground
                    if (this.bloodSplats && this.bloodSplats.length > 0) {
                        for (let i = this.bloodSplats.length - 1; i >= 0; i--) {
                            const splat = this.bloodSplats[i];
                            
                            // Very slow fade for blood splats (persist longer)
                            if (splat.material.opacity > 0.02) {
                                splat.material.opacity -= 0.001;
                            } else {
                                this.scene.remove(splat);
                                this.bloodSplats.splice(i, 1);
                            }
                        }
                    }
                    
                    // Update body parts physics
                    if (this.bodyParts && this.bodyParts.length > 0) {
                        for (let i = this.bodyParts.length - 1; i >= 0; i--) {
                            const part = this.bodyParts[i];
                            
                            // Apply gravity and update position
                            part.userData.velocity.y -= 0.01;
                            part.position.add(part.userData.velocity);
                            
                            // Apply rotation
                            if (part.userData.rotationVelocity) {
                                part.rotation.x += part.userData.rotationVelocity.x;
                                part.rotation.y += part.userData.rotationVelocity.y;
                                part.rotation.z += part.userData.rotationVelocity.z;
                            }
                            
                            // Check floor collision
                            if (part.position.y <= 0.1) {
                                part.position.y = 0.1;
                                part.userData.velocity.set(
                                    part.userData.velocity.x * 0.8, // Friction
                                    0,
                                    part.userData.velocity.z * 0.8
                                );
                                
                                // Slow down rotation on ground
                                if (part.userData.rotationVelocity) {
                                    part.userData.rotationVelocity.multiplyScalar(0.95);
                                }
                            }
                            
                            // Reduce life counter
                            part.userData.life--;
                            
                            // Fade out parts
                            if (part.userData.life <= 20) {
                                if (part.material.opacity > 0.05) {
                                    part.material.opacity -= 0.05;
                                } else {
                                    this.scene.remove(part);
                                    this.bodyParts.splice(i, 1);
                                }
                            }
                        }
                    }
                    }
                    
                    this.render();
                }

                setupAudio() {
                    try {
                        // Create local AudioContext-based sounds instead of relying on external URLs
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        
                        // Create simple audio effects using oscillators instead of external files
                        this.sounds = {
                            shoot: {
                                play: () => {
                                    this.playSound(220, 0.1, 'square');
                                }
                            },
                            reload: {
                                play: () => {
                                    this.playSound(110, 0.3, 'sawtooth');
                                }
                            },
                            enemyDeath: {
                                play: () => {
                                    this.playSound(440, 0.2, 'triangle', 0.1);
                                }
                            },
                            playerDeath: {
                                play: () => {
                                    this.playSound(55, 0.5, 'sawtooth', 0.3);
                                }
                            },
                            levelUp: {
                                play: () => {
                                    this.playSound(880, 0.3, 'sine', 0.1);
                                    setTimeout(() => this.playSound(1320, 0.3, 'sine', 0.1), 100);
                                }
                            },
                            emptyGun: {
                                play: () => {
                                    this.playSound(110, 0.1, 'square', 0.05);
                                }
                            },
                            background: {
                                play: () => {
                                    // Do nothing for background music
                                    console.log("Background music would play here");
                                },
                                pause: () => {
                                    // Do nothing for background music
                                },
                                loop: true
                            }
                        };
                        
                        console.log("Audio system initialized successfully");
                    } catch (error) {
                        console.error("Error setting up audio:", error);
                        // Fallback empty sound functions if audio setup fails
                        this.sounds = {
                            shoot: { play: () => {} },
                            reload: { play: () => {} },
                            enemyDeath: { play: () => {} },
                            playerDeath: { play: () => {} },
                            levelUp: { play: () => {} },
                            emptyGun: { play: () => {} },
                            background: { play: () => {}, pause: () => {}, loop: true }
                        };
                    }
                }

                // Helper method to play sounds using Web Audio API
                playSound(frequency, duration, type = 'square', volume = 0.2) {
                    try {
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.type = type;
                        oscillator.frequency.value = frequency;
                        oscillator.connect(gainNode);
                        
                        gainNode.connect(this.audioContext.destination);
                        gainNode.gain.value = volume;
                        
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + duration);
                    } catch (error) {
                        console.error("Error playing sound:", error);
                    }
                }

                createGunModel() {
                    // Empty method - no gun model created
                }

                togglePause() {
                    const wasAlreadyPaused = this.state.isPaused;
                    this.state.isPaused = !this.state.isPaused;
                    
                    // Find and remove ALL pause menu elements
                    const existingMenus = document.querySelectorAll('#pause-menu');
                    existingMenus.forEach(menu => menu.remove());

                    if (this.state.isPaused) {
                        // Create pause menu
                        const pauseMenu = document.createElement('div');
                        pauseMenu.id = 'pause-menu';
                        pauseMenu.style.cssText = `
                            position: fixed;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            background: rgba(0, 0, 0, 0.8);
                            color: white;
                            padding: 20px;
                            border: 2px solid white;
                            text-align: center;
                            font-family: Arial, sans-serif;
                            z-index: 1000;
                        `;

                        pauseMenu.innerHTML = `
                            <h2>GAME PAUSED</h2>
                            <h3>Controls:</h3>
                            <div style="text-align: left; margin: 20px;">
                                <div style="margin: 10px 0;">
                                    <span style="color: white;">WASD</span> - Movement
                                </div>
                                <div style="margin: 10px 0;">
                                    <span style="color: white;">1-6</span> - Select Weapons
                                </div>
                                <div style="margin: 10px 0;">
                                    <span style="color: white;">SPACEBAR</span> - Jump
                                </div>
                                <div style="margin: 10px 0;">
                                    <span style="color: white;">Q</span> - Previous Weapon
                                </div>
                            </div>
                            <h3>Power-Ups Guide:</h3>
                            <div style="text-align: left; margin: 20px;">
                                <div style="margin: 10px 0;">
                                    <span style="color: white;"></span> Health Pack: +50 HP (Max 100)
                                </div>
                                <div style="margin: 10px 0;">
                                    <span style="color: red;"></span> Speed Boost: 2x speed for 15 seconds
                                </div>
                                <div style="margin: 10px 0;">
                                    <span style="color: gold;"></span> Invincibility: Immune to damage for 15 seconds
                                </div>
                            </div>
                            <div style="margin-top: 20px;">
                                Press ESC to resume
                            </div>
                            <button onclick="window.location.reload();" style="
                            background: #ff0000;
                            color: white;
                            border: none;
                            padding: 10px 20px;
                            margin-top: 15px;
                            cursor: pointer;
                            font-size: 16px;
                            border-radius: 5px;
                        ">Restart Game</button>
                        `;

                        document.body.appendChild(pauseMenu);
                        
                        // Only exit pointer lock if we weren't already paused
                        if (!wasAlreadyPaused) {
                            document.exitPointerLock();
                        }
                    } else {
                        // Only request pointer lock if we were already paused
                        if (wasAlreadyPaused) {
                            const gameContainer = document.getElementById('game-container');
                            gameContainer.requestPointerLock().catch(err => {
                                console.warn("Pointer lock request failed:", err);
                            });
                        }
                    }
                }

                nextLevel() {
                    this.state.level++;
                    
                    // Check if player has completed all levels
                    if (this.state.level > this.config.levels.length) {
                        alert('Congratulations! You\'ve completed all 10 levels and beaten the game!');
                        window.location.reload();
                        return;
                    }
                    
                    // Get current level configuration
                    const levelConfig = this.config.levels[this.state.level - 1];
                    this.config.mazeSize = levelConfig.mazeSize;
                    
                    // Restore health to full
                    this.state.health = 100;
                    this.updateHealthBar();
                    this.updateSoldierFace();
                    
                    // Play level up sound
                    this.sounds.levelUp.play();
                    
                    // Update HUD
                    document.getElementById('level').textContent = this.state.level;
                    
                    // Clear existing level
                    this.monsters.forEach(monster => this.scene.remove(monster));
                    this.monsters = [];
                    this.powerups.forEach(powerup => this.scene.remove(powerup));
                    this.powerups = [];
                    this.projectiles.forEach(projectile => this.scene.remove(projectile));
                    this.projectiles = [];
                    
                    // Create new level with updated size
                    this.createLevel();
                    
                    // Use spawnInitialMonsters to handle monster spawning with proper distribution
                    this.spawnInitialMonsters();
                    
                    // Spawn new weapons for the level
                    this.spawnInitialWeapons();
                    
                    // Add level transition effect
                    document.body.style.backgroundColor = '#fff';
                    setTimeout(() => {
                        document.body.style.backgroundColor = 'black';
                    }, 100);
                    
                    console.log(`Starting Level ${this.state.level} - Map Size: ${this.config.mazeSize}x${this.config.mazeSize}, Enemies: ${levelConfig.enemies}`);
                }

                gameOver() {
                    // In testing mode, don't end the game when health drops to 0
                    if (this.gameMode === 'testing') {
                        console.log('Player would have died, but testing mode is active');
                        return;
                    }
                    
                    // If we're in multiplayer mode, handle respawn instead of game over
                    if (this.multiplayerEnabled) {
                        this.playerMultiplayerDeath();
                        return;
                    }
                    
                    this.state.isGameOver = true;
                    this.sounds.playerDeath.play();
                    this.sounds.background.pause();
                    document.exitPointerLock();
                    alert(`Game Over! You reached level ${this.state.level}`);
                    // Replace restart() with page reload
                    window.location.reload();
                }
                
                playerMultiplayerDeath(killerPlayerId) {
                    // Track death
                    this.state.deaths++;
                    
                    // Award kill to killer if it exists
                    if (killerPlayerId && this.otherPlayers[killerPlayerId]) {
                        // Visual notification could be added here
                    }
                    
                    // Set respawning state
                    this.state.isRespawning = true;
                    this.state.respawnEndTime = Date.now() + this.config.respawnTime;
                    
                    // Show respawn screen
                    this.showRespawnScreen();
                    
                    // Start respawn countdown
                    this.updateRespawnCountdown();
                    
                    // Hide weapon
                    this.weaponContainer.visible = false;
                    
                    // Disable controls during respawn
                    this.controlsEnabled = false;
                    
                    // Schedule respawn
                    setTimeout(() => this.respawnPlayer(), this.config.respawnTime);
                }
                
                respawnPlayer() {
                    // Find a random respawn position
                    const position = this.findRandomRespawnPosition();
                    this.camera.position.copy(position);
                    
                    // Reset player state
                    this.state.health = 100;
                    this.state.isRespawning = false;
                    this.updateHealthBar();
                    this.updateSoldierFace();
                    
                    // Show weapon again
                    this.weaponContainer.visible = true;
                    
                    // Re-enable controls
                    this.controlsEnabled = true;
                    
                    // Hide respawn screen
                    this.hideRespawnScreen();
                }
                
                findRandomRespawnPosition() {
                    // Try to find a valid position away from other players
                    let position;
                    let attempts = 0;
                    let valid = false;
                    
                    while (!valid && attempts < 100) {
                        attempts++;
                        
                        // Get a random grid position
                        const gridX = Math.floor(Math.random() * (this.config.mazeSize - 2)) + 1;
                        const gridZ = Math.floor(Math.random() * (this.config.mazeSize - 2)) + 1;
                        
                        // Convert to world coordinates
                        const x = (gridX - this.config.mazeSize/2) * this.config.cellSize;
                        const z = (gridZ - this.config.mazeSize/2) * this.config.cellSize;
                        
                        position = new THREE.Vector3(x, this.config.playerHeight, z);
                        
                        // Check if position is valid (no collision)
                        if (!this.checkCollision(position)) {
                            // Check if position is far enough from other players
                            let tooCloseToPlayer = false;
                            
                            for (const playerId in this.otherPlayers) {
                                const otherPlayer = this.otherPlayers[playerId];
                                const distance = position.distanceTo(otherPlayer.position);
                                
                                if (distance < 5) { // Keep players at least 5 units apart
                                    tooCloseToPlayer = true;
                                    break;
                                }
                            }
                            
                            if (!tooCloseToPlayer) {
                                valid = true;
                            }
                        }
                    }
                    
                    // If no valid position found after max attempts, use a default position
                    if (!valid) {
                        console.warn("Could not find valid respawn position");
                        return new THREE.Vector3(0, this.config.playerHeight, 0);
                    }
                    
                    return position;
                }
                
                setupRespawnScreen() {
                    // Create respawn overlay
                    const respawnOverlay = document.createElement('div');
                    respawnOverlay.id = 'respawn-overlay';
                    respawnOverlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background-color: rgba(0, 0, 0, 0.7);
                        color: #ff0000;
                        display: flex;
                        flex-direction: column;
                        justify-content: center;
                        align-items: center;
                        font-family: Arial, sans-serif;
                        z-index: 1000;
                        display: none;
                    `;
                    
                    // Add content to overlay
                    respawnOverlay.innerHTML = `
                        <h2 style="font-size: 32px; margin-bottom: 20px;">YOU DIED</h2>
                        <p style="font-size: 24px; margin-bottom: 30px;">Respawning in <span id="respawn-countdown">5</span> seconds</p>
                    `;
                    
                    document.body.appendChild(respawnOverlay);
                }
                
                showRespawnScreen() {
                    const respawnOverlay = document.getElementById('respawn-overlay');
                    if (respawnOverlay) {
                        respawnOverlay.style.display = 'flex';
                    }
                }
                
                hideRespawnScreen() {
                    const respawnOverlay = document.getElementById('respawn-overlay');
                    if (respawnOverlay) {
                        respawnOverlay.style.display = 'none';
                    }
                }
                
                updateRespawnCountdown() {
                    if (!this.state.isRespawning) return;
                    
                    const countdownElement = document.getElementById('respawn-countdown');
                    if (!countdownElement) return;
                    
                    const remainingTime = Math.ceil((this.state.respawnEndTime - Date.now()) / 1000);
                    countdownElement.textContent = remainingTime;
                    
                    if (remainingTime > 0) {
                        requestAnimationFrame(() => this.updateRespawnCountdown());
                    }
                }
                
                setupMultiplayer() {
                    // Add multiplayer toggle to mode selection
                    this.multiplayerEnabled = this.gameMode === 'multiplayer';
                    
                    if (this.multiplayerEnabled) {
                        // Add player IDs
                        this.playerId = 'player_' + Math.floor(Math.random() * 10000);
                        
                        // Initialize empty other players object
                        this.otherPlayers = {};
                        
                        // Update HUD for multiplayer
                        this.updateHUDForMultiplayer();
                    }
                }
                
                updateHUDForMultiplayer() {
                    const hud = document.getElementById('hud');
                    if (hud) {
                        // Add kills and deaths to HUD
                        const statsElement = document.createElement('div');
                        statsElement.id = 'multiplayer-stats';
                        statsElement.innerHTML = `
                            Kills: <span id="kills-count">0</span> | 
                            Deaths: <span id="deaths-count">0</span>
                        `;
                        hud.appendChild(statsElement);
                    }
                }
                
                updateMultiplayerStats() {
                    const killsElement = document.getElementById('kills-count');
                    const deathsElement = document.getElementById('deaths-count');
                    
                    if (killsElement) {
                        killsElement.textContent = this.state.kills;
                    }
                    
                    if (deathsElement) {
                        deathsElement.textContent = this.state.deaths;
                    }
                }

                createPowerup(type, position) {
                    let powerupMesh;

                    switch(type) {
                        case 'health':
                            // Create white box with red cross
                            const box = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                            const boxMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
                            powerupMesh = new THREE.Mesh(box, boxMaterial);

                            // Add bigger red cross
                            const crossGeometry = new THREE.BoxGeometry(0.4, 0.1, 0.6);
                            const crossMaterial = new THREE.MeshStandardMaterial({ 
                                color: 0xff0000,
                                emissive: 0xff0000,
                                emissiveIntensity: 0.5
                            });
                            const horizontalCross = new THREE.Mesh(crossGeometry, crossMaterial);
                            const verticalCross = new THREE.Mesh(crossGeometry, crossMaterial);
                            verticalCross.rotation.z = Math.PI / 2;


                            // Move crosses slightly forward to be more visible
                            horizontalCross.position.z = 0;
                            verticalCross.position.z = 0;

                            powerupMesh.add(horizontalCross);
                            powerupMesh.add(verticalCross);

                            break;

                        case 'speed':
                            // Create red shoe with wings
                            const shoeGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.6);
                            const shoeMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                            powerupMesh = new THREE.Mesh(shoeGeometry, shoeMaterial);

                            // Add wings
                            const wingGeometry = new THREE.BoxGeometry(0.1, 0.2, 0.4);
                            const wingMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
                            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                            leftWing.position.set(-0.15, 0.15, -0.25);
                            rightWing.position.set(0.15, 0.15, -0.25);
                            leftWing.rotation.x = Math.PI / 4;
                            rightWing.rotation.x = Math.PI / 4;
                            powerupMesh.add(leftWing);
                            powerupMesh.add(rightWing);
                            break;

                        case 'invincibility':
                            // Create golden shield (3D version)
                            powerupMesh = new THREE.Group();
                            
                            // Main shield body - using SphereGeometry for a 3D shield
                            const shieldBody = new THREE.Mesh(
                                new THREE.SphereGeometry(0.3, 16, 16),
                                new THREE.MeshStandardMaterial({ 
                                    color: 0xffd700,
                                    metalness: 0.7,
                                    roughness: 0.3,
                                    transparent: true,
                                    opacity: 0.6
                                })
                            );
                            
                            // Add outer glow effect
                            const outerShield = new THREE.Mesh(
                                new THREE.SphereGeometry(0.35, 16, 16),
                                new THREE.MeshStandardMaterial({ 
                                    color: 0xffd700,
                                    metalness: 0.9,
                                    roughness: 0.1,
                                    transparent: true,
                                    opacity: 0.3
                                })
                            );
                            
                            // Add shield details
                            const ring = new THREE.Mesh(
                                new THREE.TorusGeometry(0.25, 0.03, 16, 32),
                                new THREE.MeshStandardMaterial({ 
                                    color: 0xffff00,
                                    metalness: 0.8,
                                    roughness: 0.2
                                })
                            );
                            
                            // Add point light for glow effect
                            const shieldLight = new THREE.PointLight(0xffd700, 1, 2);
                            
                            powerupMesh.add(shieldBody);
                            powerupMesh.add(outerShield);
                            powerupMesh.add(ring);
                            powerupMesh.add(shieldLight);
                            break;
                            
                        case 'shotgun':
                            // Create shotgun powerup
                            powerupMesh = new THREE.Group();
                            
                            // Main body
                            const shotgunBody = new THREE.Mesh(
                                new THREE.BoxGeometry(0.1, 0.1, 0.4),
                                new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                            );
                            
                            // Pump
                            const shotgunPump = new THREE.Mesh(
                                new THREE.BoxGeometry(0.12, 0.08, 0.15),
                                new THREE.MeshStandardMaterial({ color: 0x000000 })
                            );
                            shotgunPump.position.set(0, 0, 0.15);
                            
                            // Stock
                            const shotgunStock = new THREE.Mesh(
                                new THREE.BoxGeometry(0.08, 0.12, 0.2),
                                new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                            );
                            shotgunStock.position.set(0, 0, -0.2);
                            
                            powerupMesh.add(shotgunBody);
                            powerupMesh.add(shotgunPump);
                            powerupMesh.add(shotgunStock);
                            break;
                            
                        case 'machinegun':
                            // Create machinegun powerup
                            powerupMesh = new THREE.Group();
                            
                            // Main body
                            const mgBody = new THREE.Mesh(
                                new THREE.BoxGeometry(0.1, 0.1, 0.4),
                                new THREE.MeshStandardMaterial({ color: 0x2f2f2f })
                            );
                            
                            // Barrel
                            const mgBarrel = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.03, 0.03, 0.2, 8),
                                new THREE.MeshStandardMaterial({ color: 0x1a1a1a })
                            );
                            mgBarrel.rotation.x = Math.PI / 2;
                            mgBarrel.position.set(0, 0, 0.3);
                            
                            // Magazine
                            const mgMag = new THREE.Mesh(
                                new THREE.BoxGeometry(0.08, 0.15, 0.05),
                                new THREE.MeshStandardMaterial({ color: 0x3a3a3a })
                            );
                            mgMag.position.set(0, -0.12, 0.1);
                            
                            powerupMesh.add(mgBody);
                            powerupMesh.add(mgBarrel);
                            powerupMesh.add(mgMag);
                            break;
                            
                        case 'rocketLauncher':
                            // Create rocket launcher powerup
                            powerupMesh = new THREE.Group();
                            
                            // Main tube
                            const rlTube = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.08, 0.08, 0.5, 16),
                                new THREE.MeshStandardMaterial({ color: 0x4f4f4f })
                            );
                            rlTube.rotation.z = Math.PI / 2;
                            
                            // Rear sight
                            const rlRear = new THREE.Mesh(
                                new THREE.BoxGeometry(0.12, 0.12, 0.05),
                                new THREE.MeshStandardMaterial({ color: 0x333333 })
                            );
                            rlRear.position.set(0, 0, -0.25);
                            
                            powerupMesh.add(rlTube);
                            powerupMesh.add(rlRear);
                            break;
                            
                        case 'sniper':
                            // Create sniper rifle powerup
                            powerupMesh = new THREE.Group();
                            
                            // Main body
                            const sniperBody = new THREE.Mesh(
                                new THREE.BoxGeometry(0.06, 0.08, 0.6),
                                new THREE.MeshStandardMaterial({ color: 0x222222 })
                            );
                            
                            // Scope
                            const sniperScope = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.03, 0.03, 0.15, 8),
                                new THREE.MeshStandardMaterial({ color: 0x000000 })
                            );
                            sniperScope.position.set(0, 0.08, 0.1);
                            
                            // Stock
                            const sniperStock = new THREE.Mesh(
                                new THREE.BoxGeometry(0.05, 0.12, 0.2),
                                new THREE.MeshStandardMaterial({ color: 0x663300 })
                            );
                            sniperStock.position.set(0, 0, -0.3);
                            
                            powerupMesh.add(sniperBody);
                            powerupMesh.add(sniperScope);
                            powerupMesh.add(sniperStock);
                            break;
                        case 'railgun': // Changed from sniper
                            powerupMesh = new THREE.Group();
                            
                            // Main body - more angular and sci-fi looking
                            const railBody = new THREE.Mesh(
                                new THREE.BoxGeometry(0.08, 0.12, 0.7),
                                new THREE.MeshStandardMaterial({ 
                                    color: 0x444444,
                                    metalness: 0.9,
                                    roughness: 0.2
                                })
                            );
                            
                            // Energy coils (distinctive Quake 2 railgun feature)
                            const coilGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.4, 8);
                            const coilMaterial = new THREE.MeshStandardMaterial({
                                color: 0x00ffff,
                                emissive: 0x00ffff,
                                emissiveIntensity: 0.5
                            });
                            
                            const coil1 = new THREE.Mesh(coilGeometry, coilMaterial);
                            const coil2 = new THREE.Mesh(coilGeometry, coilMaterial);
                            
                            coil1.position.set(0.06, 0, 0.1);
                            coil2.position.set(-0.06, 0, 0.1);
                            
                            // Add pulsing light to coils
                            const coilLight = new THREE.PointLight(0x00ffff, 1, 2);
                            coilLight.position.set(0, 0, 0.1);
                            
                            powerupMesh.add(railBody);
                            powerupMesh.add(coil1);
                            powerupMesh.add(coil2);
                            powerupMesh.add(coilLight);
                            break;
                    }

                    if (powerupMesh) {
                        // Position the powerup and add floating animation
                        powerupMesh.position.copy(position);
                        powerupMesh.userData = {
                            type: type,
                            rotationSpeed: 0.02,
                            floatSpeed: 0.005,
                            floatHeight: 0.2,
                            baseY: position.y,
                            floatTime: Math.random() * Math.PI * 2 // Random starting phase
                        };
                        
                        // Add glow effect for weapons
                        if (['shotgun', 'machinegun', 'rocketLauncher', 'sniper', 'railgun'].includes(type)) {
                            const pointLight = new THREE.PointLight(0x00ffff, 0.5, 2);
                            pointLight.position.set(0, 0, 0);
                            powerupMesh.add(pointLight);
                        }
                        
                        this.powerups.push(powerupMesh);
                        this.scene.add(powerupMesh);
                    }
                }

                updatePowerups() {
                    const currentTime = Date.now();
                    
                    if (this.state.powerups.speed.active && currentTime > this.state.powerups.speed.endTime) {
                        this.state.powerups.speed.active = false;
                        console.log('%cPOWERUP EXPIRED: Speed boost has worn off', 'color: orange; font-weight: bold');
                        this.updateSoldierFace();
                    }
                    if (this.state.powerups.invincibility.active && currentTime > this.state.powerups.invincibility.endTime) {
                        this.state.powerups.invincibility.active = false;
                        console.log('%cPOWERUP EXPIRED: Invincibility has worn off', 'color: orange; font-weight: bold');
                        this.updateSoldierFace();
                    }

                    this.powerups.forEach(powerup => {
                        // Rotate powerup
                        powerup.rotation.y += powerup.userData.rotationSpeed;
                        
                        // Add floating animation
                        if (powerup.userData.floatSpeed) {
                            powerup.userData.floatTime += powerup.userData.floatSpeed;
                            const floatOffset = Math.sin(powerup.userData.floatTime) * powerup.userData.floatHeight;
                            powerup.position.y = powerup.userData.baseY + floatOffset;
                        }
                    });

                    this.checkPowerupCollisions();
                }

                checkPowerupCollisions() {
                    const playerPosition = this.camera.position.clone();
                    const collectionRadius = 1.5;

                    for (let i = this.powerups.length - 1; i >= 0; i--) {
                        const powerup = this.powerups[i];
                        const distance = playerPosition.distanceTo(powerup.position);
                        
                        if (distance < collectionRadius) {
                            this.collectPowerup(powerup);
                            this.scene.remove(powerup);
                            this.powerups.splice(i, 1);
                        }
                    }
                }

                collectPowerup(powerup) {
                    // Play pickup sound
                    this.sounds.pickup = this.sounds.pickup || { play: () => this.playSound(660, 0.1, 'sine') };
                    this.sounds.pickup.play();
                    
                    const type = powerup.userData.type;
                    console.log(`%cITEM COLLECTED: ${type.toUpperCase()}`, 'color: yellow; font-weight: bold');
                    
                    switch(type) {
                        case 'health':
                            const healthBefore = this.state.health;
                            this.state.health = Math.min(this.state.health + 50, 100);
                            console.log(`Health increased from ${healthBefore} to ${this.state.health}`);
                            break;
                        case 'speed':
                            this.state.powerups.speed.active = true;
                            this.state.powerups.speed.endTime = Date.now() + this.config.powerupDuration;
                            const speedEndTime = new Date(this.state.powerups.speed.endTime);
                            console.log(`Speed boost activated until ${speedEndTime.toLocaleTimeString()}`);
                            break;
                        case 'invincibility':
                            this.state.powerups.invincibility.active = true;
                            this.state.powerups.invincibility.endTime = Date.now() + this.config.powerupDuration;
                            const invincibilityEndTime = new Date(this.state.powerups.invincibility.endTime);
                            console.log(`Invincibility activated until ${invincibilityEndTime.toLocaleTimeString()}`);
                            break;
                        default:
                            // Weapon pickup
                            const weapon = type;
                            if (this.state.weapons[weapon]) {
                                if (this.state.weapons[weapon].owned) {
                                    // Add ammo if already owned
                                    const ammoBefore = this.state.weapons[weapon].ammo;
                                    this.state.weapons[weapon].ammo = Math.min(
                                        this.state.weapons[weapon].ammo + this.config.weapons[weapon].ammo,
                                        this.config.weapons[weapon].maxAmmo
                                    );
                                    console.log(`Added ammo to ${weapon}: ${ammoBefore}  ${this.state.weapons[weapon].ammo}`);
                                } else {
                                    // Get new weapon
                                    this.state.weapons[weapon].owned = true;
                                    this.state.weapons[weapon].ammo = this.config.weapons[weapon].ammo;
                                    // Update last used weapon before switching to new weapon
                                    if (weapon !== this.state.currentWeapon) {
                                        this.state.lastUsedWeapon = this.state.currentWeapon;
                                    }
                                    this.state.currentWeapon = weapon; // Auto-equip new weapon
                                    
                                    // Ensure crosshair is visible when getting new weapon
                                    const crosshair = document.getElementById('crosshair');
                                    if (crosshair) {
                                        crosshair.style.display = 'block';
                                    }
                                    
                                    console.log(`Acquired new weapon: ${weapon} with ${this.state.weapons[weapon].ammo} ammo`);
                                }
                            }
                    }
                    
                    // Display pickup message
                    this.showPickupMessage(type);
                    
                    this.updateHUD();
                    this.updateWeaponPanel();
                    this.updateSoldierFace();
                }

                // New method to show pickup messages
                showPickupMessage(type) {
                    let message = '';
                    switch(type) {
                        case 'health':
                            message = 'Health Pack +50 HP';
                            break;
                        case 'speed':
                            message = 'Speed Boost Activated!';
                            break;
                        case 'invincibility':
                            message = 'Invincibility Shield Activated!';
                            break;
                        case 'shotgun':
                            message = 'Picked up Shotgun';
                            break;
                        case 'machinegun':
                            message = 'Picked up Machine Gun';
                            break;
                        case 'rocketLauncher':
                            message = 'Picked up Rocket Launcher';
                            break;
                        case 'railgun':
                            message = 'Picked up Railgun';
                            break;
                    }
                    
                    if (message) {
                        // Create or reuse pickup message element
                        let pickupMsg = document.getElementById('pickup-message');
                        if (!pickupMsg) {
                            pickupMsg = document.createElement('div');
                            pickupMsg.id = 'pickup-message';
                            pickupMsg.style.cssText = `
                                position: fixed;
                                top: 50%;
                                left: 50%;
                                transform: translate(-50%, -50%);
                                color: #fff;
                                font-size: 24px;
                                font-weight: bold;
                                text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
                                text-align: center;
                                opacity: 0;
                                transition: opacity 0.3s ease-in-out;
                                pointer-events: none;
                            `;
                            document.body.appendChild(pickupMsg);
                        }
                        
                        // Display message with fade effect
                        pickupMsg.textContent = message;
                        pickupMsg.style.opacity = 1;
                        
                        // Clear any existing timeout
                        if (this.pickupMessageTimeout) {
                            clearTimeout(this.pickupMessageTimeout);
                        }
                        
                        // Set fade out
                        this.pickupMessageTimeout = setTimeout(() => {
                            pickupMsg.style.opacity = 0;
                        }, 1500);
                    }
                }

                updateHUD() {
                    // Update only the level and enemies count
                    document.getElementById('level').textContent = this.state.level;
                    document.getElementById('enemies').textContent = this.state.enemiesRemaining;
                }

                setupWeaponPanel() {
                    const panel = document.createElement('div');
                    panel.style.cssText = `
                        position: fixed;
                        bottom: 0;
                        left: 0;
                        width: 100%;
                        height: 90px;
                        background: rgba(0, 0, 0, 0.7);
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        padding: 5px;
                    `;

                    const contentContainer = document.createElement('div');
                    contentContainer.style.cssText = `
                        display: flex;
                        align-items: center;
                        gap: 8px;
                    `;

                    // Add soldier face with scaled down dimensions
                    const faceContainer = this.setupSoldierFace();
                    faceContainer.style.cssText = `
                        width: 90px;
                        height: 80px;
                        background-color: rgba(0, 0, 0, 0.5);
                        border: 2px solid #666;
                        border-radius: 8px;
                        padding: 5px;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                    `;

                    // Scale down the face elements
                    const faceDiv = faceContainer.querySelector('#soldier-face');
                    if (faceDiv) {
                        faceDiv.style.width = '70px';
                        faceDiv.style.height = '70px';
                        faceDiv.style.borderRadius = '35px';
                    }

                    // Scale down the eyes
                    const eyes = faceContainer.querySelectorAll('.eye');
                    eyes.forEach(eye => {
                        eye.style.width = '18px';
                        eye.style.height = '12px';
                        eye.style.top = '10px';
                    });
                    const leftEye = faceContainer.querySelector('#left-eye');
                    if (leftEye) leftEye.style.left = '15px';
                    const rightEye = faceContainer.querySelector('#right-eye');
                    if (rightEye) rightEye.style.right = '15px';

                    // Scale down the pupils
                    const pupils = faceContainer.querySelectorAll('.pupil');
                    pupils.forEach(pupil => {
                        pupil.style.width = '7px';
                        pupil.style.height = '7px';
                    });

                    // Scale down the mouth
                    const mouth = faceContainer.querySelector('#mouth');
                    if (mouth) {
                        mouth.style.width = '35px';
                        mouth.style.height = '9px';
                        mouth.style.top = '40px';  // Changed to position from top instead of bottom
                        mouth.style.left = '18px';
                    }

                    // Scale down the health text
                    const healthText = faceContainer.querySelector('#soldier-health-text');
                    if (healthText) {
                        healthText.style.fontSize = '12px';
                        healthText.style.marginTop = '2px';
                    }

                    contentContainer.appendChild(faceContainer);

                    const weapons = ['grapplingHook', 'pistol', 'shotgun', 'machinegun', 'rocketLauncher', 'railgun'];
                    weapons.forEach((weapon, index) => {
                        const weaponDiv = document.createElement('div');
                        weaponDiv.id = `weapon-${weapon}`;
                        weaponDiv.style.cssText = `
                            color: white;
                            padding: 5px;
                            text-align: center;
                            border: 2px solid #666;
                            width: 90px;
                            height: 80px;
                            display: flex;
                            flex-direction: column;
                            justify-content: center;
                            background-color: rgba(0, 0, 0, 0.5);
                            border-radius: 8px;
                            font-size: 14px;
                        `;
                        
                        weaponDiv.innerHTML = `
                            <div style="margin-bottom: 4px;">${weapon.charAt(0).toUpperCase() + weapon.slice(1)}</div>
                            <div id="ammo-${weapon}" style="margin-bottom: 2px;">0/${this.config.weapons[weapon].maxAmmo}</div>
                            <div style="font-size: 10px;">(${index + 1})</div>
                        `;
                        
                        contentContainer.appendChild(weaponDiv);
                    });

                    panel.appendChild(contentContainer);
                    document.body.appendChild(panel);
                    
                    // Initial update of soldier face
                    this.updateSoldierFace();
                }

                updateWeaponPanel() {
                    const weapons = ['grapplingHook', 'pistol', 'shotgun', 'machinegun', 'rocketLauncher', 'railgun'];
                    
                    weapons.forEach(weapon => {
                        const weaponDiv = document.getElementById(`weapon-${weapon}`);
                        const ammoDiv = document.getElementById(`ammo-${weapon}`);
                        
                        if (this.state.currentWeapon === weapon) {
                            weaponDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                        } else {
                            weaponDiv.style.backgroundColor = 'transparent';
                        }

                        if (this.state.weapons[weapon].owned) {
                            weaponDiv.style.opacity = '1';
                            if (weapon === 'pistol' || weapon === 'grapplingHook') {
                                ammoDiv.textContent = '';  // Show infinity symbol for pistol and grappling hook
                            } else {
                                ammoDiv.textContent = `${this.state.weapons[weapon].ammo}/${this.config.weapons[weapon].maxAmmo}`;
                            }
                        } else {
                            weaponDiv.style.opacity = '0.5';
                            ammoDiv.textContent = '---';
                        }
                    });
                }

                setupHealthBar() {
                    const healthContainer = document.createElement('div');
                    healthContainer.style.cssText = `
                        position: fixed;
                        top: 20px;
                        left: 20px;
                        width: 200px;
                        height: 20px;
                        background: rgba(0, 0, 0, 0.5);
                        border: 2px solid #fff;
                    `;

                    const healthBar = document.createElement('div');
                    healthBar.id = 'health-bar';
                    healthBar.style.cssText = `
                        width: 100%;
                        height: 100%;
                        background: #ff0000;
                        transition: width 0.3s;
                    `;

                    healthContainer.appendChild(healthBar);
                    document.body.appendChild(healthContainer);
                }

                updateHealthBar() {
                    const healthBar = document.getElementById('health-bar');
                    if (healthBar) {
                        const healthPercent = (this.state.health / 100) * 100;
                        healthBar.style.width = `${healthPercent}%`;
                    }
                    
                    // Update soldier face when health changes
                    this.updateSoldierFace();
                }

                updateWeaponPosition() {
                    if (!this.weaponModels[this.state.currentWeapon]) return;

                    const weapon = this.weaponModels[this.state.currentWeapon];
                    if (!this.weaponContainer.children.includes(weapon)) {
                        this.weaponContainer.clear();
                        this.weaponContainer.add(weapon);
                        
                        weapon.traverse(child => {
                            if (child.isMesh) {
                                child.renderOrder = 999;
                                if (child.material) {
                                    child.material.depthTest = false;
                                    child.material.depthWrite = false;
                                }
                            }
                        });
                    }

                    // Base position
                    const basePosition = new THREE.Vector3(0., -0.4, -0.5);
                    
                    // Handle weapon bob
                    if (this.keys.w || this.keys.s || this.keys.a || this.keys.d) {
                        this.state.weaponBob.time += 0.1;
                        this.state.weaponBob.offset.y = Math.sin(this.state.weaponBob.time) * this.state.weaponBob.intensity;
                        this.state.weaponBob.offset.x = Math.cos(this.state.weaponBob.time * 0.5) * this.state.weaponBob.intensity * 0.5;
                    } else {
                        this.state.weaponBob.offset.lerp(new THREE.Vector3(0, 0, 0), 0.1);
                    }

                    // Handle recoil recovery
                    const currentTime = Date.now();
                    if (currentTime - this.state.recoil.lastShootTime > this.state.recoil.recoveryDelay) {
                        this.state.recoil.current *= 0.9; // Exponential decay
                        if (this.state.recoil.current < 0.001) this.state.recoil.current = 0;
                    }

                    // Calculate recoil offset
                    const recoilOffset = new THREE.Vector3(
                        0,
                        -Math.sin(this.state.recoil.current * Math.PI) * 0.1,
                        this.state.recoil.current
                    );

                    // Apply all offsets
                    weapon.position.copy(basePosition)
                        .add(this.state.weaponBob.offset)
                        .add(recoilOffset);

                    // Apply rotation with recoil
                    const recoilRotation = -this.state.recoil.current * 0.5;
                    if (this.state.currentWeapon === 'rocketLauncher') {
                        weapon.rotation.set(
                            this.rotationX * 0.2 + recoilRotation,
                            -Math.PI / 2,
                            0
                        );
                    } else {
                        weapon.rotation.set(
                            this.rotationX * 0.2 + recoilRotation,
                            0,
                            0
                        );
                    }

                    weapon.scale.set(1.5, 1.5, 1.5);
                }

                render() {
                    // Ensure weapon container and its children have highest render order
                    this.weaponContainer.renderOrder = 999;
                    this.weaponContainer.traverse(child => {
                        if (child.isMesh) {
                            child.renderOrder = 999;
                            if (child.material) {
                                child.material.transparent = true;
                                child.material.depthTest = false;
                                child.material.depthWrite = false;
                            }
                        }
                    });
                    
                    // Render scene
                    this.renderer.render(this.scene, this.camera);
                }

                // Add this cleanup method
                cleanup() {
                    // Remove all weapons from both scenes
                    if (this.weaponScene) {
                        while(this.weaponScene.children.length > 0) {
                            this.weaponScene.remove(this.weaponScene.children[0]);
                        }
                    }
                    
                    const weaponsToRemove = this.scene.children.filter(child => 
                        child.name === 'weapon' || child.name === 'pistol' || child.name === 'gun'
                    );
                    weaponsToRemove.forEach(weapon => this.scene.remove(weapon));
                }

                // Call cleanup when changing weapons or restarting game
                // Add to your game reset or level change functions
                resetGame() {
                    this.cleanup();
                    this.setupWeapons();
                    // ... other reset code ...
                }

                // Create the soldier face UI
                setupSoldierFace() {
                    // Create container for soldier face
                    const faceContainer = document.createElement('div');
                    faceContainer.id = 'soldier-face-container';
                    faceContainer.style.cssText = `
                        width: 150px;
                        height: 150px;
                        background-color: rgba(0, 0, 0, 0.5);
                        border: 2px solid #666;
                        border-radius: 10px;
                        padding: 10px;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                    `;
                    
                    // Create face elements
                    const faceDiv = document.createElement('div');
                    faceDiv.id = 'soldier-face';
                    faceDiv.style.cssText = `
                        width: 120px;
                        height: 120px;
                        position: relative;
                        background-color: #a87c5c;
                        border-radius: 60px;
                        overflow: hidden;
                    `;
                    
                    // Create eyes
                    const leftEye = document.createElement('div');
                    leftEye.id = 'left-eye';
                    leftEye.className = 'eye';
                    leftEye.style.cssText = `
                        position: absolute;
                        width: 30px;
                        height: 20px;
                        background-color: white;
                        border-radius: 50%;
                        top: 30px;
                        left: 25px;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                    `;
                    
                    const rightEye = document.createElement('div');
                    rightEye.id = 'right-eye';
                    rightEye.className = 'eye';
                    rightEye.style.cssText = `
                        position: absolute;
                        width: 30px;
                        height: 20px;
                        background-color: white;
                        border-radius: 50%;
                        top: 30px;
                        right: 25px;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                    `;
                    
                    // Create pupils
                    const leftPupil = document.createElement('div');
                    leftPupil.id = 'left-pupil';
                    leftPupil.className = 'pupil';
                    leftPupil.style.cssText = `
                        width: 12px;
                        height: 12px;
                        background-color: #000;
                        border-radius: 50%;
                    `;
                    
                    const rightPupil = document.createElement('div');
                    rightPupil.id = 'right-pupil';
                    rightPupil.className = 'pupil';
                    rightPupil.style.cssText = `
                        width: 12px;
                        height: 12px;
                        background-color: #000;
                        border-radius: 50%;
                    `;
                    
                    // Create mouth
                    const mouth = document.createElement('div');
                    mouth.id = 'mouth';
                    mouth.style.cssText = `
                        position: absolute;
                        width: 60px;
                        height: 15px;
                        background-color: #600;
                        border-radius: 0 0 30px 30px;
                        bottom: 30px;
                        left: -30px;
                    `;
                    
                    // Create blood overlay
                    const bloodOverlay = document.createElement('div');
                    bloodOverlay.id = 'blood-overlay';
                    bloodOverlay.style.cssText = `
                        position: absolute;
                        width: 100%;
                        height: 100%;
                        background: linear-gradient(transparent 50%, rgba(255,0,0,0.5));
                        top: 0;
                        left: 0;
                        pointer-events: none;
                        display: none;
                        z-index: 2;
                    `;
                    
                    // Create health text
                    const healthText = document.createElement('div');
                    healthText.id = 'soldier-health-text';
                    healthText.style.cssText = `
                        color: white;
                        font-size: 18px;
                        font-weight: bold;
                        text-align: center;
                        margin-top: 5px;
                    `;
                    healthText.textContent = '100%';
                    
                    // Assemble the face elements
                    leftEye.appendChild(leftPupil);
                    rightEye.appendChild(rightPupil);
                    
                    // Add elements to face in correct order
                    faceDiv.appendChild(bloodOverlay);
                    faceDiv.appendChild(leftEye);
                    faceDiv.appendChild(rightEye);
                    faceDiv.appendChild(mouth);
                    
                    faceContainer.appendChild(faceDiv);
                    faceContainer.appendChild(healthText);
                    
                    return faceContainer;
                }

                // Update the soldier face based on health and powerups
                updateSoldierFace() {
                    const health = this.state.health;
                    const hasSpeed = this.state.powerups.speed.active;
                    const hasInvincibility = this.state.powerups.invincibility.active;
                    
                    // Update health text
                    const healthText = document.getElementById('soldier-health-text');
                    if (healthText) {
                        healthText.textContent = `${health}%`;
                        
                        // Change color based on health
                        if (health > 75) {
                            healthText.style.color = '#0f0'; // Green for high health
                        } else if (health > 50) {
                            healthText.style.color = '#ff0'; // Yellow for medium health
                        } else if (health > 25) {
                            healthText.style.color = '#f90'; // Orange for low health
                        } else {
                            healthText.style.color = '#f00'; // Red for critical health
                        }
                    }
                    
                    // Blood effect when health is low
                    const bloodOverlay = document.getElementById('blood-overlay');
                    if (bloodOverlay) {
                        // Changed condition to show blood earlier and made it more visible
                        if (health <= 50) {
                            bloodOverlay.style.display = 'block';
                            const opacity = (100 - health) / 100 * 0.7; // Adjusted opacity calculation
                            bloodOverlay.style.background = `linear-gradient(transparent 50%, rgba(255,0,0,${opacity}))`;
                        } else {
                            bloodOverlay.style.display = 'none';
                        }
                    }
                    
                    // Update mouth based on health - adjusted expressions
                    const mouth = document.getElementById('mouth');
                    if (mouth) {
                        if (health > 75) {
                            // Happy
                            mouth.style.height = '15px';
                            mouth.style.borderRadius = '0 0 30px 30px';
                            mouth.style.bottom = '30px';
                        } else if (health > 50) {
                            // Slight smile
                            mouth.style.height = '10px';
                            mouth.style.borderRadius = '0 0 20px 20px';
                            mouth.style.bottom = '32px';
                        } else if (health > 25) {
                            // Straight
                            mouth.style.height = '5px';
                            mouth.style.borderRadius = '0';
                            mouth.style.bottom = '35px';
                        } else {
                            // Pain - made more pronounced
                            mouth.style.height = '15px';
                            mouth.style.borderRadius = '30px 30px 0 0'; // Inverted curve for frown
                            mouth.style.bottom = '25px'; // Moved lower
                            mouth.style.backgroundColor = '#800'; // Darker red
                        }
                    }
                    
                    // Update eyes based on powerups and health - made low health more visible
                    const eyes = document.querySelectorAll('.eye');
                    const pupils = document.querySelectorAll('.pupil');
                    
                    if (hasInvincibility) {
                        // Golden eyes for invincibility
                        eyes.forEach(eye => {
                            eye.style.height = '20px';
                            eye.style.backgroundColor = '#ffd700';
                            eye.style.boxShadow = '0 0 10px #ffd700';
                        });
                        pupils.forEach(pupil => {
                            pupil.style.backgroundColor = '#ff8c00';
                        });
                    } else if (hasSpeed) {
                        // Flame eyes for speed
                        eyes.forEach(eye => {
                            eye.style.height = '20px';
                            eye.style.backgroundColor = '#ff3300';
                            eye.style.boxShadow = '0 0 10px #ff3300';
                        });
                        pupils.forEach(pupil => {
                            pupil.style.backgroundColor = '#ffcc00';
                        });
                    } else if (health <= 25) {
                        // Pain expression - made more dramatic
                        eyes.forEach(eye => {
                            eye.style.height = '6px'; // More squinted
                            eye.style.backgroundColor = '#ffcccc'; // Slightly reddish
                            eye.style.transform = 'rotate(-10deg)'; // Angled for pain
                        });
                        pupils.forEach(pupil => {
                            pupil.style.height = '3px'; // More squinted
                            pupil.style.backgroundColor = '#600'; // Dark red
                        });
                    } else {
                        // Normal eyes
                        eyes.forEach(eye => {
                            eye.style.height = '20px';
                            eye.style.backgroundColor = 'white';
                            eye.style.boxShadow = 'none';
                            eye.style.transform = 'none';
                        });
                        pupils.forEach(pupil => {
                            pupil.style.height = '12px';
                            pupil.style.backgroundColor = 'black';
                        });
                    }
                }

                checkRailgunWallCollision(raycaster) {
                    const cellSize = this.config.cellSize;
                    const maxDistance = 100;
                    const steps = 100;
                    const stepSize = maxDistance / steps;
                    
                    for (let i = 0; i < steps; i++) {
                        const point = raycaster.ray.at(i * stepSize, new THREE.Vector3());
                        const gridX = Math.floor((point.x + (this.config.mazeSize * cellSize / 2)) / cellSize);
                        const gridZ = Math.floor((point.z + (this.config.mazeSize * cellSize / 2)) / cellSize);
                        
                        if (gridX < 0 || gridX >= this.config.mazeSize || 
                            gridZ < 0 || gridZ >= this.config.mazeSize ||
                            this.maze[gridX][gridZ] === 1) {
                            return point;
                        }
                    }
                    return null;
                }

                fireRailgun() {
                    const weaponConfig = this.config.weapons.railgun;

                    // Get exact direction where camera/crosshair is pointing
                    const direction = new THREE.Vector3(0, 0, -1);
                    direction.unproject(this.camera);
                    direction.sub(this.camera.position).normalize();

                    const railgunGroup = new THREE.Group();

                    // Define railgun projectile geometry
                    const railPoints = [
                        new THREE.Vector2(0, 0),
                        new THREE.Vector2(0.03, 0.2),
                        new THREE.Vector2(0.03, 1.0),
                        new THREE.Vector2(0, 1.0)
                    ];
                    const railGeometry = new THREE.LatheGeometry(railPoints, 8);
                    const railMaterial = new THREE.MeshStandardMaterial({
                        color: weaponConfig.beamColor,
                        emissive: weaponConfig.beamColor,
                        emissiveIntensity: 1,
                        metalness: 0.9,
                        roughness: 0.2
                    });
                    const railProjectile = new THREE.Mesh(railGeometry, railMaterial);
                    railProjectile.rotation.x = Math.PI / 2;
                    railgunGroup.add(railProjectile);

                    // Add a glow light
                    const glowLight = new THREE.PointLight(weaponConfig.beamColor, 2, 2);
                    railgunGroup.add(glowLight);

                    // Create a longer, spinning tail
                    const tailLength = 50;
                    const trailGeometry = new THREE.BufferGeometry();
                    const trailMaterial = new THREE.LineBasicMaterial({
                        color: weaponConfig.beamColor,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    // Create spiral trail positions
                    const trailPositions = new Float32Array(tailLength * 3);
                    const radius = 0.1;
                    for (let i = 0; i < tailLength; i++) {
                        const t = i / tailLength;
                        const angle = t * Math.PI * 8;
                        trailPositions[i * 3] = Math.cos(angle) * radius * (1 - t);
                        trailPositions[i * 3 + 1] = Math.sin(angle) * radius * (1 - t);
                        trailPositions[i * 3 + 2] = -i * 0.1;
                    }
                    
                    trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
                    const trail = new THREE.Line(trailGeometry, trailMaterial);
                    railgunGroup.add(trail);

                    railgunGroup.position.copy(this.camera.position);
                    railgunGroup.position.add(direction.clone().multiplyScalar(0));
                    railgunGroup.position.y -= 0.1;
                    
                    const quaternion = new THREE.Quaternion();
                    quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction);
                    railgunGroup.quaternion.copy(quaternion);

                    railgunGroup.userData = {
                        velocity: direction.clone().multiplyScalar(0.5),
                        distance: 0,
                        maxDistance: 100,
                        damage: weaponConfig.damage,
                        type: 'railgun',
                        prevPosition: railgunGroup.position.clone(),
                        piercing: true,
                        spinSpeed: 0.5,
                        trail: trail,
                        trailCounter: 0,
                        rotationAngle: 0,
                        hitMonsters: new Set()
                    };

                    this.projectiles.push(railgunGroup);
                    this.scene.add(railgunGroup);

                    // Railgun sound effects
                    this.playSound(880, 0.1, 'sawtooth', 0.3);
                    this.playSound(440, 0.2, 'square', 0.2);
                    
                    // Set correct render order
                    railgunGroup.renderOrder = 0;
                    railgunGroup.traverse(child => {
                        if (child.isMesh) {
                            child.renderOrder = 0;
                            child.material.depthTest = true;
                            child.material.depthWrite = true;
                        }
                    });
                }

            addScreenShake(intensity = 0.1, duration = 100) {
                if (!this.screenShakeEffect) {
                    this.screenShakeEffect = {
                        intensity: 0,
                        duration: 0,
                        startTime: 0,
                        originalPosition: new THREE.Vector3(),
                        shakeOffset: new THREE.Vector3()
                    };
                }
                
                // Set shake parameters
                this.screenShakeEffect.intensity = intensity;
                this.screenShakeEffect.duration = duration;
                this.screenShakeEffect.startTime = Date.now();
                this.screenShakeEffect.originalPosition.copy(this.camera.position);
                
                // Apply initial shake
                this.applyScreenShake();
                
                // Set interval to update shake
                const shakeInterval = setInterval(() => {
                    if (Date.now() - this.screenShakeEffect.startTime >= this.screenShakeEffect.duration) {
                        clearInterval(shakeInterval);
                        // Reset camera position
                        this.camera.position.sub(this.screenShakeEffect.shakeOffset);
                        this.screenShakeEffect.shakeOffset.set(0, 0, 0);
                    } else {
                        this.applyScreenShake();
                    }
                }, 16); // ~60fps
            }
            
            applyScreenShake() {
                // Remove previous offset
                this.camera.position.sub(this.screenShakeEffect.shakeOffset);
                
                // Calculate new random offset
                const timeLeft = 1 - ((Date.now() - this.screenShakeEffect.startTime) / this.screenShakeEffect.duration);
                const currentIntensity = this.screenShakeEffect.intensity * timeLeft;
                
                this.screenShakeEffect.shakeOffset.set(
                    (Math.random() * 2 - 1) * currentIntensity,
                    (Math.random() * 2 - 1) * currentIntensity * 0.5,  // Less vertical shake
                    (Math.random() * 2 - 1) * currentIntensity
                );
                
                // Apply new offset
                this.camera.position.add(this.screenShakeEffect.shakeOffset);
            }

            // New helper function to find direction away from nearest wall
            findNearestWallDirection(position) {
                const cellSize = this.config.cellSize;
                const gridX = Math.floor((position.x + (this.config.mazeSize * cellSize / 2)) / cellSize);
                const gridZ = Math.floor((position.z + (this.config.mazeSize * cellSize / 2)) / cellSize);
                
                let closestWallDistance = Infinity;
                let closestWallDirection = null;
                
                // Check all adjacent cells (including diagonals)
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        if (dx === 0 && dz === 0) continue; // Skip self
                        
                        const checkX = gridX + dx;
                        const checkZ = gridZ + dz;
                        
                        if (checkX < 0 || checkX >= this.config.mazeSize || 
                            checkZ < 0 || checkZ >= this.config.mazeSize) {
                            continue;
                        }
                        
                        if (this.maze[checkX][checkZ] === 1) { // It's a wall
                            const wallX = (checkX - this.config.mazeSize/2) * cellSize;
                            const wallZ = (checkZ - this.config.mazeSize/2) * cellSize;
                            
                            const dx = position.x - wallX;
                            const dz = position.z - wallZ;
                            const distance = Math.sqrt(dx*dx + dz*dz);
                            
                            if (distance < closestWallDistance) {
                                closestWallDistance = distance;
                                closestWallDirection = new THREE.Vector3(dx, 0, dz).normalize();
                            }
                        }
                    }
                }
                
                return closestWallDirection;
            }

            spawnTestMonster(type) {
                let position;
                let attempts = 0;
                const maxAttempts = 100;
                
                do {
                    // Calculate position within the maze bounds
                    const gridX = Math.floor(Math.random() * (this.config.mazeSize - 2)) + 1;
                    const gridZ = Math.floor(Math.random() * (this.config.mazeSize - 2)) + 1;
                    
                    position = new THREE.Vector3(
                        (gridX - this.config.mazeSize/2) * this.config.cellSize,
                        type === 'flying' ? 3.0 : 0,
                        (gridZ - this.config.mazeSize/2) * this.config.cellSize
                    );
                    
                    attempts++;
                } while (this.checkCollision(position, true) && attempts < maxAttempts);
                
                if (attempts < maxAttempts) {
                    const monster = this.createMonster(type);
                    monster.position.copy(position);
                    this.monsters.push(monster);
                    this.scene.add(monster);
                    this.state.enemiesRemaining = this.monsters.length;
                    document.getElementById('enemies').textContent = this.state.enemiesRemaining;
                    console.log(`Spawned test ${type} monster at position (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)})`);
                } else {
                    console.warn("Could not find valid spawn position for monster after", maxAttempts, "attempts");
                }
            }

            spawnTestWeapon(type) {
                let position;
                let attempts = 0;
                const maxAttempts = 100;
                
                do {
                    // Calculate position within the maze bounds
                    const gridX = Math.floor(Math.random() * (this.config.mazeSize - 2)) + 1;
                    const gridZ = Math.floor(Math.random() * (this.config.mazeSize - 2)) + 1;
                    
                    position = new THREE.Vector3(
                        (gridX - this.config.mazeSize/2) * this.config.cellSize,
                        0.5,
                        (gridZ - this.config.mazeSize/2) * this.config.cellSize
                    );
                    
                    attempts++;
                } while (this.checkCollision(position) && attempts < maxAttempts);
                
                if (attempts < maxAttempts) {
                    this.createPowerup(type, position);
                    console.log(`Spawned test ${type} at position (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)})`);
                } else {
                    console.warn("Could not find valid spawn position for", type, "after", maxAttempts, "attempts");
                }
            }

            fireGrapplingHook() {
                // Only allow one hook at a time
                if (this.state.grappling.hook) return;

                // Get exact direction where camera/crosshair is pointing
                const direction = new THREE.Vector3(0, 0, -1);
                direction.unproject(this.camera);
                direction.sub(this.camera.position).normalize();

                const hookGroup = new THREE.Group();

                // Create hook head
                const hookHead = new THREE.Mesh(
                    new THREE.ConeGeometry(0.1, 0.2, 3),
                    new THREE.MeshStandardMaterial({
                        color: 0x888888,
                        metalness: 0.8,
                        roughness: 0.2
                    })
                );
                hookHead.rotation.x = Math.PI / 2;
                hookGroup.add(hookHead);

                // Create trailing line
                const lineGeometry = new THREE.BufferGeometry();
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0x444444,
                    linewidth: 2
                });
                
                // Initialize with two points (will be updated)
                const points = new Float32Array(6); // 2 points  3 coordinates
                lineGeometry.setAttribute('position', new THREE.BufferAttribute(points, 3));
                const line = new THREE.Line(lineGeometry, lineMaterial);
                this.scene.add(line);

                hookGroup.position.copy(this.camera.position);
                hookGroup.position.y -= 0.2;

                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction);
                hookGroup.quaternion.copy(quaternion);

                hookGroup.userData = {
                    velocity: direction.clone().multiplyScalar(this.config.weapons.grapplingHook.speed),
                    distance: 0,
                    maxDistance: this.config.weapons.grapplingHook.hookRange,
                    type: 'grapplingHook',
                    prevPosition: hookGroup.position.clone(),
                    startPoint: this.camera.position.clone(),
                    line: line,
                    isReturning: false,
                    returnSpeed: this.config.weapons.grapplingHook.speed * 1.5
                };

                this.state.grappling.hook = hookGroup;
                this.scene.add(hookGroup);

                // Play grappling hook sound
                this.playSound(440, 0.1, 'square', 0.2);
            }

            updateGrapplingHook() {
                const hook = this.state.grappling.hook;
                if (!hook) return;

                // Update trailing line
                const line = hook.userData.line;
                const linePositions = line.geometry.attributes.position.array;
                
                // Update gun-end position
                const gunPosition = this.camera.position.clone();
                gunPosition.y -= 0.2;
                linePositions[0] = gunPosition.x;
                linePositions[1] = gunPosition.y;
                linePositions[2] = gunPosition.z;
                
                // Update hook-end position
                linePositions[3] = hook.position.x;
                linePositions[4] = hook.position.y;
                linePositions[5] = hook.position.z;
                
                line.geometry.attributes.position.needsUpdate = true;

                if (hook.userData.isReturning) {
                    // Return hook to player
                    const returnDirection = new THREE.Vector3()
                        .subVectors(gunPosition, hook.position)
                        .normalize();
                    
                    hook.position.add(returnDirection.multiplyScalar(hook.userData.returnSpeed));
                    
                    // Remove hook when it gets close enough to player
                    if (hook.position.distanceTo(gunPosition) < 0.5) {
                        this.releaseGrapplingHook();
                    }
                    return;
                }

                if (!this.state.grappling.isHooked) {
                    if (!this.state.isMouseDown) {
                        // Start returning if mouse released during flight
                        hook.userData.isReturning = true;
                        return;
                    }

                    // Update hook position while flying
                    hook.position.add(hook.userData.velocity);
                    hook.userData.distance = hook.position.distanceTo(hook.userData.startPoint);

                    // Check for collision with walls or max distance
                    // Prevent hooking to ground by checking Y position
                    if ((this.checkCollision(hook.position, false, true) && hook.position.y > 0.5) || 
                        hook.userData.distance > hook.userData.maxDistance) {
                        if (this.checkCollision(hook.position, false, true) && hook.position.y > 0.5) {
                            // Hook hit something valid, start pulling
                            this.state.grappling.isHooked = true;
                            this.state.grappling.hookPoint = hook.position.clone();
                            
                            // Play hook hit sound
                            this.playSound(880, 0.1, 'square', 0.3);
                        } else {
                            // Start returning if max distance reached or invalid hook point
                            hook.userData.isReturning = true;
                        }
                    }
                } else {
                    if (!this.state.isMouseDown) {
                        // Store current pull direction for momentum
                        const pullDir = this.state.grappling.lastPullDirection;
                        this.state.grappling.swingVelocity.set(
                            pullDir.x * this.config.weapons.grapplingHook.pullSpeed,
                            0,
                            pullDir.z * this.config.weapons.grapplingHook.pullSpeed
                        );
                        
                        // Start returning if mouse released while hooked
                        hook.userData.isReturning = true;
                        this.state.grappling.isHooked = false;
                        return;
                    }

                    // Calculate distance to hook point
                    const distanceToHook = this.camera.position.distanceTo(this.state.grappling.hookPoint);
                    
                    if (distanceToHook > 1) {  // Only pull if not already at hook point
                        // Pull player towards hook point
                        const pullDirection = new THREE.Vector3()
                            .subVectors(this.state.grappling.hookPoint, this.camera.position)
                            .normalize();
                        
                        // Store the pull direction for momentum
                        this.state.grappling.lastPullDirection.copy(pullDirection);
                        
                        const newPosition = this.camera.position.clone()
                            .add(pullDirection.multiplyScalar(this.config.weapons.grapplingHook.pullSpeed));

                        // Check for collision before moving
                        if (!this.checkCollision(newPosition)) {
                            this.camera.position.copy(newPosition);
                        } else {
                            // Hit a wall while being pulled, release hook
                            hook.userData.isReturning = true;
                            this.state.grappling.isHooked = false;
                        }
                    } else {
                        // At hook point - maintain position but store last direction for momentum
                        const currentDir = new THREE.Vector3()
                            .subVectors(this.state.grappling.hookPoint, this.camera.position)
                            .normalize();
                        this.state.grappling.lastPullDirection.copy(currentDir);
                    }
                }
            }

            releaseGrapplingHook() {
                if (this.state.grappling.hook) {
                    // Remove the trailing line
                    if (this.state.grappling.hook.userData.line) {
                        this.scene.remove(this.state.grappling.hook.userData.line);
                    }
                    this.scene.remove(this.state.grappling.hook);
                    this.state.grappling.hook = null;
                }
                
                // Store current pull direction for momentum before releasing
                if (this.state.grappling.isHooked) {
                    const pullDir = this.state.grappling.lastPullDirection;
                    this.state.grappling.swingVelocity.set(
                        pullDir.x * this.config.weapons.grapplingHook.pullSpeed * 2,  // Increased multiplier for more momentum
                        0,
                        pullDir.z * this.config.weapons.grapplingHook.pullSpeed * 2
                    );
                }
                
                this.state.grappling.isHooked = false;
                this.state.grappling.hookPoint = null;
                
                // Start falling if we're above ground level
                if (this.camera.position.y > this.config.playerHeight) {
                    this.isJumping = true;
                    this.jumpVelocity = 0;  // Start with zero upward velocity
                }

                // Play release sound
                this.playSound(220, 0.1, 'square', 0.1);
            }

        } // Close the Game class definition here

        let game = null;

        function startGame(mode) {
            // Hide mode selection and show game
            document.getElementById('mode-selection').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
            
            // Initialize game with selected mode
            game = new Game(mode);
            
            // Add spawn panel if in test mode
            if (mode === 'testing') {
                const spawnPanel = document.createElement('div');
                spawnPanel.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    height: 100vh;
                    width: 150px;
                    background: rgba(0, 0, 0, 0.8);
                    padding: 10px;
                    border-right: 2px solid #ff0000;
                    color: white;
                    z-index: 1000;
                    overflow-y: auto;
                `;
                
                spawnPanel.innerHTML = `
                    <h3 style="font-size: 14px; margin: 5px 0;">Test Controls</h3>
                    <div style="margin: 5px 0;">
                        <h4 style="font-size: 12px; margin: 5px 0;">Player</h4>
                        <button onclick="game.state.health = 100; game.updateHealthBar(); game.updateSoldierFace();" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px; background: #4CAF50; color: white;">Refill Health</button>
                    </div>
                    <div style="margin: 5px 0;">
                        <h4 style="font-size: 12px; margin: 5px 0;">Monsters</h4>
                        <button onclick="game.spawnTestMonster('ground')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Ground Monster</button>
                        <button onclick="game.spawnTestMonster('flying')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Flying Monster</button>
                        <button onclick="game.spawnTestMonster('archer')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Archer Monster</button>
                        <button onclick="game.spawnTestMonster('spider')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Spider Monster</button>
                        <button onclick="game.spawnTestMonster('giant')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Giant Monster</button>
                        <button onclick="game.spawnTestMonster('charger')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Charger Monster</button>
                    </div>
                    <div style="margin: 5px 0;">
                        <h4 style="font-size: 12px; margin: 5px 0;">Weapons</h4>
                        <button onclick="game.spawnTestWeapon('shotgun')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Shotgun</button>
                        <button onclick="game.spawnTestWeapon('machinegun')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Machine Gun</button>
                        <button onclick="game.spawnTestWeapon('rocketLauncher')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Rocket Launcher</button>
                        <button onclick="game.spawnTestWeapon('railgun')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Railgun</button>
                    </div>
                    <div style="margin: 5px 0;">
                        <h4 style="font-size: 12px; margin: 5px 0;">Power-Ups</h4>
                        <button onclick="game.spawnTestWeapon('health')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Health Pack</button>
                        <button onclick="game.spawnTestWeapon('speed')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Speed Boost</button>
                        <button onclick="game.spawnTestWeapon('invincibility')" style="margin: 2px 0; padding: 5px; width: 100%; font-size: 12px;">Invincibility</button>
                    </div>
                `;
                
                document.body.appendChild(spawnPanel);
            }
            
            // Add resize listener
            window.addEventListener('resize', () => {
                game.camera.aspect = window.innerWidth / window.innerHeight;
                game.camera.updateProjectionMatrix();
                game.renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }


        </script>
    </body>
</html>